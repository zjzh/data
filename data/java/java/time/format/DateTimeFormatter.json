{"package_name": "java.time.format", "subclass_list": [], "class_description": "Formatter for printing and parsing date-time objects. This class provides the main application entry point for printing and parsing\n and provides common implementations of DateTimeFormatter: More complex formatters are provided by\n DateTimeFormatterBuilder. The main date-time classes provide two methods - one for formatting,\n format(DateTimeFormatter formatter), and one for parsing,\n parse(CharSequence text, DateTimeFormatter formatter). For example: In addition to the format, formatters can be created with desired Locale,\n Chronology, ZoneId, and DecimalStyle. The withLocale method returns a new formatter that\n overrides the locale. The locale affects some aspects of formatting and\n parsing. For example, the ofLocalizedDate provides a\n formatter that uses the locale specific date format. The withChronology method returns a new formatter\n that overrides the chronology. If overridden, the date-time value is\n converted to the chronology before formatting. During parsing the date-time\n value is converted to the chronology before it is returned. The withZone method returns a new formatter that overrides\n the zone. If overridden, the date-time value is converted to a ZonedDateTime\n with the requested ZoneId before formatting. During parsing the ZoneId is\n applied before the value is returned. The withDecimalStyle method returns a new formatter that\n overrides the DecimalStyle. The DecimalStyle symbols are used for\n formatting and parsing. Some applications may need to use the older Format\n class for formatting. The toFormat() method returns an\n implementation of java.text.Format. For example: All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The\n following pattern letters are defined: The count of pattern letters determines the format. Text: The text style is determined based on the number of pattern\n letters used. Less than 4 pattern letters will use the\n TextStyle#SHORT. Exactly 4 pattern letters will use the\n TextStyle#FULL. Exactly 5 pattern letters will use the\n TextStyle#NARROW.\n Pattern letters 'L', 'c', and 'q' specify the stand-alone form of the text styles. Number: If the count of letters is one, then the value is output using\n the minimum number of digits and without padding. Otherwise, the count of digits\n is used as the width of the output field, with the value zero-padded as necessary.\n The following pattern letters have constraints on the count of letters.\n Only one letter of 'c' and 'F' can be specified.\n Up to two letters of 'd', 'H', 'h', 'K', 'k', 'm', and 's' can be specified.\n Up to three letters of 'D' can be specified. Number/Text: If the count of pattern letters is 3 or greater, use the\n Text rules above. Otherwise use the Number rules above. Fraction: Outputs the nano-of-second field as a fraction-of-second.\n The nano-of-second value has nine digits, thus the count of pattern letters\n is from 1 to 9. If it is less than 9, then the nano-of-second value is\n truncated, with only the most significant digits being output. Year: The count of letters determines the minimum field width below\n which padding is used. If the count of letters is two, then a\n DateTimeFormatterBuilder#appendValueReduced two digit form is\n used. For printing, this outputs the rightmost two digits. For parsing, this\n will parse using the base value of 2000, resulting in a year within the range\n 2000 to 2099 inclusive. If the count of letters is less than four (but not\n two), then the sign is only output for negative years as per\n SignStyle#NORMAL. Otherwise, the sign is output if the pad width is\n exceeded, as per SignStyle#EXCEEDS_PAD. ZoneId: This outputs the time-zone ID, such as 'Europe/Paris'. If the\n count of letters is two, then the time-zone ID is output. Any other count of\n letters throws IllegalArgumentException. Zone names: This outputs the display name of the time-zone ID. If the\n count of letters is one, two or three, then the short name is output. If the\n count of letters is four, then the full name is output. Five or more letters\n throws IllegalArgumentException. Offset X and x: This formats the offset based on the number of pattern\n letters. One letter outputs just the hour, such as '+01', unless the minute\n is non-zero in which case the minute is also output, such as '+0130'. Two\n letters outputs the hour and minute, without a colon, such as '+0130'. Three\n letters outputs the hour and minute, with a colon, such as '+01:30'. Four\n letters outputs the hour and minute and optional second, without a colon,\n such as '+013015'. Five letters outputs the hour and minute and optional\n second, with a colon, such as '+01:30:15'. Six or more letters throws\n IllegalArgumentException. Pattern letter 'X' (upper case) will output\n 'Z' when the offset to be output would be zero, whereas pattern letter 'x'\n (lower case) will output '+00', '+0000', or '+00:00'. Offset O: This formats the localized offset based on the number of\n pattern letters. One letter outputs the TextStyle#SHORT\n form of the localized offset, which is localized offset text, such as 'GMT',\n with hour without leading zero, optional 2-digit minute and second if\n non-zero, and colon, for example 'GMT+8'. Four letters outputs the\n TextStyle#FULL form, which is localized offset text,\n such as 'GMT, with 2-digit hour and minute field, optional second field\n if non-zero, and colon, for example 'GMT+08:00'. Any other count of letters\n throws IllegalArgumentException. Offset Z: This formats the offset based on the number of pattern\n letters. One, two or three letters outputs the hour and minute, without a\n colon, such as '+0130'. The output will be '+0000' when the offset is zero.\n Four letters outputs the TextStyle#FULL form of localized\n offset, equivalent to four letters of Offset-O. The output will be the\n corresponding localized offset text if the offset is zero. Five\n letters outputs the hour, minute, with optional second if non-zero, with\n colon. It outputs 'Z' if the offset is zero.\n Six or more letters throws IllegalArgumentException. Optional section: The optional section markers work exactly like\n calling DateTimeFormatterBuilder#optionalStart() and\n DateTimeFormatterBuilder#optionalEnd(). Pad modifier: Modifies the pattern that immediately follows to be\n padded with spaces. The pad width is determined by the number of pattern\n letters. This is the same as calling\n DateTimeFormatterBuilder#padNext(int). For example, 'ppH' outputs the hour-of-day padded on the left with spaces to\n a width of 2. Any unrecognized letter is an error. Any non-letter character, other than\n '[', ']', '{', '}', '#' and the single quote will be output directly.\n Despite this, it is recommended to use single quotes around all characters\n that you want to output directly to ensure that future changes do not break\n your application. Five parsing methods are supplied by this class.\n Four of these perform both the parse and resolve phases.\n The fifth method, parseUnresolved(java.lang.CharSequence, java.text.ParsePosition),\n only performs the first phase, leaving the result unresolved.\n As such, it is essentially a low-level operation. The resolve phase is controlled by two parameters, set on this class. The ResolverStyle is an enum that offers three different approaches,\n strict, smart and lenient. The smart option is the default.\n It can be set using withResolverStyle(java.time.format.ResolverStyle). The withResolverFields(java.time.temporal.TemporalField) parameter allows the\n set of fields that will be resolved to be filtered before resolving starts.\n For example, if the formatter has parsed a year, month, day-of-month\n and day-of-year, then there are two approaches to resolve a date:\n (year + month + day-of-month) and (year + day-of-year).\n The resolver fields allows one of the two approaches to be selected.\n If no resolver fields are set then both approaches must result in the same date. Resolving separate fields to form a complete date and time is a complex\n process with behaviour distributed across a number of classes.\n It follows these steps: ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Object"], "Methods": [], "class_name": "DateTimeFormatter", "Vars": null}