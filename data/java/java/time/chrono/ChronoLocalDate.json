{"package_name": "java.time.chrono", "subclass_list": ["HijrahDate", "JapaneseDate", "LocalDate", "MinguoDate", "ThaiBuddhistDate", "HijrahDate", "JapaneseDate", "LocalDate", "MinguoDate", "ThaiBuddhistDate"], "class_description": "A date without time-of-day or time-zone in an arbitrary chronology, intended\n for advanced globalization use cases. Most applications should declare method signatures, fields and variables\n as LocalDate, not this interface. A ChronoLocalDate is the abstract representation of a date where the\n Chronology chronology, or calendar system, is pluggable.\n The date is defined in terms of fields expressed by TemporalField,\n where most common implementations are defined in ChronoField.\n The chronology defines how the calendar system operates and the meaning of\n the standard fields. This concept can seem surprising at first, as the natural way to globalize an\n application might initially appear to be to abstract the calendar system.\n However, as explored below, abstracting the calendar system is usually the wrong\n approach, resulting in logic errors and hard to find bugs.\n As such, it should be considered an application-wide architectural decision to choose\n to use this interface as opposed to LocalDate. 1) Applications using this interface, as opposed to using just LocalDate,\n face a significantly higher probability of bugs. This is because the calendar system\n in use is not known at development time. A key cause of bugs is where the developer\n applies assumptions from their day-to-day knowledge of the ISO calendar system\n to code that is intended to deal with any arbitrary calendar system.\n The section below outlines how those assumptions can cause problems\n The primary mechanism for reducing this increased risk of bugs is a strong code review process.\n This should also be considered a extra cost in maintenance for the lifetime of the code. 2) This interface does not enforce immutability of implementations.\n While the implementation notes indicate that all implementations must be immutable\n there is nothing in the code or type system to enforce this. Any method declared\n to accept a ChronoLocalDate could therefore be passed a poorly or\n maliciously written mutable implementation. 3) Applications using this interface  must consider the impact of eras.\n LocalDate shields users from the concept of eras, by ensuring that getYear()\n returns the proleptic year. That decision ensures that developers can think of\n LocalDate instances as consisting of three fields - year, month-of-year and day-of-month.\n By contrast, users of this interface must think of dates as consisting of four fields -\n era, year-of-era, month-of-year and day-of-month. The extra era field is frequently\n forgotten, yet it is of vital importance to dates in an arbitrary calendar system.\n For example, in the Japanese calendar system, the era represents the reign of an Emperor.\n Whenever one reign ends and another starts, the year-of-era is reset to one. 4) The only agreed international standard for passing a date between two systems\n is the ISO-8601 standard which requires the ISO calendar system. Using this interface\n throughout the application will inevitably lead to the requirement to pass the date\n across a network or component boundary, requiring an application specific protocol or format. 5) Long term persistence, such as a database, will almost always only accept dates in the\n ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\n calendar systems increases the complications of interacting with persistence. 6) Most of the time, passing a ChronoLocalDate throughout an application\n is unnecessary, as discussed in the last section below. Code that queries the day-of-month and assumes that the value will never be more than\n 31 is invalid. Some calendar systems have more than 31 days in some months. Code that adds 12 months to a date and assumes that a year has been added is invalid.\n Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic. Code that adds one month to a date and assumes that the month-of-year value will increase\n by one or wrap to the next year is invalid. Some calendar systems have a variable number\n of months in a year, such as the Hebrew. Code that adds one month, then adds a second one month and assumes that the day-of-month\n will remain close to its original value is invalid. Some calendar systems have a large difference\n between the length of the longest month and the length of the shortest month.\n For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days. Code that adds seven days and assumes that a week has been added is invalid.\n Some calendar systems have weeks of other than seven days, such as the French Revolutionary. Code that assumes that because the year of date1 is greater than the year of date2\n then date1 is after date2 is invalid. This is invalid for all calendar systems\n when referring to the year-of-era, and especially untrue of the Japanese calendar system\n where the year-of-era restarts with the reign of every new Emperor. Code that treats month-of-year one and day-of-month one as the start of the year is invalid.\n Not all calendar systems start the year when the month value is one. In general, manipulating a date, and even querying a date, is wide open to bugs when the\n calendar system is unknown at development time. This is why it is essential that code using\n this interface is subjected to additional code reviews. It is also why an architectural\n decision to avoid this interface type is usually the correct one. As discussed above, performing calculations on a date where the rules of the calendar system\n are pluggable requires skill and is not recommended.\n Fortunately, the need to perform calculations on a date in an arbitrary calendar system\n is extremely rare. For example, it is highly unlikely that the business rules of a library\n book rental scheme will allow rentals to be for one month, where meaning of the month\n is dependent on the user's preferred calendar system. A key use case for calculations on a date in an arbitrary calendar system is producing\n a month-by-month calendar for display and user interaction. Again, this is a UI issue,\n and use of this interface solely within a few methods of the UI layer may be justified. In any other part of the system, where a date must be manipulated in a calendar system\n other than ISO, the use case will generally specify the calendar system to use.\n For example, an application may need to calculate the next Islamic or Hebrew holiday\n which may require manipulating the date.\n This kind of use case can be handled as follows: ", "class_type": "interface", "typealias": [], "interface_list": ["Temporal", "TemporalAdjuster", "Comparable<ChronoLocalDate>"], "class_inherit_list": [], "Methods": [], "class_name": "ChronoLocalDate", "Vars": null}