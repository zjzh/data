{"package_name": "java.io", "subclass_list": [], "class_description": "An ObjectInputStream deserializes primitive data and objects previously\n written using an ObjectOutputStream. ObjectOutputStream and ObjectInputStream can provide an application with\n persistent storage for graphs of objects when used with a FileOutputStream\n and FileInputStream respectively.  ObjectInputStream is used to recover\n those objects previously serialized. Other uses include passing objects\n between hosts using a socket stream or for marshaling and unmarshaling\n arguments and parameters in a remote communication system. ObjectInputStream ensures that the types of all objects in the graph\n created from the stream match the classes present in the Java Virtual\n Machine.  Classes are loaded as required using the standard mechanisms. Only objects that support the java.io.Serializable or\n java.io.Externalizable interface can be read from streams. The method readObject is used to read an object from the\n stream.  Java's safe casting should be used to get the desired type.  In\n Java, strings and arrays are objects and are treated as objects during\n serialization. When read they need to be cast to the expected type. Primitive data types can be read from the stream using the appropriate\n method on DataInput. The default deserialization mechanism for objects restores the contents\n of each field to the value and type it had when it was written.  Fields\n declared as transient or static are ignored by the deserialization process.\n References to other objects cause those objects to be read from the stream\n as necessary.  Graphs of objects are restored correctly using a reference\n sharing mechanism.  New objects are always allocated when deserializing,\n which prevents existing objects from being overwritten. Reading an object is analogous to running the constructors of a new\n object.  Memory is allocated for the object and initialized to zero (NULL).\n No-arg constructors are invoked for the non-serializable classes and then\n the fields of the serializable classes are restored from the stream starting\n with the serializable class closest to java.lang.object and finishing with\n the object's most specific class. For example to read from a stream as written by the example in\n ObjectOutputStream: Classes control how they are serialized by implementing either the\n java.io.Serializable or java.io.Externalizable interfaces. Implementing the Serializable interface allows object serialization to\n save and restore the entire state of the object and it allows classes to\n evolve between the time the stream is written and the time it is read.  It\n automatically traverses references between objects, saving and restoring\n entire graphs. Serializable classes that require special handling during the\n serialization and deserialization process should implement the following\n methods: The readObject method is responsible for reading and restoring the state\n of the object for its particular class using data written to the stream by\n the corresponding writeObject method.  The method does not need to concern\n itself with the state belonging to its superclasses or subclasses.  State is\n restored by reading data from the ObjectInputStream for the individual\n fields and making assignments to the appropriate fields of the object.\n Reading primitive data types is supported by DataInput. Any attempt to read object data which exceeds the boundaries of the\n custom data written by the corresponding writeObject method will cause an\n OptionalDataException to be thrown with an eof field value of true.\n Non-object reads which exceed the end of the allotted data will reflect the\n end of data in the same way that they would indicate the end of the stream:\n bytewise reads will return -1 as the byte read or number of bytes read, and\n primitive reads will throw EOFExceptions.  If there is no corresponding\n writeObject method, then the end of default serialized data marks the end of\n the allotted data. Primitive and object read calls issued from within a readExternal method\n behave in the same manner--if the stream is already positioned at the end of\n data written by the corresponding writeExternal method, object reads will\n throw OptionalDataExceptions with eof set to true, bytewise reads will\n return -1, and primitive reads will throw EOFExceptions.  Note that this\n behavior does not hold for streams written with the old\n ObjectStreamConstants.PROTOCOL_VERSION_1 protocol, in which the\n end of data written by writeExternal methods is not demarcated, and hence\n cannot be detected. The readObjectNoData method is responsible for initializing the state of\n the object for its particular class in the event that the serialization\n stream does not list the given class as a superclass of the object being\n deserialized.  This may occur in cases where the receiving party uses a\n different version of the deserialized instance's class than the sending\n party, and the receiver's version extends classes that are not extended by\n the sender's version.  This may also occur if the serialization stream has\n been tampered; hence, readObjectNoData is useful for initializing\n deserialized objects properly despite a \"hostile\" or incomplete source\n stream. Serialization does not read or assign values to the fields of any object\n that does not implement the java.io.Serializable interface.  Subclasses of\n Objects that are not serializable can be serializable. In this case the\n non-serializable class must have a no-arg constructor to allow its fields to\n be initialized.  In this case it is the responsibility of the subclass to\n save and restore the state of the non-serializable class. It is frequently\n the case that the fields of that class are accessible (public, package, or\n protected) or that there are get and set methods that can be used to restore\n the state. Any exception that occurs while deserializing an object will be caught by\n the ObjectInputStream and abort the reading process. Implementing the Externalizable interface allows the object to assume\n complete control over the contents and format of the object's serialized\n form.  The methods of the Externalizable interface, writeExternal and\n readExternal, are called to save and restore the objects state.  When\n implemented by a class they can write and read their own state using all of\n the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n the objects to handle any versioning that occurs. Enum constants are deserialized differently than ordinary serializable or\n externalizable objects.  The serialized form of an enum constant consists\n solely of its name; field values of the constant are not transmitted.  To\n deserialize an enum constant, ObjectInputStream reads the constant name from\n the stream; the deserialized constant is then obtained by calling the static\n method Enum.valueOf(Class, String) with the enum constant's\n base type and the received constant name as arguments.  Like other\n serializable or externalizable objects, enum constants can function as the\n targets of back references appearing subsequently in the serialization\n stream.  The process by which enum constants are deserialized cannot be\n customized: any class-specific readObject, readObjectNoData, and readResolve\n methods defined by enum types are ignored during deserialization.\n Similarly, any serialPersistentFields or serialVersionUID field declarations\n are also ignored--all enum types have a fixed serialVersionUID of 0L. ", "class_type": "class", "typealias": [], "interface_list": ["ObjectInput", "ObjectStreamConstants"], "class_inherit_list": ["InputStream"], "Methods": [], "class_name": "ObjectInputStream", "Vars": null}