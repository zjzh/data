{"package_name": "java.io", "subclass_list": [], "class_description": "An ObjectOutputStream writes primitive data types and graphs of Java objects\n to an OutputStream.  The objects can be read (reconstituted) using an\n ObjectInputStream.  Persistent storage of objects can be accomplished by\n using a file for the stream.  If the stream is a network socket stream, the\n objects can be reconstituted on another host or in another process. Only objects that support the java.io.Serializable interface can be\n written to streams.  The class of each serializable object is encoded\n including the class name and signature of the class, the values of the\n object's fields and arrays, and the closure of any other objects referenced\n from the initial objects. The method writeObject is used to write an object to the stream.  Any\n object, including Strings and arrays, is written with writeObject. Multiple\n objects or primitives can be written to the stream.  The objects must be\n read back from the corresponding ObjectInputstream with the same types and\n in the same order as they were written. Primitive data types can also be written to the stream using the\n appropriate methods from DataOutput. Strings can also be written using the\n writeUTF method. The default serialization mechanism for an object writes the class of the\n object, the class signature, and the values of all non-transient and\n non-static fields.  References to other objects (except in transient or\n static fields) cause those objects to be written also. Multiple references\n to a single object are encoded using a reference sharing mechanism so that\n graphs of objects can be restored to the same shape as when the original was\n written. For example to write an object that can be read by the example in\n ObjectInputStream: Classes that require special handling during the serialization and\n deserialization process must implement special methods with these exact\n signatures: The writeObject method is responsible for writing the state of the object\n for its particular class so that the corresponding readObject method can\n restore it.  The method does not need to concern itself with the state\n belonging to the object's superclasses or subclasses.  State is saved by\n writing the individual fields to the ObjectOutputStream using the\n writeObject method or by using the methods for primitive data types\n supported by DataOutput. Serialization does not write out the fields of any object that does not\n implement the java.io.Serializable interface.  Subclasses of Objects that\n are not serializable can be serializable. In this case the non-serializable\n class must have a no-arg constructor to allow its fields to be initialized.\n In this case it is the responsibility of the subclass to save and restore\n the state of the non-serializable class. It is frequently the case that the\n fields of that class are accessible (public, package, or protected) or that\n there are get and set methods that can be used to restore the state. Serialization of an object can be prevented by implementing writeObject\n and readObject methods that throw the NotSerializableException.  The\n exception will be caught by the ObjectOutputStream and abort the\n serialization process. Implementing the Externalizable interface allows the object to assume\n complete control over the contents and format of the object's serialized\n form.  The methods of the Externalizable interface, writeExternal and\n readExternal, are called to save and restore the objects state.  When\n implemented by a class they can write and read their own state using all of\n the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n the objects to handle any versioning that occurs. Enum constants are serialized differently than ordinary serializable or\n externalizable objects.  The serialized form of an enum constant consists\n solely of its name; field values of the constant are not transmitted.  To\n serialize an enum constant, ObjectOutputStream writes the string returned by\n the constant's name method.  Like other serializable or externalizable\n objects, enum constants can function as the targets of back references\n appearing subsequently in the serialization stream.  The process by which\n enum constants are serialized cannot be customized; any class-specific\n writeObject and writeReplace methods defined by enum types are ignored\n during serialization.  Similarly, any serialPersistentFields or\n serialVersionUID field declarations are also ignored--all enum types have a\n fixed serialVersionUID of 0L. Primitive data, excluding serializable fields and externalizable data, is\n written to the ObjectOutputStream in block-data records. A block data record\n is composed of a header and data. The block data header consists of a marker\n and the number of bytes to follow the header.  Consecutive primitive data\n writes are merged into one block-data record.  The blocking factor used for\n a block-data record will be 1024 bytes.  Each block-data record will be\n filled up to 1024 bytes, or be written whenever there is a termination of\n block-data mode.  Calls to the ObjectOutputStream methods writeObject,\n defaultWriteObject and writeFields initially terminate any existing\n block-data record. ", "class_type": "class", "typealias": [], "interface_list": ["ObjectOutput", "ObjectStreamConstants"], "class_inherit_list": ["OutputStream"], "Methods": [], "class_name": "ObjectOutputStream", "Vars": null}