{"package_name": "java.nio.channels", "subclass_list": [], "class_description": "A channel for reading, writing, mapping, and manipulating a file. A file channel is a SeekableByteChannel that is connected to\n a file. It has a current position within its file which can\n be both queried and modified.  The file itself contains a variable-length sequence\n of bytes that can be read and written and whose current size can be queried.  The size of the file increases\n when bytes are written beyond its current size; the size of the file\n decreases when it is truncated.  The\n file may also have some associated metadata such as access\n permissions, content type, and last-modification time; this class does not\n define methods for metadata access. In addition to the familiar read, write, and close operations of byte\n channels, this class defines the following file-specific operations: File channels are safe for use by multiple concurrent threads.  The\n Channel#close method may be invoked at any time, as specified\n by the Channel interface.  Only one operation that involves the\n channel's position or can change its file's size may be in progress at any\n given time; attempts to initiate a second such operation while the first is\n still in progress will block until the first operation completes.  Other\n operations, in particular those that take an explicit position, may proceed\n concurrently; whether they in fact do so is dependent upon the underlying\n implementation and is therefore unspecified. The view of a file provided by an instance of this class is guaranteed\n to be consistent with other views of the same file provided by other\n instances in the same program.  The view provided by an instance of this\n class may or may not, however, be consistent with the views seen by other\n concurrently-running programs due to caching performed by the underlying\n operating system and delays induced by network-filesystem protocols.  This\n is true regardless of the language in which these other programs are\n written, and whether they are running on the same machine or on some other\n machine.  The exact nature of any such inconsistencies are system-dependent\n and are therefore unspecified. A file channel is created by invoking one of the open\n methods defined by this class. A file channel can also be obtained from an\n existing FileInputStream, FileOutputStream, or RandomAccessFile object by invoking\n that object's getChannel method, which returns a file channel that\n is connected to the same underlying file. Where the file channel is obtained\n from an existing stream or random access file then the state of the file\n channel is intimately connected to that of the object whose getChannel\n method returned the channel.  Changing the channel's position, whether\n explicitly or by reading or writing bytes, will change the file position of\n the originating object, and vice versa. Changing the file's length via the\n file channel will change the length seen via the originating object, and vice\n versa.  Changing the file's content by writing bytes will change the content\n seen by the originating object, and vice versa. At various points this class specifies that an\n instance that is \"open for reading,\" \"open for writing,\" or \"open for\n reading and writing\" is required.  A channel obtained via the getChannel method of a FileInputStream instance will be open for reading.  A channel\n obtained via the getChannel\n method of a FileOutputStream instance will be open for\n writing.  Finally, a channel obtained via the getChannel method of a RandomAccessFile instance will be open for reading if the instance\n was created with mode \"r\" and will be open for reading and writing\n if the instance was created with mode \"rw\". A file channel that is open for writing may be in\n append mode, for example if it was obtained from a file-output stream\n that was created by invoking the FileOutputStream(File,boolean) constructor and passing true for\n the second parameter.  In this mode each invocation of a relative write\n operation first advances the position to the end of the file and then writes\n the requested data.  Whether the advancement of the position and the writing\n of the data are done in a single atomic operation is system-dependent and\n therefore unspecified. ", "class_type": "class", "typealias": [], "interface_list": ["SeekableByteChannel", "GatheringByteChannel", "ScatteringByteChannel"], "class_inherit_list": ["AbstractInterruptibleChannel"], "Methods": [], "class_name": "FileChannel", "Vars": null}