{"package_name": "java.util", "subclass_list": ["AbstractMap", "ArrayMap", "Attributes", "AuthProvider", "ConcurrentHashMap", "ConcurrentMap", "ConcurrentNavigableMap", "ConcurrentSkipListMap", "EnumMap", "Enum", "HashMap", "Hashtable", "IdentityHashMap", "LinkedHashMap", "NavigableMap", "Properties", "Provider", "SortedMap", "TreeMap", "WeakHashMap", "AbstractMap", "ArrayMap", "HashMap", "Attributes", "AuthProvider", "ConcurrentHashMap", "ConcurrentMap", "Map", "ConcurrentNavigableMap", "ConcurrentMap", "NavigableMap", "ConcurrentSkipListMap", "ConcurrentNavigableMap", "EnumMap", "Enum", "Map", "HashMap", "Hashtable", "IdentityHashMap", "LinkedHashMap", "NavigableMap", "SortedMap", "Properties", "Provider", "SortedMap", "Map", "TreeMap", "NavigableMap", "WeakHashMap"], "class_description": "An object that maps keys to values.  A map cannot contain duplicate keys;\n each key can map to at most one value. This interface takes the place of the Dictionary class, which\n was a totally abstract class rather than an interface. The Map interface provides three collection views, which\n allow a map's contents to be viewed as a set of keys, collection of values,\n or set of key-value mappings.  The order of a map is defined as\n the order in which the iterators on the map's collection views return their\n elements.  Some map implementations, like the TreeMap class, make\n specific guarantees as to their order; others, like the HashMap\n class, do not. Note: great care must be exercised if mutable objects are used as map\n keys.  The behavior of a map is not specified if the value of an object is\n changed in a manner that affects equals comparisons while the\n object is a key in the map.  A special case of this prohibition is that it\n is not permissible for a map to contain itself as a key.  While it is\n permissible for a map to contain itself as a value, extreme caution is\n advised: the equals and hashCode methods are no longer\n well defined on such a map. All general-purpose map implementation classes should provide two\n \"standard\" constructors: a void (no arguments) constructor which creates an\n empty map, and a constructor with a single argument of type Map,\n which creates a new map with the same key-value mappings as its argument.\n In effect, the latter constructor allows the user to copy any map,\n producing an equivalent map of the desired class.  There is no way to\n enforce this recommendation (as interfaces cannot contain constructors) but\n all of the general-purpose map implementations in the JDK comply. The \"destructive\" methods contained in this interface, that is, the\n methods that modify the map on which they operate, are specified to throw\n UnsupportedOperationException if this map does not support the\n operation.  If this is the case, these methods may, but are not required\n to, throw an UnsupportedOperationException if the invocation would\n have no effect on the map.  For example, invoking the putAll(java.util.Map)\n method on an unmodifiable map may, but is not required to, throw the\n exception if the map whose mappings are to be \"superimposed\" is empty. Some map implementations have restrictions on the keys and values they\n may contain.  For example, some implementations prohibit null keys and\n values, and some have restrictions on the types of their keys.  Attempting\n to insert an ineligible key or value throws an unchecked exception,\n typically NullPointerException or ClassCastException.\n Attempting to query the presence of an ineligible key or value may throw an\n exception, or it may simply return false; some implementations will exhibit\n the former behavior and some will exhibit the latter.  More generally,\n attempting an operation on an ineligible key or value whose completion\n would not result in the insertion of an ineligible element into the map may\n throw an exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Many methods in Collections Framework interfaces are defined\n in terms of the Object#equals(Object) method.  For\n example, the specification for the containsKey(Object key) method says: \"returns true if and\n only if this map contains a mapping for a key k such that\n (key==null ? k==null : key.equals(k)).\" This specification should\n not be construed to imply that invoking Map.containsKey\n with a non-null argument key will cause key.equals(k) to\n be invoked for any key k.  Implementations are free to\n implement optimizations whereby the equals invocation is avoided,\n for example, by first comparing the hash codes of the two keys.  (The\n Object#hashCode() specification guarantees that two objects with\n unequal hash codes cannot be equal.)  More generally, implementations of\n the various Collections Framework interfaces are free to take advantage of\n the specified behavior of underlying Object methods wherever the\n implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail\n with an exception for self-referential instances where the map directly or\n indirectly contains itself. This includes the clone(),\n equals(), hashCode() and toString() methods.\n Implementations may optionally handle the self-referential scenario, however\n most current implementations do not do so. ", "class_type": "interface", "typealias": [], "interface_list": [""], "class_inherit_list": [], "Methods": [], "class_name": "Map", "Vars": null}