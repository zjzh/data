{"package_name": "java.util.prefs", "subclass_list": [], "class_description": "This class provides a skeletal implementation of the Preferences\n class, greatly easing the task of implementing it. This class is for Preferences implementers only.\n Normal users of the Preferences facility should have no need to\n consult this documentation.  The Preferences documentation\n should suffice. Implementors must override the nine abstract service-provider interface\n (SPI) methods: getSpi(java.lang.String), putSpi(java.lang.String, java.lang.String),\n removeSpi(java.lang.String), childSpi(java.lang.String), removeNodeSpi(), keysSpi(), childrenNamesSpi(), syncSpi() and flushSpi().  All of the concrete methods specify\n precisely how they are implemented atop these SPI methods.  The implementor\n may, at his discretion, override one or more of the concrete methods if the\n default implementation is unsatisfactory for any reason, such as\n performance. The SPI methods fall into three groups concerning exception\n behavior. The getSpi method should never throw exceptions, but it\n doesn't really matter, as any exception thrown by this method will be\n intercepted by get(java.lang.String, java.lang.String), which will return the specified\n default value to the caller.  The removeNodeSpi, keysSpi,\n childrenNamesSpi, syncSpi and flushSpi methods are specified\n to throw BackingStoreException, and the implementation is required\n to throw this checked exception if it is unable to perform the operation.\n The exception propagates outward, causing the corresponding API method\n to fail. The remaining SPI methods putSpi(java.lang.String, java.lang.String), removeSpi(java.lang.String) and childSpi(java.lang.String) have more complicated\n exception behavior.  They are not specified to throw\n BackingStoreException, as they can generally obey their contracts\n even if the backing store is unavailable.  This is true because they return\n no information and their effects are not required to become permanent until\n a subsequent call to Preferences#flush() or\n Preferences#sync(). Generally speaking, these SPI methods should not\n throw exceptions.  In some implementations, there may be circumstances\n under which these calls cannot even enqueue the requested operation for\n later processing.  Even under these circumstances it is generally better to\n simply ignore the invocation and return, rather than throwing an\n exception.  Under these circumstances, however, all subsequent invocations\n of flush() and sync should return false, as\n returning true would imply that all previous operations had\n successfully been made permanent. There is one circumstance under which putSpi, removeSpi and\n childSpi should throw an exception: if the caller lacks\n sufficient privileges on the underlying operating system to perform the\n requested operation.  This will, for instance, occur on most systems\n if a non-privileged user attempts to modify system preferences.\n (The required privileges will vary from implementation to\n implementation.  On some implementations, they are the right to modify the\n contents of some directory in the file system; on others they are the right\n to modify contents of some key in a registry.)  Under any of these\n circumstances, it would generally be undesirable to let the program\n continue executing as if these operations would become permanent at a later\n time.  While implementations are not required to throw an exception under\n these circumstances, they are encouraged to do so.  A SecurityException would be appropriate. Most of the SPI methods require the implementation to read or write\n information at a preferences node.  The implementor should beware of the\n fact that another VM may have concurrently deleted this node from the\n backing store.  It is the implementation's responsibility to recreate the\n node if it has been deleted. Implementation note: In Sun's default Preferences\n implementations, the user's identity is inherited from the underlying\n operating system and does not change for the lifetime of the virtual\n machine.  It is recognized that server-side Preferences\n implementations may have the user identity change from request to request,\n implicitly passed to Preferences methods via the use of a\n static ThreadLocal instance.  Authors of such implementations are\n strongly encouraged to determine the user at the time preferences\n are accessed (for example by the get(java.lang.String, java.lang.String) or put(java.lang.String, java.lang.String) method) rather than permanently associating a user\n with each Preferences instance.  The latter behavior conflicts\n with normal Preferences usage and would lead to great confusion. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Preferences"], "Methods": [], "class_name": "AbstractPreferences", "Vars": null}