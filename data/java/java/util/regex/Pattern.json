{"package_name": "java.util.regex", "subclass_list": [], "class_description": "A compiled representation of a regular expression. A regular expression, specified as a string, must first be compiled into\n an instance of this class.  The resulting pattern can then be used to create\n a Matcher object that can match arbitrary character sequences against the regular\n expression.  All of the state involved in performing a match resides in the\n matcher, so many matchers can share the same pattern. A typical invocation sequence is thus A matches method is defined by this class as a\n convenience for when a regular expression is used just once.  This method\n compiles an expression and matches an input sequence against it in a single\n invocation.  The statement Instances of this class are immutable and are safe for use by multiple\n concurrent threads.  Instances of the Matcher class are not safe for\n such use. The backslash character ('\\') serves to introduce escaped\n constructs, as defined in the table above, as well as to quote characters\n that otherwise would be interpreted as unescaped constructs.  Thus the\n expression \\\\ matches a single backslash and \\{ matches a\n left brace. It is an error to use a backslash prior to any alphabetic character that\n does not denote an escaped construct; these are reserved for future\n extensions to the regular-expression language.  A backslash may be used\n prior to a non-alphabetic character regardless of whether that character is\n part of an unescaped construct. Backslashes within string literals in Java source code are interpreted\n as required by\n The Java\u2122 Language Specification\n as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)\n It is therefore necessary to double backslashes in string\n literals that represent regular expressions to protect them from\n interpretation by the Java bytecode compiler.  The string literal\n \"\\b\", for example, matches a single backspace character when\n interpreted as a regular expression, while \"\\\\b\" matches a\n word boundary.  The string literal \"\\(hello\\)\" is illegal\n and leads to a compile-time error; in order to match the string\n (hello) the string literal \"\\\\(hello\\\\)\"\n must be used. Character classes may appear within other character classes, and\n    may be composed by the union operator (implicit) and the intersection\n    operator (&&).\n    The union operator denotes a class that contains every character that is\n    in at least one of its operand classes.  The intersection operator\n    denotes a class that contains every character that is in both of its\n    operand classes. The precedence of character-class operators is as follows, from\n    highest to lowest: Note that a different set of metacharacters are in effect inside\n    a character class than outside a character class. For instance, the\n    regular expression . loses its special meaning inside a\n    character class, while the expression - becomes a range\n    forming metacharacter. A line terminator is a one- or two-character sequence that marks\n the end of a line of the input character sequence.  The following are\n recognized as line terminators: If UNIX_LINES mode is activated, then the only line terminators\n recognized are newline characters. The regular expression . matches any character except a line\n terminator unless the DOTALL flag is specified. By default, the regular expressions ^ and $ ignore\n line terminators and only match at the beginning and the end, respectively,\n of the entire input sequence. If MULTILINE mode is activated then\n ^ matches at the beginning of input and after any line terminator\n except at the end of input. When in MULTILINE mode $\n matches just before a line terminator or the end of the input sequence. Capturing groups are numbered by counting their opening parentheses from\n left to right.  In the expression ((A)(B(C))), for example, there\n are four such groups: Group zero always stands for the entire expression. Capturing groups are so named because, during a match, each subsequence\n of the input sequence that matches such a group is saved.  The captured\n subsequence may be used later in the expression, via a back reference, and\n may also be retrieved from the matcher once the match operation is complete. The constructs and APIs are available since API level 26. A capturing group\n can also be assigned a \"name\", a named-capturing group,\n and then be back-referenced later by the \"name\". Group names are composed of\n the following characters. The first character must be a letter. A named-capturing group is still numbered as described in\n Group number. The captured input associated with a group is always the subsequence\n that the group most recently matched.  If a group is evaluated a second time\n because of quantification then its previously-captured value, if any, will\n be retained if the second evaluation fails.  Matching the string\n \"aba\" against the expression (a(b)?)+, for example, leaves\n group two set to \"b\".  All captured input is discarded at the\n beginning of each match. Groups beginning with (? are either pure, non-capturing groups\n that do not capture text and do not count towards the group total, or\n named-capturing group. This class is in conformance with Level 1 of Unicode Technical\n Standard #18: Unicode Regular Expression, plus RL2.1\n Canonical Equivalents. Unicode escape sequences such as \\u2014 in Java source code\n are processed as described in section 3.3 of\n The Java\u2122 Language Specification.\n Such escape sequences are also implemented directly by the regular-expression\n parser so that Unicode escapes can be used in expressions that are read from\n files or from the keyboard.  Thus the strings \"\\u2014\" and\n \"\\\\u2014\", while not equal, compile into the same pattern, which\n matches the character with hexadecimal value 0x2014. A Unicode character can also be represented in a regular-expression by\n using its Hex notation(hexadecimal code point value) directly as described in construct\n \\x{...}, for example a supplementary character U+2011F\n can be specified as \\x{2011F}, instead of two consecutive\n Unicode escape sequences of the surrogate pair\n \\uD840\\uDD1F. Unicode scripts, blocks, categories and binary properties are written with\n the \\p and \\P constructs as in Perl.\n \\p{prop} matches if\n the input has the property prop, while \\P{prop}\n does not match if the input has that property. Scripts, blocks, categories and binary properties can be used both inside\n and outside of a character class. Scripts are specified either with the prefix Is, as in\n IsHiragana, or by using  the script keyword (or its short\n form sc)as in script=Hiragana or sc=Hiragana. The script names supported by Pattern are the valid script names\n accepted and defined by\n UnicodeScript.forName. Blocks are specified with the prefix In, as in\n InMongolian, or by using the keyword block (or its short\n form blk) as in block=Mongolian or blk=Mongolian. The block names supported by Pattern are the valid block names\n accepted and defined by\n UnicodeBlock.forName. Categories may be specified with the optional prefix Is:\n Both \\p{L} and \\p{IsL} denote the category of Unicode\n letters. Same as scripts and blocks, categories can also be specified\n by using the keyword general_category (or its short form\n gc) as in general_category=Lu or gc=Lu. The supported categories are those of\n \nThe Unicode Standard in the version specified by the\n Character class. The category names are those\n defined in the Standard, both normative and informative. Binary properties are specified with the prefix Is, as in\n IsAlphabetic. The supported binary properties by Pattern\n are The following Predefined Character classes and POSIX character classes\n are in conformance with the recommendation of Annex C: Compatibility Properties\n of Unicode Regular Expression\n . Categories that behave like the java.lang.Character\n boolean ismethodname methods (except for the deprecated ones) are\n available through the same \\p{prop} syntax where\n the specified property has the name javamethodname. The Pattern engine performs traditional NFA-based matching\n with ordered alternation as occurs in Perl 5. Perl constructs not supported by this class: Constructs supported by this class but not by Perl: Notable differences from Perl: For a more precise description of the behavior of regular expression\n constructs, please see \nMastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl,\n O'Reilly and Associates, 2006. ", "class_type": "class", "typealias": [], "interface_list": ["Serializable"], "class_inherit_list": ["Object"], "Methods": [], "class_name": "Pattern", "Vars": null}