{"package_name": "java.util.jar", "subclass_list": [], "class_description": "The packer engine applies various transformations to the input JAR file,\n making the pack stream highly compressible by a compressor such as\n gzip or zip. An instance of the engine can be obtained\n using Pack200.newPacker().\n \n The high degree of compression is achieved\n by using a number of techniques described in the JSR 200 specification.\n Some of the techniques are sorting, re-ordering and co-location of the\n constant pool. The pack engine is initialized to an initial state as described\n by their properties below.\n The initial state can be manipulated by getting the\n engine properties (using properties()) and storing\n the modified properties on the map.\n The resource files will be passed through with no changes at all.\n The class files will not contain identical bytes, since the unpacker\n is free to change minor class file features such as constant pool order.\n However, the class files will be semantically identical,\n as specified in\n The Java\u2122 Virtual Machine Specification. By default, the packer does not change the order of JAR elements.\n Also, the modification time and deflation hint of each\n JAR element is passed unchanged.\n (Any other ZIP-archive information, such as extra attributes\n giving Unix file permissions, are lost.) Note that packing and unpacking a JAR will in general alter the\n bytewise contents of classfiles in the JAR.  This means that packing\n and unpacking will in general invalidate any digital signatures\n which rely on bytewise images of JAR elements.  In order both to sign\n and to pack a JAR, you must first pack and unpack the JAR to\n \"normalize\" it, then compute signatures on the unpacked JAR elements,\n and finally repack the signed JAR.\n Both packing steps should\n use precisely the same options, and the segment limit may also\n need to be set to \"-1\", to prevent accidental variation of segment\n boundaries as class file sizes change slightly. (Here's why this works:  Any reordering the packer does\n of any classfile structures is idempotent, so the second packing\n does not change the orderings produced by the first packing.\n Also, the unpacker is guaranteed by the JSR 200 specification\n to produce a specific bytewise image for any given transmission\n ordering of archive elements.) In order to maintain backward compatibility, the pack file's version is\n set to accommodate the class files present in the input JAR file. In\n other words, the pack file version will be the latest, if the class files\n are the latest and conversely the pack file version will be the oldest\n if the class file versions are also the oldest. For intermediate class\n file versions the corresponding pack file version will be used.\n For example:\n    If the input JAR-files are solely comprised of 1.5  (or  lesser)\n class files, a 1.5 compatible pack file is  produced. This will also be\n the case for archives that have no class files.\n    If the input JAR-files contains a 1.6 class file, then the pack file\n version will be set to 1.6. Note: Unless otherwise noted, passing a null argument to a\n constructor or method in this class will cause a NullPointerException\n to be thrown.  ", "class_type": "interface", "typealias": [], "interface_list": [""], "class_inherit_list": [], "Methods": [], "class_name": "Pack200.Packer", "Vars": null}