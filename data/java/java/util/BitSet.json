{"package_name": "java.util", "subclass_list": [], "class_description": "This class implements a vector of bits that grows as needed. Each\n component of the bit set has a boolean value. The\n bits of a BitSet are indexed by nonnegative integers.\n Individual indexed bits can be examined, set, or cleared. One\n BitSet may be used to modify the contents of another\n BitSet through logical AND, logical inclusive OR, and\n logical exclusive OR operations. By default, all bits in the set initially have the value\n false. Every bit set has a current size, which is the number of bits\n of space currently in use by the bit set. Note that the size is\n related to the implementation of a bit set, so it may change with\n implementation. The length of a bit set relates to logical length\n of a bit set and is defined independently of implementation. Unless otherwise noted, passing a null parameter to any of the\n methods in a BitSet will result in a\n NullPointerException. A BitSet is not safe for multithreaded use without\n external synchronization. ", "class_type": "class", "typealias": [], "interface_list": ["Cloneable", "Serializable"], "class_inherit_list": ["Object"], "Methods": [{"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Creates a new bit set. All bits are initially false.\n", "method_declar": ""}, {"params": [{"param_name": ["nbits"], "param_type": "int", "param_description": " the initial size of the bit set"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Creates a bit set whose initial size is large enough to explicitly\n represent bits with indices in the range 0 through\n nbits-1. All bits are initially false.\n", "method_declar": ""}, {"params": [{"param_name": ["set"], "param_type": "BitSet", "param_description": " a bit set"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "and", "method_description": "Performs a logical AND of this target bit set with the\n argument bit set. This bit set is modified so that each bit in it\n has the value true if and only if it both initially\n had the value true and the corresponding bit in the\n bit set argument also had the value true.\n", "method_declar": ""}, {"params": [{"param_name": ["set"], "param_type": "BitSet", "param_description": " the BitSet with which to mask this\n         BitSet"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "andNot", "method_description": "Clears all of the bits in this BitSet whose corresponding\n bit is set in the specified BitSet.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the number of bits set to true in this BitSet"], "return_type": ["int"]}, "method_name": "cardinality", "method_description": "Returns the number of bits set to true in this BitSet.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " index of the first bit to be cleared"}, {"param_name": ["toIndex"], "param_type": "int", "param_description": " index after the last bit to be cleared"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "clear", "method_description": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to false.\n", "method_declar": ""}, {"params": [{"param_name": ["bitIndex"], "param_type": "int", "param_description": " the index of the bit to be cleared"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "clear", "method_description": "Sets the bit specified by the index to false.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "clear", "method_description": "Sets all of the bits in this BitSet to false.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["a clone of this bit set"], "return_type": ["Object"]}, "method_name": "clone", "method_description": "Cloning this BitSet produces a new BitSet\n that is equal to it.\n The clone of the bit set is another bit set that has exactly the\n same bits set to true as this bit set.\nSee also:\n", "method_declar": ""}, {"params": [{"param_name": ["obj"], "param_type": "Object", "param_description": " the object to compare with"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the objects are the same;\n         false otherwise"], "return_type": ["boolean"]}, "method_name": "equals", "method_description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and is a Bitset object that has\n exactly the same set of bits set to true as this bit\n set. That is, for every nonnegative int index k,\n \nSee also:\n", "method_declar": ""}, {"params": [{"param_name": ["bitIndex"], "param_type": "int", "param_description": " the index of the bit to flip"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "flip", "method_description": "Sets the bit at the specified index to the complement of its\n current value.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " index of the first bit to flip"}, {"param_name": ["toIndex"], "param_type": "int", "param_description": " index after the last bit to flip"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "flip", "method_description": "Sets each bit from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to the complement of its current\n value.\n", "method_declar": ""}, {"params": [{"param_name": ["bitIndex"], "param_type": "int", "param_description": " the bit index"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the value of the bit with the specified index"], "return_type": ["boolean"]}, "method_name": "get", "method_description": "Returns the value of the bit with the specified index. The value\n is true if the bit with the index bitIndex\n is currently set in this BitSet; otherwise, the result\n is false.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " index of the first bit to include"}, {"param_name": ["toIndex"], "param_type": "int", "param_description": " index after the last bit to include"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["a new BitSet from a range of this BitSet"], "return_type": ["BitSet"]}, "method_name": "get", "method_description": "Returns a new BitSet composed of bits from this BitSet\n from fromIndex (inclusive) to toIndex (exclusive).\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the hash code value for this bit set"], "return_type": ["int"]}, "method_name": "hashCode", "method_description": "Returns the hash code value for this bit set. The hash code depends\n only on which bits are set within this BitSet.\n\n \nThe hash code is defined to be the result of the following\n calculation:\n  \n", "method_declar": ""}, {"params": [{"param_name": ["set"], "param_type": "BitSet", "param_description": " BitSet to intersect with"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["boolean indicating whether this BitSet intersects\n         the specified BitSet"], "return_type": ["boolean"]}, "method_name": "intersects", "method_description": "Returns true if the specified BitSet has any bits set to\n true that are also set to true in this BitSet.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["boolean indicating whether this BitSet is empty"], "return_type": ["boolean"]}, "method_name": "isEmpty", "method_description": "Returns true if this BitSet contains no bits that are set\n to true.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the logical size of this BitSet"], "return_type": ["int"]}, "method_name": "length", "method_description": "Returns the \"logical size\" of this BitSet: the index of\n the highest set bit in the BitSet plus one. Returns zero\n if the BitSet contains no set bits.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " the index to start checking from (inclusive)"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the index of the next clear bit"], "return_type": ["int"]}, "method_name": "nextClearBit", "method_description": "Returns the index of the first bit that is set to false\n that occurs on or after the specified starting index.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " the index to start checking from (inclusive)"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the index of the next set bit, or -1 if there\n         is no such bit"], "return_type": ["int"]}, "method_name": "nextSetBit", "method_description": "Returns the index of the first bit that is set to true\n that occurs on or after the specified starting index. If no such\n bit exists then -1 is returned.\n\n \nTo iterate over the true bits in a BitSet,\n use the following loop:\n\n  \n", "method_declar": ""}, {"params": [{"param_name": ["set"], "param_type": "BitSet", "param_description": " a bit set"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "or", "method_description": "Performs a logical OR of this bit set with the bit set\n argument. This bit set is modified so that a bit in it has the\n value true if and only if it either already had the\n value true or the corresponding bit in the bit set\n argument has the value true.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " the index to start checking from (inclusive)"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the index of the previous clear bit, or -1 if there\n         is no such bit"], "return_type": ["int"]}, "method_name": "previousClearBit", "method_description": "Returns the index of the nearest bit that is set to false\n that occurs on or before the specified starting index.\n If no such bit exists, or if -1 is given as the\n starting index, then -1 is returned.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " the index to start checking from (inclusive)"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the index of the previous set bit, or -1 if there\n         is no such bit"], "return_type": ["int"]}, "method_name": "previousSetBit", "method_description": "Returns the index of the nearest bit that is set to true\n that occurs on or before the specified starting index.\n If no such bit exists, or if -1 is given as the\n starting index, then -1 is returned.\n\n \nTo iterate over the true bits in a BitSet,\n use the following loop:\n\n  \n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " index of the first bit to be set"}, {"param_name": ["toIndex"], "param_type": "int", "param_description": " index after the last bit to be set"}, {"param_name": ["value"], "param_type": "boolean", "param_description": " value to set the selected bits to"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "set", "method_description": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to the specified value.\n", "method_declar": ""}, {"params": [{"param_name": ["fromIndex"], "param_type": "int", "param_description": " index of the first bit to be set"}, {"param_name": ["toIndex"], "param_type": "int", "param_description": " index after the last bit to be set"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "set", "method_description": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to true.\n", "method_declar": ""}, {"params": [{"param_name": ["bitIndex"], "param_type": "int", "param_description": " a bit index"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "set", "method_description": "Sets the bit at the specified index to true.\n", "method_declar": ""}, {"params": [{"param_name": ["bitIndex"], "param_type": "int", "param_description": " a bit index"}, {"param_name": ["value"], "param_type": "boolean", "param_description": " a boolean value to set"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "set", "method_description": "Sets the bit at the specified index to the specified value.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["the number of bits currently in this bit set"], "return_type": ["int"]}, "method_name": "size", "method_description": "Returns the number of bits of space actually in use by this\n BitSet to represent bit values.\n The maximum element in the set is the size - 1st element.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["a stream of integers representing set indices"], "return_type": ["IntStream"]}, "method_name": "stream", "method_description": "Returns a stream of indices for which this BitSet\n contains a bit in the set state. The indices are returned\n in order, from lowest to highest. The size of the stream\n is the number of bits in the set state, equal to the value\n returned by the cardinality() method.\n\n \nThe bit set must remain constant during the execution of the\n terminal stream operation.  Otherwise, the result of the terminal\n stream operation is undefined.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["a byte array containing a little-endian representation\n         of all the bits in this bit set"], "return_type": ["byte[]"]}, "method_name": "toByteArray", "method_description": "Returns a new byte array containing all the bits in this bit set.\n\n \nMore precisely, if\n byte[] bytes = s.toByteArray();\nthen bytes.length == (s.length()+7)/8 and\n s.get(n) == ((bytes[n/8] & (1<<(n%8))) != 0)\nfor all n < 8 * bytes.length.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["a long array containing a little-endian representation\n         of all the bits in this bit set"], "return_type": ["long[]"]}, "method_name": "toLongArray", "method_description": "Returns a new long array containing all the bits in this bit set.\n\n \nMore precisely, if\n long[] longs = s.toLongArray();\nthen longs.length == (s.length()+63)/64 and\n s.get(n) == ((longs[n/64] & (1L<<(n%64))) != 0)\nfor all n < 64 * longs.length.\n", "method_declar": ""}, {"params": [], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": ["a string representation of this bit set"], "return_type": ["String"]}, "method_name": "toString", "method_description": "Returns a string representation of this bit set. For every index\n for which this BitSet contains a bit in the set\n state, the decimal representation of that index is included in\n the result. Such indices are listed in order from lowest to\n highest, separated by \",\u00a0\" (a comma and a space) and\n surrounded by braces, resulting in the usual mathematical\n notation for a set of integers.\n\n \nExample:\n \n", "method_declar": ""}, {"params": [{"param_name": ["longs"], "param_type": "long[]", "param_description": " a long array containing a little-endian representation\n        of a sequence of bits to be used as the initial bits of the\n        new bit set"}], "class_name": "BitSet", "is_static": true, "return_value": {"return_name": [], "return_description": ["a BitSet containing all the bits in the long array"], "return_type": ["BitSet"]}, "method_name": "valueOf", "method_description": "Returns a new bit set containing all the bits in the given long array.\n\n \nMore precisely,\n BitSet.valueOf(longs).get(n) == ((longs[n/64] & (1L<<(n%64))) != 0)\nfor all n < 64 * longs.length.\n\n \nThis method is equivalent to\n BitSet.valueOf(LongBuffer.wrap(longs)).\n", "method_declar": ""}, {"params": [{"param_name": ["bytes"], "param_type": "byte[]", "param_description": " a byte array containing a little-endian\n        representation of a sequence of bits to be used as the\n        initial bits of the new bit set"}], "class_name": "BitSet", "is_static": true, "return_value": {"return_name": [], "return_description": ["a BitSet containing all the bits in the byte array"], "return_type": ["BitSet"]}, "method_name": "valueOf", "method_description": "Returns a new bit set containing all the bits in the given byte array.\n\n \nMore precisely,\n BitSet.valueOf(bytes).get(n) == ((bytes[n/8] & (1<<(n%8))) != 0)\nfor all n <  8 * bytes.length.\n\n \nThis method is equivalent to\n BitSet.valueOf(ByteBuffer.wrap(bytes)).\n", "method_declar": ""}, {"params": [{"param_name": ["bb"], "param_type": "ByteBuffer", "param_description": " a byte buffer containing a little-endian representation\n        of a sequence of bits between its position and limit, to be\n        used as the initial bits of the new bit set"}], "class_name": "BitSet", "is_static": true, "return_value": {"return_name": [], "return_description": ["a BitSet containing all the bits in the buffer in the\n         specified range"], "return_type": ["BitSet"]}, "method_name": "valueOf", "method_description": "Returns a new bit set containing all the bits in the given byte\n buffer between its position and limit.\n\n \nMore precisely,\n BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n/8) & (1<<(n%8))) != 0)\nfor all n < 8 * bb.remaining().\n\n \nThe byte buffer is not modified by this method, and no\n reference to the buffer is retained by the bit set.\n", "method_declar": ""}, {"params": [{"param_name": ["lb"], "param_type": "LongBuffer", "param_description": " a long buffer containing a little-endian representation\n        of a sequence of bits between its position and limit, to be\n        used as the initial bits of the new bit set"}], "class_name": "BitSet", "is_static": true, "return_value": {"return_name": [], "return_description": ["a BitSet containing all the bits in the buffer in the\n         specified range"], "return_type": ["BitSet"]}, "method_name": "valueOf", "method_description": "Returns a new bit set containing all the bits in the given long\n buffer between its position and limit.\n\n \nMore precisely,\n BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n/64) & (1L<<(n%64))) != 0)\nfor all n < 64 * lb.remaining().\n\n \nThe long buffer is not modified by this method, and no\n reference to the buffer is retained by the bit set.\n", "method_declar": ""}, {"params": [{"param_name": ["set"], "param_type": "BitSet", "param_description": " a bit set"}], "class_name": "BitSet", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "xor", "method_description": "Performs a logical XOR of this bit set with the bit set\n argument. This bit set is modified so that a bit in it has the\n value true if and only if one of the following\n statements holds:\n \n", "method_declar": ""}], "class_name": "BitSet", "Vars": null}