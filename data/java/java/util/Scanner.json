{"package_name": "java.util", "subclass_list": [], "class_description": "A simple text scanner which can parse primitive types and strings using\n regular expressions. A Scanner breaks its input into tokens using a\n delimiter pattern, which by default matches whitespace. The resulting\n tokens may then be converted into values of different types using the\n various next methods. For example, this code allows a user to read a number from\n System.in: As another example, this code allows long types to be\n assigned from entries in a file myNumbers: The scanner can also use delimiters other than whitespace. This\n example reads several items in from a string: prints the following output: The same output can be generated with this code, which uses a regular\n expression to parse all four tokens at once: The default whitespace delimiter used\n by a scanner is as recognized by Character.isWhitespace. The reset()\n method will reset the value of the scanner's delimiter to the default\n whitespace delimiter regardless of whether it was previously changed. A scanning operation may block waiting for input. The next() and hasNext() methods and their\n primitive-type companion methods (such as nextInt() and\n hasNextInt()) first skip any input that matches the delimiter\n pattern, and then attempt to return the next token. Both hasNext\n and next methods may block waiting for further input.  Whether a\n hasNext method blocks has no connection to whether or not its\n associated next method will block. The findInLine(String), findWithinHorizon(String, int), and skip(String)\n methods operate independently of the delimiter pattern. These methods will\n attempt to match the specified pattern with no regard to delimiters in the\n input and thus can be used in special circumstances where delimiters are\n not relevant. These methods may block waiting for more input. When a scanner throws an InputMismatchException, the scanner\n will not pass the token that caused the exception, so that it may be\n retrieved or skipped via some other method. Depending upon the type of delimiting pattern, empty tokens may be\n returned. For example, the pattern \"\\\\s+\" will return no empty\n tokens since it matches multiple instances of the delimiter. The delimiting\n pattern \"\\\\s\" could return empty tokens since it only passes one\n space at a time. A scanner can read text from any object which implements the Readable interface.  If an invocation of the underlying\n readable's Readable.read(CharBuffer) method throws an IOException then the scanner assumes that the end of the input\n has been reached.  The most recent IOException thrown by the\n underlying readable can be retrieved via the ioException() method. When a Scanner is closed, it will close its input source\n if the source implements the Closeable interface. A Scanner is not safe for multithreaded use without\n external synchronization. Unless otherwise mentioned, passing a null parameter into\n any method of a Scanner will cause a\n NullPointerException to be thrown. A scanner will default to interpreting numbers as decimal unless a\n different radix has been set by using the useRadix(int) method. The\n reset() method will reset the value of the scanner's radix to\n 10 regardless of whether it was previously changed. An instance of this class is capable of scanning numbers in the standard\n formats as well as in the formats of the scanner's locale. A scanner's\n initial locale is the value returned by the Locale.getDefault(Locale.Category.FORMAT) method; it may be changed via the useLocale(Locale) method. The reset() method will reset the value of the\n scanner's locale to the initial locale regardless of whether it was\n previously changed. The localized formats are defined in terms of the following parameters,\n which for a particular locale are taken from that locale's DecimalFormat object, df, and its and\n DecimalFormatSymbols object,\n dfs. The strings that can be parsed as numbers by an instance of this class\n are specified in terms of the following regular-expression grammar, where\n Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10). Whitespace is not significant in the above regular expressions. ", "class_type": "class", "typealias": [], "interface_list": ["Iterator<String>", "Closeable"], "class_inherit_list": ["Object"], "Methods": [{"params": [{"param_name": ["source"], "param_type": "Readable", "param_description": " A character source implementing the Readable\n         interface"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified source.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "InputStream", "param_description": " An input stream to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the underlying platform's\n default charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "InputStream", "param_description": " An input stream to be scanned"}, {"param_name": ["charsetName"], "param_type": "String", "param_description": " The encoding type used to convert bytes from the\n        stream into characters to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the specified charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "File", "param_description": " A file to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the underlying platform's\n default charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "File", "param_description": " A file to be scanned"}, {"param_name": ["charsetName"], "param_type": "String", "param_description": " The encoding type used to convert bytes from the file\n        into characters to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "Path", "param_description": " the path to the file to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the underlying platform's\n default charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "Path", "param_description": " the path to the file to be scanned"}, {"param_name": ["charsetName"], "param_type": "String", "param_description": " The encoding type used to convert bytes from the file\n          into characters to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "String", "param_description": " A string to scan"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified string.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "ReadableByteChannel", "param_description": " A channel to scan"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the underlying platform's\n default charset.\n", "method_declar": ""}, {"params": [{"param_name": ["source"], "param_type": "ReadableByteChannel", "param_description": " A channel to scan"}, {"param_name": ["charsetName"], "param_type": "String", "param_description": " The encoding type used to convert bytes from the\n        channel into characters to be scanned"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Constructs a new Scanner that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the specified charset.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "close", "method_description": "Closes this scanner.\n\n \n If this scanner has not yet been closed then if its underlying\n readable also implements the Closeable interface then the readable's close method\n will be invoked.  If this scanner is already closed then invoking this\n method will have no effect.\n\n \nAttempting to perform search operations after a scanner has\n been closed will result in an IllegalStateException.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner's delimiting pattern."], "return_type": ["Pattern"]}, "method_name": "delimiter", "method_description": "Returns the Pattern this Scanner is currently\n using to match delimiters.\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "String", "param_description": " a string specifying the pattern to search for"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the text that matched the specified pattern"], "return_type": ["String"]}, "method_name": "findInLine", "method_description": "Attempts to find the next occurrence of a pattern constructed from the\n specified string, ignoring delimiters.\n\n \nAn invocation of this method of the form findInLine(pattern)\n behaves in exactly the same way as the invocation\n findInLine(Pattern.compile(pattern)).\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "Pattern", "param_description": " the pattern to scan for"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the text that matched the specified pattern"], "return_type": ["String"]}, "method_name": "findInLine", "method_description": "Attempts to find the next occurrence of the specified pattern ignoring\n delimiters. If the pattern is found before the next line separator, the\n scanner advances past the input that matched and returns the string that\n matched the pattern.\n If no such pattern is detected in the input up to the next line\n separator, then null is returned and the scanner's\n position is unchanged. This method may block waiting for input that\n matches the pattern.\n\n \nSince this method continues to search through the input looking\n for the specified pattern, it may buffer all of the input searching for\n the desired token if no line separators are present.\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "Pattern", "param_description": " the pattern to scan for"}, {"param_name": ["horizon"], "param_type": "int", "param_description": " the search horizon"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the text that matched the specified pattern"], "return_type": ["String"]}, "method_name": "findWithinHorizon", "method_description": "Attempts to find the next occurrence of the specified pattern.\n\n \nThis method searches through the input up to the specified\n search horizon, ignoring delimiters. If the pattern is found the\n scanner advances past the input that matched and returns the string\n that matched the pattern. If no such pattern is detected then the\n null is returned and the scanner's position remains unchanged. This\n method may block waiting for input that matches the pattern.\n\n \nA scanner will never search more than horizon code\n points beyond its current position. Note that a match may be clipped\n by the horizon; that is, an arbitrary match result may have been\n different if the horizon had been larger. The scanner treats the\n horizon as a transparent, non-anchoring bound (see Matcher#useTransparentBounds and Matcher#useAnchoringBounds).\n\n \nIf horizon is 0, then the horizon is ignored and\n this method continues to search through the input looking for the\n specified pattern without bound. In this case it may buffer all of\n the input searching for the pattern.\n\n \nIf horizon is negative, then an IllegalArgumentException is\n thrown.\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "String", "param_description": " a string specifying the pattern to search for"}, {"param_name": ["horizon"], "param_type": "int", "param_description": " the search horizon"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the text that matched the specified pattern"], "return_type": ["String"]}, "method_name": "findWithinHorizon", "method_description": "Attempts to find the next occurrence of a pattern constructed from the\n specified string, ignoring delimiters.\n\n \nAn invocation of this method of the form\n findWithinHorizon(pattern) behaves in exactly the same way as\n the invocation\n findWithinHorizon(Pattern.compile(pattern, horizon)).\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner has another token"], "return_type": ["boolean"]}, "method_name": "hasNext", "method_description": "Returns true if this scanner has another token in its input.\n This method may block while waiting for input to scan.\n The scanner does not advance past any input.\nSee also:\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "String", "param_description": " a string specifying the pattern to scan"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner has another token matching\n         the specified pattern"], "return_type": ["boolean"]}, "method_name": "hasNext", "method_description": "Returns true if the next token matches the pattern constructed from the\n specified string. The scanner does not advance past any input.\n\n \n An invocation of this method of the form hasNext(pattern)\n behaves in exactly the same way as the invocation\n hasNext(Pattern.compile(pattern)).\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "Pattern", "param_description": " the pattern to scan for"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner has another token matching\n         the specified pattern"], "return_type": ["boolean"]}, "method_name": "hasNext", "method_description": "Returns true if the next complete token matches the specified pattern.\n A complete token is prefixed and postfixed by input that matches\n the delimiter pattern. This method may block while waiting for input.\n The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         BigDecimal"], "return_type": ["boolean"]}, "method_name": "hasNextBigDecimal", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a BigDecimal using the\n nextBigDecimal() method. The scanner does not advance past any\n input.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as an integer"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         BigInteger"], "return_type": ["boolean"]}, "method_name": "hasNextBigInteger", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a BigInteger in the specified radix using\n the nextBigInteger() method. The scanner does not advance past\n any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         BigInteger"], "return_type": ["boolean"]}, "method_name": "hasNextBigInteger", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a BigInteger in the default radix using the\n nextBigInteger() method. The scanner does not advance past any\n input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         boolean value"], "return_type": ["boolean"]}, "method_name": "hasNextBoolean", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a boolean value using a case insensitive pattern\n created from the string \"true|false\".  The scanner does not\n advance past the input that matched.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         byte value"], "return_type": ["boolean"]}, "method_name": "hasNextByte", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a byte value in the default radix using the\n nextByte() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as a byte value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         byte value"], "return_type": ["boolean"]}, "method_name": "hasNextByte", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a byte value in the specified radix using the\n nextByte() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         double value"], "return_type": ["boolean"]}, "method_name": "hasNextDouble", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a double value using the nextDouble()\n method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         float value"], "return_type": ["boolean"]}, "method_name": "hasNextFloat", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a float value using the nextFloat()\n method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         int value"], "return_type": ["boolean"]}, "method_name": "hasNextInt", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as an int value in the default radix using the\n nextInt() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as an int value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         int value"], "return_type": ["boolean"]}, "method_name": "hasNextInt", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as an int value in the specified radix using the\n nextInt() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner has another line of input"], "return_type": ["boolean"]}, "method_name": "hasNextLine", "method_description": "Returns true if there is another line in the input of this scanner.\n This method may block while waiting for input. The scanner does not\n advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         long value"], "return_type": ["boolean"]}, "method_name": "hasNextLong", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a long value in the default radix using the\n nextLong() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as a long value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         long value"], "return_type": ["boolean"]}, "method_name": "hasNextLong", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a long value in the specified radix using the\n nextLong() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         short value in the default radix"], "return_type": ["boolean"]}, "method_name": "hasNextShort", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a short value in the default radix using the\n nextShort() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as a short value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if and only if this scanner's next token is a valid\n         short value in the specified radix"], "return_type": ["boolean"]}, "method_name": "hasNextShort", "method_description": "Returns true if the next token in this scanner's input can be\n interpreted as a short value in the specified radix using the\n nextShort() method. The scanner does not advance past any input.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the last exception thrown by this scanner's readable"], "return_type": ["IOException"]}, "method_name": "ioException", "method_description": "Returns the IOException last thrown by this\n Scanner's underlying Readable. This method\n returns null if no such exception exists.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner's locale"], "return_type": ["Locale"]}, "method_name": "locale", "method_description": "Returns this scanner's locale.\n\n \nA scanner's locale affects many elements of its default\n primitive matching regular expressions; see\n localized numbers above.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["a match result for the last match operation"], "return_type": ["MatchResult"]}, "method_name": "match", "method_description": "Returns the match result of the last scanning operation performed\n by this scanner. This method throws IllegalStateException\n if no match has been performed, or if the last match was\n not successful.\n\n \nThe various nextmethods of Scanner\n make a match result available if they complete without throwing an\n exception. For instance, after an invocation of the nextInt()\n method that returned an int, this method returns a\n MatchResult for the search of the\n Integer regular expression\n defined above. Similarly the findInLine(String),\n findWithinHorizon(String, int), and skip(String) methods will make a\n match available if they succeed.\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "Pattern", "param_description": " the pattern to scan for"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the next token"], "return_type": ["String"]}, "method_name": "next", "method_description": "Returns the next token if it matches the specified pattern. This\n method may block while waiting for input to scan, even if a previous\n invocation of hasNext(java.util.regex.Pattern) returned true.\n If the match is successful, the scanner advances past the input that\n matched the pattern.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the next token"], "return_type": ["String"]}, "method_name": "next", "method_description": "Finds and returns the next complete token from this scanner.\n A complete token is preceded and followed by input that matches\n the delimiter pattern. This method may block while waiting for input\n to scan, even if a previous invocation of hasNext() returned\n true.\nSee also:\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "String", "param_description": " a string specifying the pattern to scan"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the next token"], "return_type": ["String"]}, "method_name": "next", "method_description": "Returns the next token if it matches the pattern constructed from the\n specified string.  If the match is successful, the scanner advances\n past the input that matched the pattern.\n\n \n An invocation of this method of the form next(pattern)\n behaves in exactly the same way as the invocation\n next(Pattern.compile(pattern)).\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the BigDecimal scanned from the input"], "return_type": ["BigDecimal"]}, "method_name": "nextBigDecimal", "method_description": "Scans the next token of the input as a BigDecimal.\n\n \n If the next token matches the Decimal regular expression defined\n above then the token is converted into a BigDecimal value as if\n by removing all group separators, mapping non-ASCII digits into ASCII\n digits via the Character#digit, and passing the\n resulting string to the BigDecimal(String)\n constructor.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the BigInteger scanned from the input"], "return_type": ["BigInteger"]}, "method_name": "nextBigInteger", "method_description": "Scans the next token of the input as a BigInteger.\n\n \n An invocation of this method of the form\n nextBigInteger() behaves in exactly the same way as the\n invocation nextBigInteger(radix), where radix\n is the default radix of this scanner.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the BigInteger scanned from the input"], "return_type": ["BigInteger"]}, "method_name": "nextBigInteger", "method_description": "Scans the next token of the input as a BigInteger.\n\n \n If the next token matches the Integer regular expression defined\n above then the token is converted into a BigInteger value as if\n by removing all group separators, mapping non-ASCII digits into ASCII\n digits via the Character#digit, and passing the\n resulting string to the BigInteger(String, int) constructor with the specified radix.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the boolean scanned from the input"], "return_type": ["boolean"]}, "method_name": "nextBoolean", "method_description": "Scans the next token of the input into a boolean value and returns\n that value. This method will throw InputMismatchException\n if the next token cannot be translated into a valid boolean value.\n If the match is successful, the scanner advances past the input that\n matched.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as a byte value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the byte scanned from the input"], "return_type": ["byte"]}, "method_name": "nextByte", "method_description": "Scans the next token of the input as a byte.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid byte value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \n If the next token matches the Integer regular expression defined\n above then the token is converted into a byte value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character#digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Byte#parseByte(String, int) with the\n specified radix.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the byte scanned from the input"], "return_type": ["byte"]}, "method_name": "nextByte", "method_description": "Scans the next token of the input as a byte.\n\n \n An invocation of this method of the form\n nextByte() behaves in exactly the same way as the\n invocation nextByte(radix), where radix\n is the default radix of this scanner.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the double scanned from the input"], "return_type": ["double"]}, "method_name": "nextDouble", "method_description": "Scans the next token of the input as a double.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid double value.\n If the translation is successful, the scanner advances past the input\n that matched.\n\n \n If the next token matches the Float regular expression defined above\n then the token is converted into a double value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character#digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Double#parseDouble. If the token matches\n the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\"\n is passed to Double#parseDouble(String) as\n appropriate.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the float scanned from the input"], "return_type": ["float"]}, "method_name": "nextFloat", "method_description": "Scans the next token of the input as a float.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid float value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \n If the next token matches the Float regular expression defined above\n then the token is converted into a float value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character#digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Float#parseFloat. If the token matches\n the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\"\n is passed to Float#parseFloat(String) as\n appropriate.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the int scanned from the input"], "return_type": ["int"]}, "method_name": "nextInt", "method_description": "Scans the next token of the input as an int.\n\n \n An invocation of this method of the form\n nextInt() behaves in exactly the same way as the\n invocation nextInt(radix), where radix\n is the default radix of this scanner.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as an int value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the int scanned from the input"], "return_type": ["int"]}, "method_name": "nextInt", "method_description": "Scans the next token of the input as an int.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid int value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \n If the next token matches the Integer regular expression defined\n above then the token is converted into an int value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character#digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Integer#parseInt(String, int) with the\n specified radix.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the line that was skipped"], "return_type": ["String"]}, "method_name": "nextLine", "method_description": "Advances this scanner past the current line and returns the input\n that was skipped.\n\n This method returns the rest of the current line, excluding any line\n separator at the end. The position is set to the beginning of the next\n line.\n\n \nSince this method continues to search through the input looking\n for a line separator, it may buffer all of the input searching for\n the line to skip if no line separators are present.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the long scanned from the input"], "return_type": ["long"]}, "method_name": "nextLong", "method_description": "Scans the next token of the input as a long.\n\n \n An invocation of this method of the form\n nextLong() behaves in exactly the same way as the\n invocation nextLong(radix), where radix\n is the default radix of this scanner.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as an int value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the long scanned from the input"], "return_type": ["long"]}, "method_name": "nextLong", "method_description": "Scans the next token of the input as a long.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid long value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \n If the next token matches the Integer regular expression defined\n above then the token is converted into a long value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character#digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Long#parseLong(String, int) with the\n specified radix.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " the radix used to interpret the token as a short value"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the short scanned from the input"], "return_type": ["short"]}, "method_name": "nextShort", "method_description": "Scans the next token of the input as a short.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid short value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \n If the next token matches the Integer regular expression defined\n above then the token is converted into a short value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character#digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Short#parseShort(String, int) with the\n specified radix.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the short scanned from the input"], "return_type": ["short"]}, "method_name": "nextShort", "method_description": "Scans the next token of the input as a short.\n\n \n An invocation of this method of the form\n nextShort() behaves in exactly the same way as the\n invocation nextShort(radix), where radix\n is the default radix of this scanner.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["the default radix of this scanner"], "return_type": ["int"]}, "method_name": "radix", "method_description": "Returns this scanner's default radix.\n\n \nA scanner's radix affects elements of its default\n number matching regular expressions; see\n localized numbers above.\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "remove", "method_description": "The remove operation is not supported by this implementation of\n Iterator.\nSee also:\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "reset", "method_description": "Resets this scanner.\n\n \n Resetting a scanner discards all of its explicit state\n information which may have been changed by invocations of useDelimiter(String), useLocale(Locale), or useRadix(int).\n\n \n An invocation of this method of the form\n scanner.reset() behaves in exactly the same way as the\n invocation\n\n \n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "String", "param_description": " a string specifying the pattern to skip over"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "skip", "method_description": "Skips input that matches a pattern constructed from the specified\n string.\n\n \n An invocation of this method of the form skip(pattern)\n behaves in exactly the same way as the invocation\n skip(Pattern.compile(pattern)).\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "Pattern", "param_description": " a string specifying the pattern to skip over"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "skip", "method_description": "Skips input that matches the specified pattern, ignoring delimiters.\n This method will skip input if an anchored match of the specified\n pattern succeeds.\n\n \nIf a match to the specified pattern is not found at the\n current position, then no input is skipped and a\n NoSuchElementException is thrown.\n\n \nSince this method seeks to match the specified pattern starting at\n the scanner's current position, patterns that can match a lot of\n input (\".*\", for example) may cause the scanner to buffer a large\n amount of input.\n\n \nNote that it is possible to skip something without risking a\n NoSuchElementException by using a pattern that can\n match nothing, e.g., sc.skip(\"[ \\t]*\").\n", "method_declar": ""}, {"params": [], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["The string representation of this scanner"], "return_type": ["String"]}, "method_name": "toString", "method_description": "\nReturns the string representation of this Scanner. The\n string representation of a Scanner contains information\n that may be useful for debugging. The exact format is unspecified.\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "Pattern", "param_description": " A delimiting pattern"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "useDelimiter", "method_description": "Sets this scanner's delimiting pattern to the specified pattern.\n", "method_declar": ""}, {"params": [{"param_name": ["pattern"], "param_type": "String", "param_description": " A string specifying a delimiting pattern"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "useDelimiter", "method_description": "Sets this scanner's delimiting pattern to a pattern constructed from\n the specified String.\n\n \n An invocation of this method of the form\n useDelimiter(pattern) behaves in exactly the same way as the\n invocation useDelimiter(Pattern.compile(pattern)).\n\n \n Invoking the reset() method will set the scanner's delimiter\n to the default.\n", "method_declar": ""}, {"params": [{"param_name": ["locale"], "param_type": "Locale", "param_description": " A string specifying the locale to use"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "useLocale", "method_description": "Sets this scanner's locale to the specified locale.\n\n \nA scanner's locale affects many elements of its default\n primitive matching regular expressions; see\n localized numbers above.\n\n \nInvoking the reset() method will set the scanner's locale to\n the initial locale.\n", "method_declar": ""}, {"params": [{"param_name": ["radix"], "param_type": "int", "param_description": " The radix to use when scanning numbers"}], "class_name": "Scanner", "is_static": false, "return_value": {"return_name": [], "return_description": ["this scanner"], "return_type": ["Scanner"]}, "method_name": "useRadix", "method_description": "Sets this scanner's default radix to the specified radix.\n\n \nA scanner's radix affects elements of its default\n number matching regular expressions; see\n localized numbers above.\n\n \nIf the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown.\n\n \nInvoking the reset() method will set the scanner's radix to\n 10.\n", "method_declar": ""}], "class_name": "Scanner", "Vars": null}