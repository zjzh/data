{"package_name": "java.util", "subclass_list": ["Spliterator.OfDouble", "Spliterator.OfInt", "Spliterator.OfLong", "Spliterator.OfPrimitive", "OfPrimitive", "Spliterators.AbstractDoubleSpliterator", "Spliterators.AbstractIntSpliterator", "Spliterators.AbstractLongSpliterator", "Spliterators.AbstractSpliterator", "Spliterator.OfDouble", "Spliterator.OfInt", "Spliterator.OfLong", "Spliterator.OfPrimitive", "OfPrimitive", "Spliterators.AbstractDoubleSpliterator", "Spliterators.AbstractIntSpliterator", "Spliterators.AbstractLongSpliterator", "Spliterators.AbstractSpliterator"], "class_description": "An object for traversing and partitioning elements of a source.  The source\n of elements covered by a Spliterator could be, for example, an array, a\n Collection, an IO channel, or a generator function. A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk\n (forEachRemaining()). A Spliterator may also partition off some of its elements (using\n trySplit()) as another Spliterator, to be used in\n possibly-parallel operations.  Operations using a Spliterator that\n cannot split, or does so in a highly imbalanced or inefficient\n manner, are unlikely to benefit from parallelism.  Traversal\n and splitting exhaust elements; each Spliterator is useful for only a single\n bulk computation. A Spliterator also reports a set of characteristics() of its\n structure, source, and elements from among ORDERED,\n DISTINCT, SORTED, SIZED, NONNULL,\n IMMUTABLE, CONCURRENT, and SUBSIZED. These may\n be employed by Spliterator clients to control, specialize or simplify\n computation.  For example, a Spliterator for a Collection would\n report SIZED, a Spliterator for a Set would report\n DISTINCT, and a Spliterator for a SortedSet would also\n report SORTED.  Characteristics are reported as a simple unioned bit\n set.\n\n Some characteristics additionally constrain method behavior; for example if\n ORDERED, traversal methods must conform to their documented ordering.\n New characteristics may be defined in the future, so implementors should not\n assign meanings to unlisted values. A Spliterator that does not report IMMUTABLE or\n CONCURRENT is expected to have a documented policy concerning:\n when the spliterator binds to the element source; and detection of\n structural interference of the element source detected after binding.  A\n late-binding Spliterator binds to the source of elements at the\n point of first traversal, first split, or first query for estimated size,\n rather than at the time the Spliterator is created.  A Spliterator that is\n not late-binding binds to the source of elements at the point of\n construction or first invocation of any method.  Modifications made to the\n source prior to binding are reflected when the Spliterator is traversed.\n After binding a Spliterator should, on a best-effort basis, throw\n ConcurrentModificationException if structural interference is\n detected.  Spliterators that do this are called fail-fast.  The\n bulk traversal method (forEachRemaining()) of a\n Spliterator may optimize traversal and check for structural interference\n after all elements have been traversed, rather than checking per-element and\n failing immediately. Spliterators can provide an estimate of the number of remaining elements\n via the estimateSize() method.  Ideally, as reflected in characteristic\n SIZED, this value corresponds exactly to the number of elements\n that would be encountered in a successful traversal.  However, even when not\n exactly known, an estimated value value may still be useful to operations\n being performed on the source, such as helping to determine whether it is\n preferable to split further or traverse the remaining elements sequentially. Despite their obvious utility in parallel algorithms, spliterators are not\n expected to be thread-safe; instead, implementations of parallel algorithms\n using spliterators should ensure that the spliterator is only used by one\n thread at a time.  This is generally easy to attain via serial\n thread-confinement, which often is a natural consequence of typical\n parallel algorithms that work by recursive decomposition.  A thread calling\n trySplit() may hand over the returned Spliterator to another thread,\n which in turn may traverse or further split that Spliterator.  The behaviour\n of splitting and traversal is undefined if two or more threads operate\n concurrently on the same spliterator.  If the original thread hands a\n spliterator off to another thread for processing, it is best if that handoff\n occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of\n estimateSize() for SIZED spliterators) are only valid before\n traversal has begun. Primitive subtype specializations of Spliterator are provided for\n OfInt, OfLong, and OfDouble values.\n The subtype default implementations of\n Spliterator#tryAdvance(java.util.function.Consumer)\n and Spliterator#forEachRemaining(java.util.function.Consumer) box\n primitive values to instances of their corresponding wrapper class.  Such\n boxing may undermine any performance advantages gained by using the primitive\n specializations.  To avoid boxing, the corresponding primitive-based methods\n should be used.  For example,\n Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)\n and Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)\n should be used in preference to\n Spliterator.OfInt#tryAdvance(java.util.function.Consumer) and\n Spliterator.OfInt#forEachRemaining(java.util.function.Consumer).\n Traversal of primitive values using boxing-based methods\n tryAdvance() and\n forEachRemaining()\n does not affect the order in which the values, transformed to boxed values,\n are encountered. ", "class_type": "interface", "typealias": [], "interface_list": [""], "class_inherit_list": [], "Methods": [], "class_name": "Spliterator", "Vars": null}