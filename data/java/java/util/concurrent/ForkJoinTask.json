{"package_name": "java.util.concurrent", "subclass_list": ["CountedCompleter", "RecursiveAction", "RecursiveTask", "CountedCompleter", "ForkJoinTask", "RecursiveAction", "ForkJoinTask", "RecursiveTask", "ForkJoinTask"], "class_description": "Abstract base class for tasks that run within a ForkJoinPool.\n A ForkJoinTask is a thread-like entity that is much\n lighter weight than a normal thread.  Huge numbers of tasks and\n subtasks may be hosted by a small number of actual threads in a\n ForkJoinPool, at the price of some usage limitations. A \"main\" ForkJoinTask begins execution when it is\n explicitly submitted to a ForkJoinPool, or, if not already\n engaged in a ForkJoin computation, commenced in the ForkJoinPool#commonPool() via fork(), invoke(), or\n related methods.  Once started, it will usually in turn start other\n subtasks.  As indicated by the name of this class, many programs\n using ForkJoinTask employ only methods fork() and\n join(), or derivatives such as invokeAll.  However, this class also\n provides a number of other methods that can come into play in\n advanced usages, as well as extension mechanics that allow support\n of new forms of fork/join processing. A ForkJoinTask is a lightweight form of Future.\n The efficiency of ForkJoinTasks stems from a set of\n restrictions (that are only partially statically enforceable)\n reflecting their main use as computational tasks calculating pure\n functions or operating on purely isolated objects.  The primary\n coordination mechanisms are fork(), that arranges\n asynchronous execution, and join(), that doesn't proceed\n until the task's result has been computed.  Computations should\n ideally avoid synchronized methods or blocks, and should\n minimize other blocking synchronization apart from joining other\n tasks or using synchronizers such as Phasers that are advertised to\n cooperate with fork/join scheduling. Subdividable tasks should also\n not perform blocking I/O, and should ideally access variables that\n are completely independent of those accessed by other running\n tasks. These guidelines are loosely enforced by not permitting\n checked exceptions such as IOExceptions to be\n thrown. However, computations may still encounter unchecked\n exceptions, that are rethrown to callers attempting to join\n them. These exceptions may additionally include RejectedExecutionException stemming from internal resource\n exhaustion, such as failure to allocate internal task\n queues. Rethrown exceptions behave in the same way as regular\n exceptions, but, when possible, contain stack traces (as displayed\n for example using ex.printStackTrace()) of both the thread\n that initiated the computation as well as the thread actually\n encountering the exception; minimally only the latter. It is possible to define and use ForkJoinTasks that may block,\n but doing do requires three further considerations: (1) Completion\n of few if any other tasks should be dependent on a task\n that blocks on external synchronization or I/O. Event-style async\n tasks that are never joined (for example, those subclassing CountedCompleter) often fall into this category.  (2) To minimize\n resource impact, tasks should be small; ideally performing only the\n (possibly) blocking action. (3) Unless the ForkJoinPool.ManagedBlocker API is used, or the number of possibly\n blocked tasks is known to be less than the pool's ForkJoinPool#getParallelism level, the pool cannot guarantee that\n enough threads will be available to ensure progress or good\n performance. The primary method for awaiting completion and extracting\n results of a task is join(), but there are several variants:\n The Future#get methods support interruptible and/or timed\n waits for completion and report results using Future\n conventions. Method invoke() is semantically\n equivalent to fork(); join() but always attempts to begin\n execution in the current thread. The \"quiet\" forms of\n these methods do not extract results or report exceptions. These\n may be useful when a set of tasks are being executed, and you need\n to delay processing of results or exceptions until all complete.\n Method invokeAll (available in multiple versions)\n performs the most common form of parallel invocation: forking a set\n of tasks and joining them all. In the most typical usages, a fork-join pair act like a call\n (fork) and return (join) from a parallel recursive function. As is\n the case with other forms of recursive calls, returns (joins)\n should be performed innermost-first. For example, a.fork();\n b.fork(); b.join(); a.join(); is likely to be substantially more\n efficient than joining a before b. The execution status of tasks may be queried at several levels\n of detail: isDone() is true if a task completed in any way\n (including the case where a task was cancelled without executing);\n isCompletedNormally() is true if a task completed without\n cancellation or encountering an exception; isCancelled() is\n true if the task was cancelled (in which case getException()\n returns a CancellationException); and\n isCompletedAbnormally() is true if a task was either\n cancelled or encountered an exception, in which case getException() will return either the encountered exception or\n CancellationException. The ForkJoinTask class is not usually directly subclassed.\n Instead, you subclass one of the abstract classes that support a\n particular style of fork/join processing, typically RecursiveAction for most computations that do not return results,\n RecursiveTask for those that do, and CountedCompleter for those in which completed actions trigger\n other actions.  Normally, a concrete ForkJoinTask subclass declares\n fields comprising its parameters, established in a constructor, and\n then defines a compute method that somehow uses the control\n methods supplied by this base class. Method join() and its variants are appropriate for use\n only when completion dependencies are acyclic; that is, the\n parallel computation can be described as a directed acyclic graph\n (DAG). Otherwise, executions may encounter a form of deadlock as\n tasks cyclically wait for each other.  However, this framework\n supports other methods and techniques (for example the use of\n Phaser, helpQuiesce(), and complete(V)) that\n may be of use in constructing custom subclasses for problems that\n are not statically structured as DAGs. To support such usages, a\n ForkJoinTask may be atomically tagged with a short\n value using setForkJoinTaskTag(short) or compareAndSetForkJoinTaskTag(short, short) and checked using getForkJoinTaskTag(). The ForkJoinTask implementation does not use\n these protected methods or tags for any purpose, but they\n may be of use in the construction of specialized subclasses.  For\n example, parallel graph traversals can use the supplied methods to\n avoid revisiting nodes/tasks that have already been processed.\n (Method names for tagging are bulky in part to encourage definition\n of methods that reflect their usage patterns.) Most base support methods are final, to prevent\n overriding of implementations that are intrinsically tied to the\n underlying lightweight task scheduling framework.  Developers\n creating new basic styles of fork/join processing should minimally\n implement protected methods exec(), setRawResult(V), and getRawResult(), while also introducing\n an abstract computational method that can be implemented in its\n subclasses, possibly relying on other protected methods\n provided by this class. ForkJoinTasks should perform relatively small amounts of\n computation. Large tasks should be split into smaller subtasks,\n usually via recursive decomposition. As a very rough rule of thumb,\n a task should perform more than 100 and less than 10000 basic\n computational steps, and should avoid indefinite looping. If tasks\n are too big, then parallelism cannot improve throughput. If too\n small, then memory and internal task maintenance overhead may\n overwhelm processing. This class provides adapt methods for Runnable\n and Callable, that may be of use when mixing execution of\n ForkJoinTasks with other kinds of tasks. When all tasks are\n of this form, consider using a pool constructed in asyncMode. ForkJoinTasks are Serializable, which enables them to be\n used in extensions such as remote execution frameworks. It is\n sensible to serialize tasks only before or after, but not during,\n execution. Serialization is not relied on during execution itself. ", "class_type": "class", "typealias": [], "interface_list": ["Future", "Serializable"], "class_inherit_list": ["Object"], "Methods": [{"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "\n", "method_declar": ""}, {"params": [{"param_name": ["runnable"], "param_type": "Runnable", "param_description": " the runnable action"}, {"param_name": ["result"], "param_type": "T", "param_description": " the result upon completion"}], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the task"], "return_type": ["ForkJoinTask<T>"]}, "method_name": "adapt", "method_description": "Returns a new ForkJoinTask that performs the run\n method of the given Runnable as its action, and returns\n the given result upon join().\n", "method_declar": ""}, {"params": [{"param_name": ["runnable"], "param_type": "Runnable", "param_description": " the runnable action"}], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the task"], "return_type": ["ForkJoinTask<?>"]}, "method_name": "adapt", "method_description": "Returns a new ForkJoinTask that performs the run\n method of the given Runnable as its action, and returns\n a null result upon join().\n", "method_declar": ""}, {"params": [{"param_name": ["callable"], "param_type": "Callable", "param_description": " the callable action"}], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the task"], "return_type": ["ForkJoinTask<T>"]}, "method_name": "adapt", "method_description": "Returns a new ForkJoinTask that performs the call\n method of the given Callable as its action, and returns\n its result upon join(), translating any checked exceptions\n encountered into RuntimeException.\n", "method_declar": ""}, {"params": [{"param_name": ["mayInterruptIfRunning"], "param_type": "boolean", "param_description": " this value has no effect in the\n default implementation because interrupts are not used to\n control cancellation."}], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if this task is now cancelled"], "return_type": ["boolean"]}, "method_name": "cancel", "method_description": "Attempts to cancel execution of this task. This attempt will\n fail if the task has already completed or could not be\n cancelled for some other reason. If successful, and this task\n has not started when cancel is called, execution of\n this task is suppressed. After this method returns\n successfully, unless there is an intervening call to reinitialize(), subsequent calls to isCancelled(),\n isDone(), and cancel will return true\n and calls to join() and related methods will result in\n CancellationException.\n\n \nThis method may be overridden in subclasses, but if so, must\n still ensure that these properties hold. In particular, the\n cancel method itself must not throw exceptions.\n\n \nThis method is designed to be invoked by other\n tasks. To terminate the current task, you can just return or\n throw an unchecked exception from its computation method, or\n invoke completeExceptionally(java.lang.Throwable).\n", "method_declar": ""}, {"params": [{"param_name": ["expect"], "param_type": "short", "param_description": " the expected tag value"}, {"param_name": ["update"], "param_type": "short", "param_description": " the new tag value"}], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if successful; i.e., the current value was\n equal to expect and was changed to update."], "return_type": ["boolean"]}, "method_name": "compareAndSetForkJoinTaskTag", "method_description": "Atomically conditionally sets the tag value for this task.\n Among other applications, tags can be used as visit markers\n in tasks operating on graphs, as in methods that check: if (task.compareAndSetForkJoinTaskTag((short)0, (short)1))\n before processing, otherwise exiting because the node has\n already been visited.\n", "method_declar": ""}, {"params": [{"param_name": ["value"], "param_type": "V", "param_description": " the result value for this task"}], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "complete", "method_description": "Completes this task, and if not already aborted or cancelled,\n returning the given value as the result of subsequent\n invocations of join and related operations. This method\n may be used to provide results for asynchronous tasks, or to\n provide alternative handling for tasks that would not otherwise\n complete normally. Its use in other situations is\n discouraged. This method is overridable, but overridden\n versions must invoke super implementation to maintain\n guarantees.\n", "method_declar": ""}, {"params": [{"param_name": ["ex"], "param_type": "Throwable", "param_description": " the exception to throw. If this exception is not a\n RuntimeException or Error, the actual exception\n thrown will be a RuntimeException with cause ex."}], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "completeExceptionally", "method_description": "Completes this task abnormally, and if not already aborted or\n cancelled, causes it to throw the given exception upon\n join and related operations. This method may be used\n to induce exceptions in asynchronous tasks, or to force\n completion of tasks that would not otherwise complete.  Its use\n in other situations is discouraged.  This method is\n overridable, but overridden versions must invoke super\n implementation to maintain guarantees.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["this, to simplify usage"], "return_type": ["ForkJoinTask<V>"]}, "method_name": "fork", "method_description": "Arranges to asynchronously execute this task in the pool the\n current task is running in, if applicable, or using the ForkJoinPool#commonPool() if not inForkJoinPool().  While\n it is not necessarily enforced, it is a usage error to fork a\n task more than once unless it has completed and been\n reinitialized.  Subsequent modifications to the state of this\n task or any data it operates on are not necessarily\n consistently observable by any thread other than the one\n executing it unless preceded by a call to join() or\n related methods, or a call to isDone() returning true.\n", "method_declar": ""}, {"params": [{"param_name": ["timeout"], "param_type": "long", "param_description": " the maximum time to wait"}, {"param_name": ["unit"], "param_type": "TimeUnit", "param_description": " the time unit of the timeout argument"}], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the computed result"], "return_type": ["V"]}, "method_name": "get", "method_description": "Waits if necessary for at most the given time for the computation\n to complete, and then retrieves its result, if available.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the computed result"], "return_type": ["V"]}, "method_name": "get", "method_description": "Waits if necessary for the computation to complete, and then\n retrieves its result.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the exception, or null if none"], "return_type": ["Throwable"]}, "method_name": "getException", "method_description": "Returns the exception thrown by the base computation, or a\n CancellationException if cancelled, or null if\n none or if the method has not yet completed.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the tag for this task"], "return_type": ["short"]}, "method_name": "getForkJoinTaskTag", "method_description": "Returns the tag for this task.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the pool, or null if none"], "return_type": ["ForkJoinPool"]}, "method_name": "getPool", "method_description": "Returns the pool hosting the current thread, or null\n if the current thread is executing outside of any ForkJoinPool.\n\n \nThis method returns null if and only if inForkJoinPool() returns false.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the number of tasks"], "return_type": ["int"]}, "method_name": "getQueuedTaskCount", "method_description": "Returns an estimate of the number of tasks that have been\n forked by the current worker thread but not yet executed. This\n value may be useful for heuristic decisions about whether to\n fork other tasks.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the surplus number of tasks, which may be negative"], "return_type": ["int"]}, "method_name": "getSurplusQueuedTaskCount", "method_description": "Returns an estimate of how many more locally queued tasks are\n held by the current worker thread than there are other worker\n threads that might steal them, or zero if this thread is not\n operating in a ForkJoinPool. This value may be useful for\n heuristic decisions about whether to fork other tasks. In many\n usages of ForkJoinTasks, at steady state, each worker should\n aim to maintain a small constant surplus (for example, 3) of\n tasks, and to process computations locally if this threshold is\n exceeded.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "helpQuiesce", "method_description": "Possibly executes tasks until the pool hosting the current task\n ForkJoinPool#isQuiescent.  This\n method may be of use in designs in which many tasks are forked,\n but none are explicitly joined, instead executing them until\n all are processed.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation,\n or false otherwise"], "return_type": ["boolean"]}, "method_name": "inForkJoinPool", "method_description": "Returns true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the computed result"], "return_type": ["V"]}, "method_name": "invoke", "method_description": "Commences performing this task, awaits its completion if\n necessary, and returns its result, or throws an (unchecked)\n RuntimeException or Error if the underlying\n computation did so.\n", "method_declar": ""}, {"params": [{"param_name": ["tasks"], "param_type": "ForkJoinTask...", "param_description": " the tasks"}], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "invokeAll", "method_description": "Forks the given tasks, returning when isDone holds for\n each task or an (unchecked) exception is encountered, in which\n case the exception is rethrown. If more than one task\n encounters an exception, then this method throws any one of\n these exceptions. If any task encounters an exception, others\n may be cancelled. However, the execution status of individual\n tasks is not guaranteed upon exceptional return. The status of\n each task may be obtained using getException() and\n related methods to check if they have been cancelled, completed\n normally or exceptionally, or left unprocessed.\n", "method_declar": ""}, {"params": [{"param_name": ["t1"], "param_type": "ForkJoinTask", "param_description": " the first task"}, {"param_name": ["t2"], "param_type": "ForkJoinTask", "param_description": " the second task"}], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "invokeAll", "method_description": "Forks the given tasks, returning when isDone holds for\n each task or an (unchecked) exception is encountered, in which\n case the exception is rethrown. If more than one task\n encounters an exception, then this method throws any one of\n these exceptions. If any task encounters an exception, the\n other may be cancelled. However, the execution status of\n individual tasks is not guaranteed upon exceptional return. The\n status of each task may be obtained using getException() and related methods to check if they have been\n cancelled, completed normally or exceptionally, or left\n unprocessed.\n", "method_declar": ""}, {"params": [{"param_name": ["tasks"], "param_type": "Collection", "param_description": " the collection of tasks"}], "class_name": "ForkJoinTask", "is_static": true, "return_value": {"return_name": [], "return_description": ["the tasks argument, to simplify usage"], "return_type": ["Collection<T>"]}, "method_name": "invokeAll", "method_description": "Forks all tasks in the specified collection, returning when\n isDone holds for each task or an (unchecked) exception\n is encountered, in which case the exception is rethrown. If\n more than one task encounters an exception, then this method\n throws any one of these exceptions. If any task encounters an\n exception, others may be cancelled. However, the execution\n status of individual tasks is not guaranteed upon exceptional\n return. The status of each task may be obtained using getException() and related methods to check if they have been\n cancelled, completed normally or exceptionally, or left\n unprocessed.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if this task was cancelled before it completed"], "return_type": ["boolean"]}, "method_name": "isCancelled", "method_description": "Returns true if this task was cancelled before it completed\n normally.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if this task threw an exception or was cancelled"], "return_type": ["boolean"]}, "method_name": "isCompletedAbnormally", "method_description": "Returns true if this task threw an exception or was cancelled.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if this task completed without throwing an\n exception and was not cancelled"], "return_type": ["boolean"]}, "method_name": "isCompletedNormally", "method_description": "Returns true if this task completed without throwing an\n exception and was not cancelled.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if this task completed"], "return_type": ["boolean"]}, "method_name": "isDone", "method_description": "Returns true if this task completed.\n\n Completion may be due to normal termination, an exception, or\n cancellation -- in all of these cases, this method will return\n true.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the computed result"], "return_type": ["V"]}, "method_name": "join", "method_description": "Returns the result of the computation when it is\n done.  This method differs from get() in that\n abnormal completion results in RuntimeException or\n Error, not ExecutionException, and that\n interrupts of the calling thread do not cause the\n method to abruptly return by throwing InterruptedException.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "quietlyComplete", "method_description": "Completes this task normally without setting a value. The most\n recent value established by setRawResult(V) (or null by default) will be returned as the result of subsequent\n invocations of join and related operations.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "quietlyInvoke", "method_description": "Commences performing this task and awaits its completion if\n necessary, without returning its result or throwing its\n exception.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "quietlyJoin", "method_description": "Joins this task, without returning its result or throwing its\n exception. This method may be useful when processing\n collections of tasks when some have been cancelled or otherwise\n known to have aborted.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "reinitialize", "method_description": "Resets the internal bookkeeping state of this task, allowing a\n subsequent fork. This method allows repeated reuse of\n this task, but only if reuse occurs when this task has either\n never been forked, or has been forked, then completed and all\n outstanding joins of this task have also completed. Effects\n under any other usage conditions are not guaranteed.\n This method may be useful when executing\n pre-constructed trees of subtasks in loops.\n\n \nUpon completion of this method, isDone() reports\n false, and getException() reports null. However, the value returned by getRawResult is\n unaffected. To clear this value, you can invoke setRawResult(null).\n", "method_declar": ""}, {"params": [{"param_name": ["newValue"], "param_type": "short", "param_description": " the new tag value"}], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["the previous value of the tag"], "return_type": ["short"]}, "method_name": "setForkJoinTaskTag", "method_description": "Atomically sets the tag value for this task and returns the old value.\n", "method_declar": ""}, {"params": [], "class_name": "ForkJoinTask", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if unforked"], "return_type": ["boolean"]}, "method_name": "tryUnfork", "method_description": "Tries to unschedule this task for execution. This method will\n typically (but is not guaranteed to) succeed if this task is\n the most recently forked task by the current thread, and has\n not commenced executing in another thread.  This method may be\n useful when arranging alternative local processing of tasks\n that could have been, but were not, stolen.\n", "method_declar": ""}], "class_name": "ForkJoinTask", "Vars": null}