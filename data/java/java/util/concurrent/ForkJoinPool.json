{"package_name": "java.util.concurrent", "subclass_list": [], "class_description": "An ExecutorService for running ForkJoinTasks.\n A ForkJoinPool provides the entry point for submissions\n from non-ForkJoinTask clients, as well as management and\n monitoring operations. A ForkJoinPool differs from other kinds of ExecutorService mainly by virtue of employing\n work-stealing: all threads in the pool attempt to find and\n execute tasks submitted to the pool and/or created by other active\n tasks (eventually blocking waiting for work if none exist). This\n enables efficient processing when most tasks spawn other subtasks\n (as do most ForkJoinTasks), as well as when many small\n tasks are submitted to the pool from external clients.  Especially\n when setting asyncMode to true in constructors, ForkJoinPools may also be appropriate for use with event-style\n tasks that are never joined. A static commonPool() is available and appropriate for\n most applications. The common pool is used by any ForkJoinTask that\n is not explicitly submitted to a specified pool. Using the common\n pool normally reduces resource usage (its threads are slowly\n reclaimed during periods of non-use, and reinstated upon subsequent\n use). For applications that require separate or custom pools, a ForkJoinPool may be constructed with a given target parallelism\n level; by default, equal to the number of available processors.\n The pool attempts to maintain enough active (or available) threads\n by dynamically adding, suspending, or resuming internal worker\n threads, even if some tasks are stalled waiting to join others.\n However, no such adjustments are guaranteed in the face of blocked\n I/O or other unmanaged synchronization. The nested ManagedBlocker interface enables extension of the kinds of\n synchronization accommodated. In addition to execution and lifecycle control methods, this\n class provides status check methods (for example\n getStealCount()) that are intended to aid in developing,\n tuning, and monitoring fork/join applications. Also, method\n toString() returns indications of pool state in a\n convenient form for informal monitoring. As is the case with other ExecutorServices, there are three\n main task execution methods summarized in the following table.\n These are designed to be used primarily by clients not already\n engaged in fork/join computations in the current pool.  The main\n forms of these methods accept instances of ForkJoinTask,\n but overloaded forms also allow mixed execution of plain Runnable- or Callable- based activities as well.  However,\n tasks that are already executing in a pool should normally instead\n use the within-computation forms listed in the table unless using\n async event-style tasks that are not usually joined, in which case\n there is little difference among choice of methods. The common pool is by default constructed with default\n parameters, but these may be controlled by setting three\n System#getProperty: Implementation notes: This implementation restricts the\n maximum number of running threads to 32767. Attempts to create\n pools with greater than the maximum number result in\n IllegalArgumentException. This implementation rejects submitted tasks (that is, by throwing\n RejectedExecutionException) only when the pool is shut down\n or internal resources have been exhausted. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["AbstractExecutorService"], "Methods": [], "class_name": "ForkJoinPool", "Vars": null}