{"package_name": "java.util.concurrent", "subclass_list": [], "class_description": "A hash table supporting full concurrency of retrievals and\n high expected concurrency for updates. This class obeys the\n same functional specification as Hashtable, and\n includes versions of methods corresponding to each method of\n Hashtable. However, even though all operations are\n thread-safe, retrieval operations do not entail locking,\n and there is not any support for locking the entire table\n in a way that prevents all access.  This class is fully\n interoperable with Hashtable in programs that rely on its\n thread safety but not on its synchronization details. Retrieval operations (including get) generally do not\n block, so may overlap with update operations (including put\n and remove). Retrievals reflect the results of the most\n recently completed update operations holding upon their\n onset. (More formally, an update operation for a given key bears a\n happens-before relation with any (non-null) retrieval for\n that key reporting the updated value.)  For aggregate operations\n such as putAll and clear, concurrent retrievals may\n reflect insertion or removal of only some entries.  Similarly,\n Iterators, Spliterators and Enumerations return elements reflecting the\n state of the hash table at some point at or since the creation of the\n iterator/enumeration.  They do not throw ConcurrentModificationException.\n However, iterators are designed to be used by only one thread at a time.\n Bear in mind that the results of aggregate status methods including\n size, isEmpty, and containsValue are typically\n useful only when a map is not undergoing concurrent updates in other threads.\n Otherwise the results of these methods reflect transient states\n that may be adequate for monitoring or estimation purposes, but not\n for program control. The table is dynamically expanded when there are too many\n collisions (i.e., keys that have distinct hash codes but fall into\n the same slot modulo the table size), with the expected average\n effect of maintaining roughly two bins per mapping (corresponding\n to a 0.75 load factor threshold for resizing). There may be much\n variance around this average as mappings are added and removed, but\n overall, this maintains a commonly accepted time/space tradeoff for\n hash tables.  However, resizing this or any other kind of hash\n table may be a relatively slow operation. When possible, it is a\n good idea to provide a size estimate as an optional initialCapacity constructor argument. An additional optional\n loadFactor constructor argument provides a further means of\n customizing initial table capacity by specifying the table density\n to be used in calculating the amount of space to allocate for the\n given number of elements.  Also, for compatibility with previous\n versions of this class, constructors may optionally specify an\n expected concurrencyLevel as an additional hint for\n internal sizing.  Note that using many keys with exactly the same\n hashCode() is a sure way to slow down performance of any\n hash table. To ameliorate impact, when keys are Comparable,\n this class may use comparison order among keys to help break ties. A Set projection of a ConcurrentHashMap may be created\n (using newKeySet() or newKeySet(int)), or viewed\n (using keySet(java.lang.Object) when only keys are of interest, and the\n mapped values are (perhaps transiently) not used or all take the\n same mapping value. A ConcurrentHashMap can be used as a scalable frequency map (a\n form of histogram or multiset) by using LongAdder values and initializing via\n computeIfAbsent. For example, to add a count\n to a ConcurrentHashMap<String,LongAdder> freqs, you can use\n freqs.computeIfAbsent(key, k -> new LongAdder()).increment(); This class and its views and iterators implement all of the\n optional methods of the Map and Iterator\n interfaces. Like Hashtable but unlike HashMap, this class\n does not allow null to be used as a key or value. ConcurrentHashMaps support a set of sequential and parallel bulk\n operations that, unlike most Stream methods, are designed\n to be safely, and often sensibly, applied even with maps that are\n being concurrently updated by other threads; for example, when\n computing a snapshot summary of the values in a shared registry.\n There are three kinds of operation, each with four forms, accepting\n functions with keys, values, entries, and (key, value) pairs as\n arguments and/or return values. Because the elements of a\n ConcurrentHashMap are not ordered in any particular way, and may be\n processed in different orders in different parallel executions, the\n correctness of supplied functions should not depend on any\n ordering, or on any other objects or values that may transiently\n change while computation is in progress; and except for forEach\n actions, should ideally be side-effect-free. Bulk operations on\n Map.Entry objects do not support method setValue. These bulk operations accept a parallelismThreshold\n argument. Methods proceed sequentially if the current map size is\n estimated to be less than the given threshold. Using a value of\n Long.MAX_VALUE suppresses all parallelism.  Using a value\n of 1 results in maximal parallelism by partitioning into\n enough subtasks to fully utilize the ForkJoinPool#commonPool() that is used for all parallel\n computations. Normally, you would initially choose one of these\n extreme values, and then measure performance of using in-between\n values that trade off overhead versus throughput. The concurrency properties of bulk operations follow\n from those of ConcurrentHashMap: Any non-null result returned\n from get(key) and related access methods bears a\n happens-before relation with the associated insertion or\n update.  The result of any bulk operation reflects the\n composition of these per-element relations (but is not\n necessarily atomic with respect to the map as a whole unless it\n is somehow known to be quiescent).  Conversely, because keys\n and values in the map are never null, null serves as a reliable\n atomic indicator of the current lack of any result.  To\n maintain this property, null serves as an implicit basis for\n all non-scalar reduction operations. For the double, long, and\n int versions, the basis should be one that, when combined with\n any other value, returns that other value (more formally, it\n should be the identity element for the reduction). Most common\n reductions have these properties; for example, computing a sum\n with basis 0 or a minimum with basis MAX_VALUE. Search and transformation functions provided as arguments\n should similarly return null to indicate the lack of any result\n (in which case it is not used). In the case of mapped\n reductions, this also enables transformations to serve as\n filters, returning null (or, in the case of primitive\n specializations, the identity basis) if the element should not\n be combined. You can create compound transformations and\n filterings by composing them yourself under this \"null means\n there is nothing there now\" rule before using them in search or\n reduce operations. Methods accepting and/or returning Entry arguments maintain\n key-value associations. They may be useful for example when\n finding the key for the greatest value. Note that \"plain\" Entry\n arguments can be supplied using new\n AbstractMap.SimpleEntry(k,v). Bulk operations may complete abruptly, throwing an\n exception encountered in the application of a supplied\n function. Bear in mind when handling such exceptions that other\n concurrently executing functions could also have thrown\n exceptions, or would have done so if the first exception had\n not occurred. Speedups for parallel compared to sequential forms are common\n but not guaranteed.  Parallel operations involving brief functions\n on small maps may execute more slowly than sequential forms if the\n underlying work to parallelize the computation is more expensive\n than the computation itself.  Similarly, parallelization may not\n lead to much actual parallelism if all processors are busy\n performing unrelated tasks. All arguments to all task methods must be non-null. ", "class_type": "class", "typealias": [], "interface_list": ["ConcurrentMap<K", "\u00a0V>", "Serializable"], "class_inherit_list": ["AbstractMap<K,\u00a0V>"], "Methods": [], "class_name": "ConcurrentHashMap", "Vars": null}