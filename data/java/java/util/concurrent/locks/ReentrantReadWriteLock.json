{"package_name": "java.util.concurrent.locks", "subclass_list": [], "class_description": "An implementation of ReadWriteLock supporting similar\n semantics to ReentrantLock. This class has the following properties: Serialization of this class behaves in the same way as built-in\n locks: a deserialized lock is in the unlocked state, regardless of\n its state when serialized. Sample usages. Here is a code sketch showing how to perform\n lock downgrading after updating a cache (exception handling is\n particularly tricky when handling multiple locks in a non-nested\n fashion): This lock supports a maximum of 65535 recursive write locks\n and 65535 read locks. Attempts to exceed these limits result in\n Error throws from locking methods. ", "class_type": "class", "typealias": [], "interface_list": ["ReadWriteLock", "Serializable"], "class_inherit_list": ["Object"], "Methods": [], "class_name": "ReentrantReadWriteLock", "Vars": null}