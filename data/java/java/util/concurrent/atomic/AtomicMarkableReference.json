{"package_name": "java.util.concurrent.atomic", "subclass_list": [], "class_description": "An AtomicMarkableReference maintains an object reference\n along with a mark bit, that can be updated atomically. Implementation note: This implementation maintains markable\n references by creating internal objects representing \"boxed\"\n [reference, boolean] pairs. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Object"], "Methods": [{"params": [{"param_name": ["initialRef"], "param_type": "V", "param_description": " the initial reference"}, {"param_name": ["initialMark"], "param_type": "boolean", "param_description": " the initial mark"}], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": "", "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Creates a new AtomicMarkableReference with the given\n initial values.\n", "method_declar": ""}, {"params": [{"param_name": ["expectedReference"], "param_type": "V", "param_description": " the expected value of the reference"}, {"param_name": ["newMark"], "param_type": "boolean", "param_description": " the new value for the mark"}], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if successful"], "return_type": ["boolean"]}, "method_name": "attemptMark", "method_description": "Atomically sets the value of the mark to the given update value\n if the current reference is == to the expected\n reference.  Any given invocation of this operation may fail\n (return false) spuriously, but repeated invocation\n when the current value holds the expected value and no other\n thread is also attempting to set the value will eventually\n succeed.\n", "method_declar": ""}, {"params": [{"param_name": ["expectedReference"], "param_type": "V", "param_description": " the expected value of the reference"}, {"param_name": ["newReference"], "param_type": "V", "param_description": " the new value for the reference"}, {"param_name": ["expectedMark"], "param_type": "boolean", "param_description": " the expected value of the mark"}, {"param_name": ["newMark"], "param_type": "boolean", "param_description": " the new value for the mark"}], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if successful"], "return_type": ["boolean"]}, "method_name": "compareAndSet", "method_description": "Atomically sets the value of both the reference and mark\n to the given update values if the\n current reference is == to the expected reference\n and the current mark is equal to the expected mark.\n", "method_declar": ""}, {"params": [{"param_name": ["markHolder"], "param_type": "boolean[]", "param_description": " an array of size of at least one. On return,\n markHolder[0] will hold the value of the mark."}], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": ["the current value of the reference"], "return_type": ["V"]}, "method_name": "get", "method_description": "Returns the current values of both the reference and the mark.\n Typical usage is boolean[1] holder; ref = v.get(holder); .\n", "method_declar": ""}, {"params": [], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": ["the current value of the reference"], "return_type": ["V"]}, "method_name": "getReference", "method_description": "Returns the current value of the reference.\n", "method_declar": ""}, {"params": [], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": ["the current value of the mark"], "return_type": ["boolean"]}, "method_name": "isMarked", "method_description": "Returns the current value of the mark.\n", "method_declar": ""}, {"params": [{"param_name": ["newReference"], "param_type": "V", "param_description": " the new value for the reference"}, {"param_name": ["newMark"], "param_type": "boolean", "param_description": " the new value for the mark"}], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": [""], "return_type": []}, "method_name": "set", "method_description": "Unconditionally sets the value of both the reference and mark.\n", "method_declar": ""}, {"params": [{"param_name": ["expectedReference"], "param_type": "V", "param_description": " the expected value of the reference"}, {"param_name": ["newReference"], "param_type": "V", "param_description": " the new value for the reference"}, {"param_name": ["expectedMark"], "param_type": "boolean", "param_description": " the expected value of the mark"}, {"param_name": ["newMark"], "param_type": "boolean", "param_description": " the new value for the mark"}], "class_name": "AtomicMarkableReference", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if successful"], "return_type": ["boolean"]}, "method_name": "weakCompareAndSet", "method_description": "Atomically sets the value of both the reference and mark\n to the given update values if the\n current reference is == to the expected reference\n and the current mark is equal to the expected mark.\n\n \nMay fail\n spuriously and does not provide ordering guarantees, so is\n only rarely an appropriate alternative to compareAndSet.\n", "method_declar": ""}], "class_name": "AtomicMarkableReference", "Vars": null}