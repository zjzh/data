{"package_name": "java.util.concurrent", "subclass_list": [], "class_description": "A ForkJoinTask with a completion action performed when\n triggered and there are no remaining pending actions.\n CountedCompleters are in general more robust in the\n presence of subtask stalls and blockage than are other forms of\n ForkJoinTasks, but are less intuitive to program.  Uses of\n CountedCompleter are similar to those of other completion based\n components (such as CompletionHandler)\n except that multiple pending completions may be necessary\n to trigger the completion action onCompletion(java.util.concurrent.CountedCompleter),\n not just one.\n Unless initialized otherwise, the pending\n count starts at zero, but may be (atomically) changed using\n methods setPendingCount(int), addToPendingCount(int), and\n compareAndSetPendingCount(int, int). Upon invocation of tryComplete(), if the pending action count is nonzero, it is\n decremented; otherwise, the completion action is performed, and if\n this completer itself has a completer, the process is continued\n with its completer.  As is the case with related synchronization\n components such as Phaser and\n Semaphore, these methods\n affect only internal counts; they do not establish any further\n internal bookkeeping. In particular, the identities of pending\n tasks are not maintained. As illustrated below, you can create\n subclasses that do record some or all pending tasks or their\n results when needed.  As illustrated below, utility methods\n supporting customization of completion traversals are also\n provided. However, because CountedCompleters provide only basic\n synchronization mechanisms, it may be useful to create further\n abstract subclasses that maintain linkages, fields, and additional\n support methods appropriate for a set of related usages. A concrete CountedCompleter class must define method compute(), that should in most cases (as illustrated below), invoke\n tryComplete() once before returning. The class may also\n optionally override method onCompletion(java.util.concurrent.CountedCompleter)\n to perform an action upon normal completion, and method\n onExceptionalCompletion(java.lang.Throwable, java.util.concurrent.CountedCompleter) to\n perform an action upon any exception. CountedCompleters most often do not bear results, in which case\n they are normally declared as CountedCompleter<Void>, and\n will always return null as a result value.  In other cases,\n you should override method getRawResult() to provide a\n result from join(), invoke(), and related methods.  In\n general, this method should return the value of a field (or a\n function of one or more fields) of the CountedCompleter object that\n holds the result upon completion. Method setRawResult(T) by\n default plays no role in CountedCompleters.  It is possible, but\n rarely applicable, to override this method to maintain other\n objects or fields holding result data. A CountedCompleter that does not itself have a completer (i.e.,\n one for which getCompleter() returns null) can be\n used as a regular ForkJoinTask with this added functionality.\n However, any completer that in turn has another completer serves\n only as an internal helper for other computations, so its own task\n status (as reported in methods such as ForkJoinTask#isDone)\n is arbitrary; this status changes only upon explicit invocations of\n complete(T), ForkJoinTask#cancel,\n ForkJoinTask#completeExceptionally(Throwable) or upon\n exceptional completion of method compute. Upon any\n exceptional completion, the exception may be relayed to a task's\n completer (and its completer, and so on), if one exists and it has\n not otherwise already completed. Similarly, cancelling an internal\n CountedCompleter has only a local effect on that completer, so is\n not often useful. Sample Usages. Parallel recursive decomposition. CountedCompleters may\n be arranged in trees similar to those often used with RecursiveActions, although the constructions involved in setting\n them up typically vary. Here, the completer of each task is its\n parent in the computation tree. Even though they entail a bit more\n bookkeeping, CountedCompleters may be better choices when applying\n a possibly time-consuming operation (that cannot be further\n subdivided) to each element of an array or collection; especially\n when the operation takes a significantly different amount of time\n to complete for some elements than others, either because of\n intrinsic variation (for example I/O) or auxiliary effects such as\n garbage collection.  Because CountedCompleters provide their own\n continuations, other threads need not block waiting to perform\n them. For example, here is an initial version of a class that uses\n divide-by-two recursive decomposition to divide work into single\n pieces (leaf tasks). Even when work is split into individual calls,\n tree-based techniques are usually preferable to directly forking\n leaf tasks, because they reduce inter-thread communication and\n improve load balancing. In the recursive case, the second of each\n pair of subtasks to finish triggers completion of its parent\n (because no result combination is performed, the default no-op\n implementation of method onCompletion is not overridden).\n A static utility method sets up the base task and invokes it\n (here, implicitly using the ForkJoinPool#commonPool()). Searching. A tree of CountedCompleters can search for a\n value or property in different parts of a data structure, and\n report a result in an AtomicReference as\n soon as one is found. The others can poll the result to avoid\n unnecessary work. (You could additionally cancel other tasks, but it is usually simpler and more efficient\n to just let them notice that the result is set and if so skip\n further processing.)  Illustrating again with an array using full\n partitioning (again, in practice, leaf tasks will almost always\n process more than one element): Recording subtasks. CountedCompleter tasks that combine\n results of multiple subtasks usually need to access these results\n in method onCompletion(java.util.concurrent.CountedCompleter). As illustrated in the following\n class (that performs a simplified form of map-reduce where mappings\n and reductions are all of type E), one way to do this in\n divide and conquer designs is to have each subtask record its\n sibling, so that it can be accessed in method onCompletion.\n This technique applies to reductions in which the order of\n combining left and right results does not matter; ordered\n reductions require explicit left/right designations.  Variants of\n other streamlinings seen in the above examples may also apply. Completion Traversals. If using onCompletion to\n process completions is inapplicable or inconvenient, you can use\n methods firstComplete() and nextComplete() to create\n custom traversals.  For example, to define a MapReducer that only\n splits out right-hand tasks in the form of the third ForEach\n example, the completions must cooperatively reduce along\n unexhausted subtask links, which can be done as follows: Triggers. Some CountedCompleters are themselves never\n forked, but instead serve as bits of plumbing in other designs;\n including those in which the completion of one or more async tasks\n triggers another async task. For example: ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["ForkJoinTask"], "Methods": [], "class_name": "CountedCompleter", "Vars": null}