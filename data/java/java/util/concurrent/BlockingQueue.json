{"package_name": "java.util.concurrent", "subclass_list": ["ArrayBlockingQueue", "BlockingDeque", "DelayQueue", "Delayed", "LinkedBlockingDeque", "LinkedBlockingQueue", "LinkedTransferQueue", "PriorityBlockingQueue", "SynchronousQueue", "TransferQueue", "ArrayBlockingQueue", "BlockingQueue", "BlockingDeque", "Deque", "DelayQueue", "Delayed", "BlockingQueue", "LinkedBlockingDeque", "BlockingDeque", "LinkedBlockingQueue", "BlockingQueue", "LinkedTransferQueue", "TransferQueue", "PriorityBlockingQueue", "BlockingQueue", "PriorityQueue", "SynchronousQueue", "BlockingQueue", "TransferQueue", "BlockingQueue"], "class_description": "A Queue that additionally supports operations\n that wait for the queue to become non-empty when retrieving an\n element, and wait for space to become available in the queue when\n storing an element. BlockingQueue methods come in four forms, with different ways\n of handling operations that cannot be satisfied immediately, but may be\n satisfied at some point in the future:\n one throws an exception, the second returns a special value (either\n null or false, depending on the operation), the third\n blocks the current thread indefinitely until the operation can succeed,\n and the fourth blocks for only a given maximum time limit before giving\n up.  These methods are summarized in the following table: A BlockingQueue does not accept null elements.\n Implementations throw NullPointerException on attempts\n to add, put or offer a null.  A\n null is used as a sentinel value to indicate failure of\n poll operations. A BlockingQueue may be capacity bounded. At any given\n time it may have a remainingCapacity beyond which no\n additional elements can be put without blocking.\n A BlockingQueue without any intrinsic capacity constraints always\n reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are designed to be used\n primarily for producer-consumer queues, but additionally support\n the Collection interface.  So, for example, it is\n possible to remove an arbitrary element from a queue using\n remove(x). However, such operations are in general\n not performed very efficiently, and are intended for only\n occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe.  All\n queuing methods achieve their effects atomically using internal\n locks or other forms of concurrency control. However, the\n bulk Collection operations addAll,\n containsAll, retainAll and removeAll are\n not necessarily performed atomically unless specified\n otherwise in an implementation. So it is possible, for example, for\n addAll(c) to fail (throwing an exception) after adding\n only some of the elements in c. A BlockingQueue does not intrinsically support\n any kind of \"close\" or \"shutdown\" operation to\n indicate that no more items will be added.  The needs and usage of\n such features tend to be implementation-dependent. For example, a\n common tactic is for producers to insert special\n end-of-stream or poison objects, that are\n interpreted accordingly when taken by consumers. Usage example, based on a typical producer-consumer scenario.\n Note that a BlockingQueue can safely be used with multiple\n producers and multiple consumers. Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n BlockingQueue\nhappen-before\n actions subsequent to the access or removal of that element from\n the BlockingQueue in another thread. ", "class_type": "interface", "typealias": [], "interface_list": ["Queue"], "class_inherit_list": [], "Methods": [], "class_name": "BlockingQueue", "Vars": null}