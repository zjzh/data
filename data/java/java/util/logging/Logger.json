{"package_name": "java.util.logging", "subclass_list": [], "class_description": "A Logger object is used to log messages for a specific\n system or application component.  Loggers are normally named,\n using a hierarchical dot-separated namespace.  Logger names\n can be arbitrary strings, but they should normally be based on\n the package name or class name of the logged component, such\n as java.net or javax.swing.  In addition it is possible to create\n \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger\n factory methods.  These will either create a new Logger or\n return a suitable existing Logger. It is important to note that\n the Logger returned by one of the getLogger factory methods\n may be garbage collected at any time if a strong reference to the\n Logger is not kept. Logging messages will be forwarded to registered Handler\n objects, which can forward the messages to a variety of\n destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its\n nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it.  This reflects\n a minimum Level that this logger cares about.  If a Logger's\n level is set to null, then its effective level is inherited\n from its parent, which may in turn obtain it recursively from its\n parent, and so on up the tree. The log level can be configured based on the properties from the\n logging configuration file, as described in the description\n of the LogManager class.  However it may also be dynamically changed\n by calls on the Logger.setLevel method.  If a logger's level is\n changed the change may also affect child loggers, since any child\n logger that has null as its level will inherit its\n effective level from its parent. On each logging call the Logger initially performs a cheap\n check of the request level (e.g., SEVERE or FINE) against the\n effective log level of the logger.  If the request level is\n lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate\n a LogRecord to describe the logging message.  It will then call a\n Filter (if present) to do a more detailed check on whether the\n record should be published.  If that passes it will then publish\n the LogRecord to its output Handlers.  By default, loggers also\n publish to their parent's Handlers, recursively up the tree. Each Logger may have a ResourceBundle associated with it.\n The ResourceBundle may be specified by name, using the\n getLogger(java.lang.String, java.lang.String) factory\n method, or by value - using the setResourceBundle method.\n This bundle will be used for localizing logging messages.\n If a Logger does not have its own ResourceBundle or resource bundle\n name, then it will inherit the ResourceBundle or resource bundle name\n from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument.  This\n msg argument may be either a raw value or a localization key.\n During formatting, if the logger has (or inherits) a localization\n ResourceBundle and if the ResourceBundle has a mapping for\n the msg string, then the msg string is replaced by the localized value.\n Otherwise the original msg string is used.  Typically, formatters use\n java.text.MessageFormat style formatting to format parameters, so\n for example a format string \"{0} {1}\" would format two parameters\n as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\"\n argument.  These methods take a Supplier<String> function\n which is invoked to construct the desired log message only when the message\n actually is to be logged based on the effective log level thus eliminating\n unnecessary message construction. For example, if the developer wants to\n log system health status for diagnosis, with the String-accepting version,\n the code would look like: When looking for a ResourceBundle, the logger will first look at\n whether a bundle was specified using setResourceBundle, and then\n only whether a resource bundle name was specified through the getLogger factory method.\n If no ResourceBundle or no resource bundle name is found,\n then it will use the nearest ResourceBundle or resource bundle\n name inherited from its parent tree.\n When a ResourceBundle was inherited or specified through the\n setResourceBundle method, then\n that ResourceBundle will be used. Otherwise if the logger only\n has or inherited a resource bundle name, then that resource bundle name\n will be mapped to a ResourceBundle object, using the default Locale\n at the time of logging.\n When mapping resource bundle names to\n ResourceBundle objects, the logger will first try to use the\n Thread's context class\n loader to map the given resource bundle name to a ResourceBundle.\n If the thread context class loader is null, it will try the\n system class loader\n instead.  If the ResourceBundle is still not found, it will use the\n class loader of the first caller of the getLogger factory method. Formatting (including localization) is the responsibility of\n the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously.  It may be delayed\n until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: For the methods that do not take an explicit source name and\n method name, the Logging framework will make a \"best effort\"\n to determine which class and method called into the logging method.\n However, it is important to realize that this automatically inferred\n information may only be approximate (or may even be quite wrong!).\n Virtual machines are allowed to do extensive optimizations when\n JITing and may entirely remove stack frames, making it impossible\n to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may\n provide its own implementation of named Loggers for any point in\n the namespace.  Therefore, any subclasses of Logger (unless they\n are implemented in conjunction with a new LogManager class) should\n take care to obtain a Logger instance from the LogManager class and\n should delegate operations such as \"isLoggable\" and \"log(LogRecord)\"\n to that instance.  Note that in order to intercept all logging\n output, subclasses need only override the log(LogRecord) method.\n All the other logging methods are implemented as calls on this\n log(LogRecord) method. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Object"], "Methods": [], "class_name": "Logger", "Vars": null}