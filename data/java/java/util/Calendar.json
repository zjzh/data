{"package_name": "java.util", "subclass_list": ["GregorianCalendar", "GregorianCalendar"], "class_description": "The Calendar class is an abstract class that provides methods\n for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH,\n DAY_OF_MONTH, HOUR, and so on, and for\n manipulating the calendar fields, such as getting the date of the next\n week. An instant in time can be represented by a millisecond value that is\n an offset from the Epoch, January 1, 1970\n 00:00:00.000 GMT (Gregorian). The class also provides additional fields and methods for\n implementing a concrete calendar system outside the package. Those\n fields and methods are defined as protected. Like other locale-sensitive classes, Calendar provides a\n class method, getInstance, for getting a generally useful\n object of this type. Calendar's getInstance method\n returns a Calendar object whose\n calendar fields have been initialized with the current date and time: A Calendar object can produce all the calendar field values\n needed to implement the date-time formatting for a particular language and\n calendar style (for example, Japanese-Gregorian, Japanese-Traditional).\n Calendar defines the range of values returned by\n certain calendar fields, as well as their meaning.  For example,\n the first month of the calendar system has value MONTH ==\n JANUARY for all calendars.  Other values are defined by the\n concrete subclass, such as ERA.  See individual field\n documentation and subclass documentation for details. The calendar field values can be set by calling the set\n methods. Any field values set in a Calendar will not be\n interpreted until it needs to calculate its time value (milliseconds from\n the Epoch) or values of the calendar fields. Calling the\n get, getTimeInMillis, getTime,\n add and roll involves such calculation. Calendar has two modes for interpreting the calendar\n fields, lenient and non-lenient.  When a\n Calendar is in lenient mode, it accepts a wider range of\n calendar field values than it produces.  When a Calendar\n recomputes calendar field values for return by get(), all of\n the calendar fields are normalized. For example, a lenient\n GregorianCalendar interprets MONTH == JANUARY,\n DAY_OF_MONTH == 32 as February 1. When a Calendar is in non-lenient mode, it throws an\n exception if there is any inconsistency in its calendar fields. For\n example, a GregorianCalendar always produces\n DAY_OF_MONTH values between 1 and the length of the month. A\n non-lenient GregorianCalendar throws an exception upon\n calculating its time or calendar field values if any out-of-range field\n value has been set. When setting or getting the WEEK_OF_MONTH or\n WEEK_OF_YEAR fields, Calendar must determine the\n first week of the month or year as a reference point.  The first week of a\n month or year is defined as the earliest seven day period beginning on\n getFirstDayOfWeek() and containing at least\n getMinimalDaysInFirstWeek() days of that month or year.  Weeks\n numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow\n it.  Note that the normalized numbering returned by get() may be\n different.  For example, a specific Calendar subclass may\n designate the week before week 1 of a year as week n of\n the previous year. If there is any conflict in calendar field values,\n Calendar gives priorities to calendar fields that have been set\n more recently. The following are the default combinations of the\n calendar fields. The most recent combination, as determined by the\n most recently set single field, will be used. For the date fields: If there are any calendar fields whose values haven't been set in the selected\n field combination, Calendar uses their default values. The default\n value of each field may vary by concrete calendar systems. For example, in\n GregorianCalendar, the default of a field is the same as that\n of the start of the Epoch: i.e., YEAR = 1970, MONTH =\n JANUARY, DAY_OF_MONTH = 1, etc. Note: There are certain possible ambiguities in\n interpretation of certain singular times, which are resolved in the\n following ways: The date or time format strings are not part of the definition of a\n calendar, as those must be modifiable or overridable by the user at\n runtime. Use DateFormat\n to format dates. set(f, value) changes calendar field\n f to value.  In addition, it sets an\n internal member variable to indicate that calendar field f has\n been changed. Although calendar field f is changed immediately,\n the calendar's time value in milliseconds is not recomputed until the next call to\n get(), getTime(), getTimeInMillis(),\n add(), or roll() is made. Thus, multiple calls to\n set() do not trigger multiple, unnecessary\n computations. As a result of changing a calendar field using\n set(), other calendar fields may also change, depending on the\n calendar field, the calendar field value, and the calendar system. In addition,\n get(f) will not necessarily return value set by\n the call to the set method\n after the calendar fields have been recomputed. The specifics are determined by\n the concrete calendar class. Example: Consider a GregorianCalendar\n originally set to August 31, 1999. Calling set(Calendar.MONTH,\n Calendar.SEPTEMBER) sets the date to September 31,\n 1999. This is a temporary internal representation that resolves to\n October 1, 1999 if getTime()is then called. However, a\n call to set(Calendar.DAY_OF_MONTH, 30) before the call to\n getTime() sets the date to September 30, 1999, since\n no recomputation occurs after set() itself. add(f, delta) adds delta\n to field f.  This is equivalent to calling set(f,\n get(f) + delta) with two adjustments: In addition, unlike set(), add() forces\n an immediate recomputation of the calendar's milliseconds and all\n fields. Example: Consider a GregorianCalendar\n originally set to August 31, 1999. Calling add(Calendar.MONTH,\n 13) sets the calendar to September 30, 2000. Add rule\n 1 sets the MONTH field to September, since\n adding 13 months to August gives September of the next year. Since\n DAY_OF_MONTH cannot be 31 in September in a\n GregorianCalendar, add rule 2 sets the\n DAY_OF_MONTH to 30, the closest possible value. Although\n it is a smaller field, DAY_OF_WEEK is not adjusted by\n rule 2, since it is expected to change when the month changes in a\n GregorianCalendar. roll(f, delta) adds\n delta to field f without changing larger\n fields. This is equivalent to calling add(f, delta) with\n the following adjustment: Example: See GregorianCalendar.roll(int, int). Usage model. To motivate the behavior of\n add() and roll(), consider a user interface\n component with increment and decrement buttons for the month, day, and\n year, and an underlying GregorianCalendar. If the\n interface reads January 31, 1999 and the user presses the month\n increment button, what should it read? If the underlying\n implementation uses set(), it might read March 3, 1999. A\n better result would be February 28, 1999. Furthermore, if the user\n presses the month increment button again, it should read March 31,\n 1999, not March 28, 1999. By saving the original date and using either\n add() or roll(), depending on whether larger\n fields should be affected, the user interface can behave as most users\n will intuitively expect. ", "class_type": "class", "typealias": [], "interface_list": ["Serializable", "Cloneable", "Comparable<Calendar>"], "class_inherit_list": ["Object"], "Methods": [], "class_name": "Calendar", "Vars": null}