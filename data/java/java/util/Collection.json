{"package_name": "java.util", "subclass_list": ["AbstractCollection", "AbstractList", "AbstractQueue", "AbstractSequentialList", "AbstractSet", "ArrayBlockingQueue", "ArrayDeque", "ArrayList", "ArraySet", "BlockingDeque", "BlockingQueue", "ConcurrentHashMap.KeySetView", "ConcurrentLinkedDeque", "ConcurrentLinkedQueue", "ConcurrentSkipListSet", "AbstractCollection", "AbstractList", "List", "AbstractQueue", "Queue", "AbstractSequentialList", "AbstractSet", "ArrayBlockingQueue", "BlockingQueue", "ArrayDeque", "Deque", "ArrayList", "ArraySet", "HashSet", "BlockingDeque", "Deque", "BlockingQueue", "Queue", "ConcurrentHashMap.KeySetView", "Set", "ConcurrentLinkedDeque", "Deque", "ConcurrentLinkedQueue", "Queue", "ConcurrentSkipListSet", "NavigableSet", "ConcurrentSkipListMap", "CopyOnWriteArrayList", "ArrayList", "CopyOnWriteArraySet", "Set", "CopyOnWriteArrayList", "DelayQueue", "Delayed", "BlockingQueue", "Deque", "EnumSet", "Enum", "Set", "HashSet", "LinkedBlockingDeque", "BlockingDeque", "LinkedBlockingQueue", "BlockingQueue", "LinkedHashSet", "LinkedList", "LinkedTransferQueue", "TransferQueue", "List", "NavigableSet", "SortedSet", "PriorityBlockingQueue", "BlockingQueue", "PriorityQueue", "PriorityQueue", "Queue", "Queue", "Set", "SortedSet", "Set", "Stack", "SynchronousQueue", "BlockingQueue", "TransferQueue", "BlockingQueue", "TreeSet", "NavigableSet", "TreeMap", "Vector"], "class_description": "The root interface in the collection hierarchy.  A collection\n represents a group of objects, known as its elements.  Some\n collections allow duplicate elements and others do not.  Some are ordered\n and others unordered.  The JDK does not provide any direct\n implementations of this interface: it provides implementations of more\n specific subinterfaces like Set and List.  This interface\n is typically used to pass collections around and manipulate them where\n maximum generality is desired. Bags or multisets (unordered collections that may contain\n duplicate elements) should implement this interface directly. All general-purpose Collection implementation classes (which\n typically implement Collection indirectly through one of its\n subinterfaces) should provide two \"standard\" constructors: a void (no\n arguments) constructor, which creates an empty collection, and a\n constructor with a single argument of type Collection, which\n creates a new collection with the same elements as its argument.  In\n effect, the latter constructor allows the user to copy any collection,\n producing an equivalent collection of the desired implementation type.\n There is no way to enforce this convention (as interfaces cannot contain\n constructors) but all of the general-purpose Collection\n implementations in the Java platform libraries comply. The \"destructive\" methods contained in this interface, that is, the\n methods that modify the collection on which they operate, are specified to\n throw UnsupportedOperationException if this collection does not\n support the operation.  If this is the case, these methods may, but are not\n required to, throw an UnsupportedOperationException if the\n invocation would have no effect on the collection.  For example, invoking\n the addAll(java.util.Collection) method on an unmodifiable collection may,\n but is not required to, throw the exception if the collection to be added\n is empty. Some collection implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the collection may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. It is up to each collection to determine its own synchronization\n policy.  In the absence of a stronger guarantee by the\n implementation, undefined behavior may result from the invocation\n of any method on a collection that is being mutated by another\n thread; this includes direct invocations, passing the collection to\n a method that might perform invocations, and using an existing\n iterator to examine the collection. Many methods in Collections Framework interfaces are defined in\n terms of the Object#equals(Object) method.  For example,\n the specification for the contains(Object o)\n method says: \"returns true if and only if this collection\n contains at least one element e such that\n (o==null ? e==null : o.equals(e)).\"  This specification should\n not be construed to imply that invoking Collection.contains\n with a non-null argument o will cause o.equals(e) to be\n invoked for any element e.  Implementations are free to implement\n optimizations whereby the equals invocation is avoided, for\n example, by first comparing the hash codes of the two elements.  (The\n Object#hashCode() specification guarantees that two objects with\n unequal hash codes cannot be equal.)  More generally, implementations of\n the various Collections Framework interfaces are free to take advantage of\n the specified behavior of underlying Object methods wherever the\n implementor deems it appropriate. Some collection operations which perform recursive traversal of the\n collection may fail with an exception for self-referential instances where\n the collection directly or indirectly contains itself. This includes the\n clone(), equals(), hashCode() and toString()\n methods. Implementations may optionally handle the self-referential scenario,\n however most current implementations do not do so. This interface is a member of the\n \n Java Collections Framework. ", "class_type": "interface", "typealias": [], "interface_list": ["Iterable"], "class_inherit_list": [], "Methods": [], "class_name": "Collection", "Vars": null}