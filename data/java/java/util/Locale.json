{"package_name": "java.util", "subclass_list": [], "class_description": "A Locale object represents a specific geographical, political,\n or cultural region. An operation that requires a Locale to perform\n its task is called locale-sensitive and uses the Locale\n to tailor information for the user. For example, displaying a number\n is a locale-sensitive operation\u2014 the number should be formatted\n according to the customs and conventions of the user's native country,\n region, or culture. The Locale class implements IETF BCP 47 which is composed of\n RFC 4647 \"Matching of Language\n Tags\" and RFC 5646 \"Tags\n for Identifying Languages\" with support for the LDML (UTS#35, \"Unicode\n Locale Data Markup Language\") BCP 47-compatible extensions for locale data\n exchange. A Locale object logically consists of the fields\n described below. UTS#35, \"Unicode Locale Data Markup Language\" defines optional\n attributes and keywords to override or refine the default behavior\n associated with a locale.  A keyword is represented by a pair of\n key and type.  For example, \"nu-thai\" indicates that Thai local\n digits (value:\"thai\") should be used for formatting numbers\n (key:\"nu\"). The keywords are mapped to a BCP 47 extension value using the\n extension key 'u' (UNICODE_LOCALE_EXTENSION).  The above\n example, \"nu-thai\", becomes the extension \"u-nu-thai\".code Thus, when a Locale object contains Unicode locale\n attributes and keywords,\n getExtension(UNICODE_LOCALE_EXTENSION) will return a\n String representing this information, for example, \"nu-thai\".  The\n Locale class also provides getUnicodeLocaleAttributes(), getUnicodeLocaleKeys(), and\n getUnicodeLocaleType(String) which allow you to access Unicode\n locale attributes and key/type pairs directly.  When represented as\n a string, the Unicode Locale Extension lists attributes\n alphabetically, followed by key/type sequences with keys listed\n alphabetically (the order of subtags comprising a key's type is\n fixed when the type is defined) A well-formed locale key has the form\n [0-9a-zA-Z]{2}.  A well-formed locale type has the\n form \"\" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})* (it\n can be empty, or a series of subtags 3-8 alphanums in length).  A\n well-formed locale attribute has the form\n [0-9a-zA-Z]{3,8} (it is a single subtag with the same\n form as a locale type subtag). The Unicode locale extension specifies optional behavior in\n locale-sensitive services.  Although the LDML specification defines\n various keys and values, actual locale-sensitive service\n implementations in a Java Runtime Environment might not support any\n particular Unicode locale attributes or key/type pairs. There are several different ways to create a Locale\n object. Using Builder you can construct a Locale object\n that conforms to BCP 47 syntax. The Locale class provides three constructors: The method forLanguageTag(String) creates a Locale\n object for a well-formed BCP 47 language tag. The Locale class provides a number of convenient constants\n that you can use to create Locale objects for commonly used\n locales. For example, the following creates a Locale object\n for the United States: If an application or a system is internationalized and provides localized\n resources for multiple locales, it sometimes needs to find one or more\n locales (or language tags) which meet each user's specific preferences. Note\n that a term \"language tag\" is used interchangeably with \"locale\" in this\n locale matching documentation. In order to do matching a user's preferred locales to a set of language\n tags, RFC 4647 Matching of\n Language Tags defines two mechanisms: filtering and lookup.\n Filtering is used to get all matching locales, whereas\n lookup is to choose the best matching locale.\n Matching is done case-insensitively. These matching mechanisms are described\n in the following sections. A user's preference is called a Language Priority List and is\n expressed as a list of language ranges. There are syntactically two types of\n language ranges: basic and extended. See\n Locale.LanguageRange for details. The filtering operation returns all matching language tags. It is defined\n in RFC 4647 as follows:\n \"In filtering, each language range represents the least specific language\n tag (that is, the language tag with fewest number of subtags) that is an\n acceptable match. All of the language tags in the matching set of tags will\n have an equal or greater number of subtags than the language range. Every\n non-wildcard subtag in the language range will appear in every one of the\n matching language tags.\" There are two types of filtering: filtering for basic language ranges\n (called \"basic filtering\") and filtering for extended language ranges\n (called \"extended filtering\"). They may return different results by what\n kind of language ranges are included in the given Language Priority List.\n Locale.FilteringMode is a parameter to specify how filtering should\n be done. The lookup operation returns the best matching language tags. It is\n defined in RFC 4647 as follows:\n \"By contrast with filtering, each language range represents the most\n specific tag that is an acceptable match.  The first matching tag found,\n according to the user's priority, is considered the closest match and is the\n item returned.\" For example, if a Language Priority List consists of two language ranges,\n \"zh-Hant-TW\" and \"en-US\", in prioritized order, lookup\n method progressively searches the language tags below in order to find the\n best matching language tag. \"*\" is the special language range, and it is ignored in lookup. If multiple language tags match as a result of the subtag '*'\n included in a language range, the first matching language tag returned by\n an Iterator over a Collection of language tags is treated as\n the best matching one. Once you've created a Locale you can query it for information\n about itself. Use getCountry to get the country (or region)\n code and getLanguage to get the language code.\n You can use getDisplayCountry to get the\n name of the country suitable for displaying to the user. Similarly,\n you can use getDisplayLanguage to get the name of\n the language suitable for displaying to the user. Interestingly,\n the getDisplayXXX methods are themselves locale-sensitive\n and have two versions: one that uses the default\n Locale.Category#DISPLAY locale and one\n that uses the locale specified as an argument. The Java Platform provides a number of classes that perform locale-sensitive\n operations. For example, the NumberFormat class formats\n numbers, currency, and percentages in a locale-sensitive manner. Classes\n such as NumberFormat have several convenience methods\n for creating a default object of that type. For example, the\n NumberFormat class provides these three convenience methods\n for creating a default NumberFormat object: In order to maintain compatibility with existing usage, Locale's\n constructors retain their behavior prior to the Java Runtime\n Environment version 1.7.  The same is largely true for the\n toString method. Thus Locale objects can continue to\n be used as they were. In particular, clients who parse the output\n of toString into language, country, and variant fields can continue\n to do so (although this is strongly discouraged), although the\n variant field will have additional information in it if script or\n extensions are present. In addition, BCP 47 imposes syntax restrictions that are not\n imposed by Locale's constructors. This means that conversions\n between some Locales and BCP 47 language tags cannot be made without\n losing information. Thus toLanguageTag cannot\n represent the state of locales whose language, country, or variant\n do not conform to BCP 47. Because of these issues, it is recommended that clients migrate\n away from constructing non-conforming locales and use the\n forLanguageTag and Locale.Builder APIs instead.\n Clients desiring a string representation of the complete locale can\n then always rely on toLanguageTag for this purpose. For compatibility reasons, two\n non-conforming locales are treated as special cases.  These are\n ja_JP_JP and th_TH_TH. These are ill-formed\n in BCP 47 since the variants are too short. To ease migration to BCP 47,\n these are treated specially during construction.  These two cases (and only\n these) cause a constructor to generate an extension, all other values behave\n exactly as they did prior to Java 7. Java has used ja_JP_JP to represent Japanese as used in\n Japan together with the Japanese Imperial calendar. This is now\n representable using a Unicode locale extension, by specifying the\n Unicode locale key ca (for \"calendar\") and type\n japanese. When the Locale constructor is called with the\n arguments \"ja\", \"JP\", \"JP\", the extension \"u-ca-japanese\" is\n automatically added. Java has used th_TH_TH to represent Thai as used in\n Thailand together with Thai digits. This is also now representable using\n a Unicode locale extension, by specifying the Unicode locale key\n nu (for \"number\") and value thai. When the Locale\n constructor is called with the arguments \"th\", \"TH\", \"TH\", the\n extension \"u-nu-thai\" is automatically added. During serialization, writeObject writes all fields to the output\n stream, including extensions. During deserialization, readResolve adds extensions as described\n in Special Cases, only\n for the two cases th_TH_TH and ja_JP_JP. Locale's constructor has always converted three language codes to\n their earlier, obsoleted forms: he maps to iw,\n yi maps to ji, and id maps to\n in.  This continues to be the case, in order to not break\n backwards compatibility. The APIs added in 1.7 map between the old and new language codes,\n maintaining the old codes internal to Locale (so that\n getLanguage and toString reflect the old\n code), but using the new codes in the BCP 47 language tag APIs (so\n that toLanguageTag reflects the new one). This\n preserves the equivalence between Locales no matter which code or\n API is used to construct them. Java's default resource bundle\n lookup mechanism also implements this mapping, so that resources\n can be named using either convention, see ResourceBundle.Control. The Locale constructors have always specified that the language\n and the country param be two characters in length, although in\n practice they have accepted any length.  The specification has now\n been relaxed to allow language codes of two to eight characters and\n country (region) codes of two to three characters, and in\n particular, three-letter language codes and three-digit region\n codes as specified in the IANA Language Subtag Registry.  For\n compatibility, the implementation still does not impose a length\n constraint. Note that locale data comes solely from ICU. User-supplied locale service providers (using\n the java.text.spi or java.util.spi mechanisms) are not supported. Here are the versions of ICU (and the corresponding CLDR and Unicode versions) used in\n various Android releases: Note that there are many convenience methods that automatically use the default locale, but\n using them may lead to subtle bugs. The default locale is appropriate for tasks that involve presenting data to the user. In\n this case, you want to use the user's date/time formats, number\n formats, rules for conversion to lowercase, and so on. In this case, it's safe to use the\n convenience methods. The default locale is not appropriate for machine-readable output. The best choice\n there is usually Locale.US\u00a0\u2013 this locale is guaranteed to be available on all\n devices, and the fact that it has no surprising special cases and is frequently used (especially\n for computer-computer communication) means that it tends to be the most efficient choice too. A common mistake is to implicitly use the default locale when producing output meant to be\n machine-readable. This tends to work on the developer's test devices (especially because so many\n developers use en_US), but fails when run on a device whose user is in a more complex locale. For example, if you're formatting integers some locales will use non-ASCII decimal\n digits. As another example, if you're formatting floating-point numbers some locales will use\n ',' as the decimal point and '.' for digit grouping. That's correct for\n human-readable output, but likely to cause problems if presented to another\n computer (Double#parseDouble can't parse such a number, for example).\n You should also be wary of the String#toLowerCase and\n String#toUpperCase overloads that don't take a Locale: in Turkey, for example,\n the characters 'i' and 'I' won't be converted to 'I' and 'i'.\n This is the correct behavior for Turkish text (such as user input), but inappropriate for, say,\n HTTP headers. ", "class_type": "class", "typealias": [], "interface_list": ["Cloneable", "Serializable"], "class_inherit_list": ["Object"], "Methods": [], "class_name": "Locale", "Vars": null}