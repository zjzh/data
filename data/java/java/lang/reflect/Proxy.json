{"package_name": "java.lang.reflect", "subclass_list": [], "class_description": "Proxy provides static methods for creating dynamic proxy\n classes and instances, and it is also the superclass of all\n dynamic proxy classes created by those methods. To create a proxy for some interface Foo: A dynamic proxy class (simply referred to as a proxy\n class below) is a class that implements a list of interfaces\n specified at runtime when the class is created, with behavior as\n described below.\n\n A proxy interface is such an interface that is implemented\n by a proxy class.\n\n A proxy instance is an instance of a proxy class.\n\n Each proxy instance has an associated invocation handler\n object, which implements the interface InvocationHandler.\n A method invocation on a proxy instance through one of its proxy\n interfaces will be dispatched to the InvocationHandler#invoke method of the instance's invocation handler, passing the proxy\n instance, a java.lang.reflect.Method object identifying\n the method that was invoked, and an array of type Object\n containing the arguments.  The invocation handler processes the\n encoded method invocation as appropriate and the result that it\n returns will be returned as the result of the method invocation on\n the proxy instance. A proxy class has the following properties: A proxy instance has the following properties: When two or more interfaces of a proxy class contain a method with\n the same name and parameter signature, the order of the proxy class's\n interfaces becomes significant.  When such a duplicate method\n is invoked on a proxy instance, the Method object passed\n to the invocation handler will not necessarily be the one whose\n declaring class is assignable from the reference type of the interface\n that the proxy's method was invoked through.  This limitation exists\n because the corresponding method implementation in the generated proxy\n class cannot determine which interface it was invoked through.\n Therefore, when a duplicate method is invoked on a proxy instance,\n the Method object for the method in the foremost interface\n that contains the method (either directly or inherited through a\n superinterface) in the proxy class's list of interfaces is passed to\n the invocation handler's invoke method, regardless of the\n reference type through which the method invocation occurred. If a proxy interface contains a method with the same name and\n parameter signature as the hashCode, equals,\n or toString methods of java.lang.Object,\n when such a method is invoked on a proxy instance, the\n Method object passed to the invocation handler will have\n java.lang.Object as its declaring class.  In other words,\n the public, non-final methods of java.lang.Object\n logically precede all of the proxy interfaces for the determination of\n which Method object to pass to the invocation handler. Note also that when a duplicate method is dispatched to an\n invocation handler, the invoke method may only throw\n checked exception types that are assignable to one of the exception\n types in the throws clause of the method in all of\n the proxy interfaces that it can be invoked through.  If the\n invoke method throws a checked exception that is not\n assignable to any of the exception types declared by the method in one\n of the proxy interfaces that it can be invoked through, then an\n unchecked UndeclaredThrowableException will be thrown by\n the invocation on the proxy instance.  This restriction means that not\n all of the exception types returned by invoking\n getExceptionTypes on the Method object\n passed to the invoke method can necessarily be thrown\n successfully by the invoke method. ", "class_type": "class", "typealias": [], "interface_list": ["Serializable"], "class_inherit_list": ["Object"], "Methods": [], "class_name": "Proxy", "Vars": null}