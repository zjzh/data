{"package_name": "java.lang.reflect", "subclass_list": ["AccessibleObject", "Class", "Constructor", "Executable", "Field", "GenericDeclaration", "Method", "Package", "Parameter", "AccessibleObject", "Class", "Constructor", "Executable", "Method", "Constructor", "Field", "GenericDeclaration", "Method", "Package", "Parameter"], "class_description": "Represents an annotated element of the program currently running in this\n VM.  This interface allows annotations to be read reflectively.  All\n annotations returned by methods in this interface are immutable and\n serializable. The arrays returned by methods of this interface may be modified\n by callers without affecting the arrays returned to other callers. Android note: methods that return multiple annotations of different types such as\n getAnnotations() and getDeclaredAnnotations() can be affected\n by the explicit character-code ordering of annotations types specified by the DEX format.\n Annotations of different types on a single element are not guaranteed to be returned in the order\n they are declared in source. The getAnnotationsByType(java.lang.Class) and getDeclaredAnnotationsByType(java.lang.Class) methods support multiple\n annotations of the same type on an element. If the argument to\n either method is a repeatable annotation type (JLS 9.6), then the\n method will \"look through\" a container annotation (JLS 9.7), if\n present, and return any annotations inside the container. Container\n annotations may be generated at compile-time to wrap multiple\n annotations of the argument type. The terms directly present, indirectly present,\n present, and associated are used throughout this\n interface to describe precisely which annotations are returned by\n methods: The table below summarizes which kind of annotation presence\n different methods in this interface examine. For an invocation of get[Declared]AnnotationsByType( Class <\n T >), the order of annotations which are directly or indirectly\n present on an element E is computed as if indirectly present\n annotations on E are directly present on E in place\n of their container annotation, in the order in which they appear in\n the value element of the container annotation. There are several compatibility concerns to keep in mind if an\n annotation type T is originally not repeatable and\n later modified to be repeatable.\n\n The containing annotation type for T is TC. If an annotation returned by a method in this interface contains\n (directly or indirectly) a Class-valued member referring to\n a class that is not accessible in this VM, attempting to read the class\n by calling the relevant Class-returning method on the returned annotation\n will result in a TypeNotPresentException. Similarly, attempting to read an enum-valued member will result in\n a EnumConstantNotPresentException if the enum constant in the\n annotation is no longer present in the enum type. If an annotation type T is (meta-)annotated with an\n @Repeatable annotation whose value element indicates a type\n TC, but TC does not declare a value() method\n with a return type of T[], then an exception of type\n AnnotationFormatError is thrown. Finally, attempting to read a member whose definition has evolved\n incompatibly will result in a AnnotationTypeMismatchException or an\n IncompleteAnnotationException. ", "class_type": "interface", "typealias": [], "interface_list": [""], "class_inherit_list": [], "Methods": [], "class_name": "AnnotatedElement", "Vars": null}