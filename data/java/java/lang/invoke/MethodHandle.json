{"package_name": "java.lang.invoke", "subclass_list": [], "class_description": "A method handle is a typed, directly executable reference to an underlying method,\n constructor, field, or similar low-level operation, with optional\n transformations of arguments or return values.\n These transformations are quite general, and include such patterns as\n conversion,\n insertion,\n deletion,\n and substitution. Every method handle reports its type descriptor via the type accessor.\n This type descriptor is a MethodType object,\n whose structure is a series of classes, one of which is\n the return type of the method (or void.class if none). A method handle's type controls the types of invocations it accepts,\n and the kinds of transformations that apply to it. A method handle contains a pair of special invoker methods\n called invokeExact and invoke.\n Both invoker methods provide direct access to the method handle's\n underlying method, constructor, field, or other operation,\n as modified by transformations of arguments and return values.\n Both invokers accept calls which exactly match the method handle's own type.\n The plain, inexact invoker also accepts a range of other call types. Method handles are immutable and have no visible state.\n Of course, they can be bound to underlying methods or data which exhibit state.\n With respect to the Java Memory Model, any method handle will behave\n as if all of its (internal) fields are final variables.  This means that any method\n handle made visible to the application will always be fully formed.\n This is true even if the method handle is published through a shared\n variable in a data race. Method handles cannot be subclassed by the user.\n Implementations may (or may not) create internal subclasses of MethodHandle\n which may be visible via the Object.getClass\n operation.  The programmer should not draw conclusions about a method handle\n from its specific class, as the method handle class hierarchy (if any)\n may change from time to time or across implementations from different vendors. As is usual with virtual methods, source-level calls to invokeExact\n and invoke compile to an invokevirtual instruction.\n More unusually, the compiler must record the actual argument types,\n and may not perform method invocation conversions on the arguments.\n Instead, it must push them on the stack according to their own unconverted types.\n The method handle object itself is pushed on the stack before the arguments.\n The compiler then calls the method handle with a symbolic type descriptor which\n describes the argument and return types. To issue a complete symbolic type descriptor, the compiler must also determine\n the return type.  This is based on a cast on the method invocation expression,\n if there is one, or else Object if the invocation is an expression\n or else void if the invocation is a statement.\n The cast may be to a primitive type (but not void). As a corner case, an uncasted null argument is given\n a symbolic type descriptor of java.lang.Void.\n The ambiguity with the type Void is harmless, since there are no references of type\n Void except the null reference. When the invokevirtual is executed after linking,\n the receiving method handle's type is first checked by the JVM\n to ensure that it matches the symbolic type descriptor.\n If the type match fails, it means that the method which the\n caller is invoking is not present on the individual\n method handle being invoked. In the case of invokeExact, the type descriptor of the invocation\n (after resolving symbolic type names) must exactly match the method type\n of the receiving method handle.\n In the case of plain, inexact invoke, the resolved type descriptor\n must be a valid argument to the receiver's asType method.\n Thus, plain invoke is more permissive than invokeExact. After type matching, a call to invokeExact directly\n and immediately invoke the method handle's underlying method\n (or other behavior, as the case may be). A call to plain invoke works the same as a call to\n invokeExact, if the symbolic type descriptor specified by the caller\n exactly matches the method handle's own type.\n If there is a type mismatch, invoke attempts\n to adjust the type of the receiving method handle,\n as if by a call to asType,\n to obtain an exactly invokable method handle M2.\n This allows a more powerful negotiation of method type\n between caller and callee. (Note: The adjusted method handle M2 is not directly observable,\n and implementations are therefore not required to materialize it.) Thus, a method type mismatch which might show up as a linkage error\n in a statically typed program can show up as\n a dynamic WrongMethodTypeException\n in a program which uses method handles. Because method types contain \"live\" Class objects,\n method type matching takes into account both types names and class loaders.\n Thus, even if a method handle M is created in one\n class loader L1 and used in another L2,\n method handle calls are type-safe, because the caller's symbolic type\n descriptor, as resolved in L2,\n is matched against the original callee method's symbolic type descriptor,\n as resolved in L1.\n The resolution in L1 happens when M is created\n and its type is assigned, while the resolution in L2 happens\n when the invokevirtual instruction is linked. Apart from the checking of type descriptors,\n a method handle's capability to call its underlying method is unrestricted.\n If a method handle is formed on a non-public method by a class\n that has access to that method, the resulting handle can be used\n in any place by any caller who receives a reference to it. Unlike with the Core Reflection API, where access is checked every time\n a reflective method is invoked,\n method handle access checking is performed\n when the method handle is created.\n In the case of ldc (see below), access checking is performed as part of linking\n the constant pool entry underlying the constant method handle. Thus, handles to non-public methods, or to methods in non-public classes,\n should generally be kept secret.\n They should not be passed to untrusted code unless their use from\n the untrusted code would be harmless. Like classes and strings, method handles that correspond to accessible\n fields, methods, and constructors can also be represented directly\n in a class file's constant pool as constants to be loaded by ldc bytecodes.\n A new type of constant pool entry, CONSTANT_MethodHandle,\n refers directly to an associated CONSTANT_Methodref,\n CONSTANT_InterfaceMethodref, or CONSTANT_Fieldref\n constant pool entry.\n (For full details on method handle constants,\n see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.) Method handles produced by lookups or constant loads from methods or\n constructors with the variable arity modifier bit (0x0080)\n have a corresponding variable arity, as if they were defined with\n the help of asVarargsCollector. A method reference may refer either to a static or non-static method.\n In the non-static case, the method handle type includes an explicit\n receiver argument, prepended before any other arguments.\n In the method handle's type, the initial receiver argument is typed\n according to the class under which the method was initially requested.\n (E.g., if a non-static method handle is obtained via ldc,\n the type of the receiver is the class named in the constant pool entry.) Method handle constants are subject to the same link-time access checks\n their corresponding bytecode instructions, and the ldc instruction\n will throw corresponding linkage errors if the bytecode behaviors would\n throw such errors. As a corollary of this, access to protected members is restricted\n to receivers only of the accessing class, or one of its subclasses,\n and the accessing class must in turn be a subclass (or package sibling)\n of the protected member's defining class.\n If a method reference refers to a protected non-static method or field\n of a class outside the current package, the receiver argument will\n be narrowed to the type of the accessing class. When a method handle to a virtual method is invoked, the method is\n always looked up in the receiver (that is, the first argument). A non-virtual method handle to a specific virtual method implementation\n can also be created.  These do not perform virtual lookup based on\n receiver type.  Such a method handle simulates the effect of\n an invokespecial instruction to the same method. In source code, a call to a signature polymorphic method will\n compile, regardless of the requested symbolic type descriptor.\n As usual, the Java compiler emits an invokevirtual\n instruction with the given symbolic type descriptor against the named method.\n The unusual part is that the symbolic type descriptor is derived from\n the actual argument and return types, not from the method declaration. When the JVM processes bytecode containing signature polymorphic calls,\n it will successfully link any such call, regardless of its symbolic type descriptor.\n (In order to retain type safety, the JVM will guard such calls with suitable\n dynamic type checks, as described elsewhere.) Bytecode generators, including the compiler back end, are required to emit\n untransformed symbolic type descriptors for these methods.\n Tools which determine symbolic linkage are required to accept such\n untransformed descriptors, without reporting linkage errors. As a special case,\n when the Core Reflection API is used to view the signature polymorphic\n methods invokeExact or plain invoke in this class,\n they appear as ordinary non-polymorphic methods.\n Their reflective appearance, as viewed by\n Class.getDeclaredMethod,\n is unaffected by their special status in this API.\n For example, Method.getModifiers\n will report exactly those modifier bits required for any similarly\n declared method, including in this case native and varargs bits. As with any reflected method, these methods (when reflected) may be\n invoked via java.lang.reflect.Method.invoke.\n However, such reflective calls do not result in method handle invocations.\n Such a call, if passed the required argument\n (a single one, of type Object[]), will ignore the argument and\n will throw an UnsupportedOperationException. Since invokevirtual instructions can natively\n invoke method handles under any symbolic type descriptor, this reflective view conflicts\n with the normal presentation of these methods via bytecodes.\n Thus, these two native methods, when reflectively viewed by\n Class.getDeclaredMethod, may be regarded as placeholders only. In order to obtain an invoker method for a particular type descriptor,\n use MethodHandles.exactInvoker,\n or MethodHandles.invoker.\n The Lookup.findVirtual\n API is also able to return a method handle\n to call invokeExact or plain invoke,\n for any specified type descriptor . Method handles do not represent\n their function-like types in terms of Java parameterized (generic) types,\n because there are three mismatches between function-like types and parameterized\n Java types. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Object"], "Methods": [], "class_name": "MethodHandle", "Vars": null}