{"package_name": "java.lang", "subclass_list": [], "class_description": "The class Math contains methods for performing basic\n numeric operations such as the elementary exponential, logarithm,\n square root, and trigonometric functions. Unlike some of the numeric methods of class\n StrictMath, all implementations of the equivalent\n functions of class Math are not defined to return the\n bit-for-bit same results.  This relaxation permits\n better-performing implementations where strict reproducibility is\n not required. By default many of the Math methods simply call\n the equivalent method in StrictMath for their\n implementation.  Code generators are encouraged to use\n platform-specific native libraries or microprocessor instructions,\n where available, to provide higher-performance implementations of\n Math methods.  Such higher-performance\n implementations still must conform to the specification for\n Math. The quality of implementation specifications concern two\n properties, accuracy of the returned result and monotonicity of the\n method.  Accuracy of the floating-point Math methods is\n measured in terms of ulps, units in the last place.  For a\n given floating-point format, an ulp of a\n specific real number value is the distance between the two\n floating-point values bracketing that numerical value.  When\n discussing the accuracy of a method as a whole rather than at a\n specific argument, the number of ulps cited is for the worst-case\n error at any argument.  If a method always has an error less than\n 0.5 ulps, the method always returns the floating-point number\n nearest the exact result; such a method is correctly\n rounded.  A correctly rounded method is generally the best a\n floating-point approximation can be; however, it is impractical for\n many floating-point methods to be correctly rounded.  Instead, for\n the Math class, a larger error bound of 1 or 2 ulps is\n allowed for certain methods.  Informally, with a 1 ulp error bound,\n when the exact result is a representable number, the exact result\n should be returned as the computed result; otherwise, either of the\n two floating-point values which bracket the exact result may be\n returned.  For exact results large in magnitude, one of the\n endpoints of the bracket may be infinite.  Besides accuracy at\n individual arguments, maintaining proper relations between the\n method at different arguments is also important.  Therefore, most\n methods with more than 0.5 ulp errors are required to be\n semi-monotonic: whenever the mathematical function is\n non-decreasing, so is the floating-point approximation, likewise,\n whenever the mathematical function is non-increasing, so is the\n floating-point approximation.  Not all approximations that have 1\n ulp accuracy will automatically meet the monotonicity requirements. The platform uses signed two's complement integer arithmetic with\n int and long primitive types.  The developer should choose\n the primitive type to ensure that arithmetic operations consistently\n produce correct results, which in some cases means the operations\n will not overflow the range of values of the computation.\n The best practice is to choose the primitive type and algorithm to avoid\n overflow. In cases where the size is int or long and\n overflow errors need to be detected, the methods addExact,\n subtractExact, multiplyExact, and toIntExact\n throw an ArithmeticException when the results overflow.\n For other arithmetic operations such as divide, absolute value,\n increment, decrement, and negation overflow occurs only with\n a specific minimum or maximum value and should be checked against\n the minimum or maximum as appropriate. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Object"], "Methods": [], "class_name": "Math", "Vars": null}