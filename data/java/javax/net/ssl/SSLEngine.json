{"package_name": "javax.net.ssl", "subclass_list": [], "class_description": "A class which enables secure communications using protocols such as\n the Secure Sockets Layer (SSL) or\n  IETF RFC 2246 \"Transport\n Layer Security\" (TLS)  protocols, but is transport independent. The secure communications modes include: The cipher suite used is established by a negotiation process called\n \"handshaking\".  The goal of this process is to create or rejoin a\n \"session\", which may protect many connections over time.  After\n handshaking has completed, you can access session attributes by\n using the getSession() method. The SSLSocket class provides much of the same security\n functionality, but all of the inbound and outbound data is\n automatically transported using the underlying Socket, which by design uses a blocking model.\n While this is appropriate for many applications, this model does not\n provide the scalability required by large servers. The primary distinction of an SSLEngine is that it\n operates on inbound and outbound byte streams, independent of the\n transport mechanism.  It is the responsibility of the\n SSLEngine user to arrange for reliable I/O transport to\n the peer.  By separating the SSL/TLS abstraction from the I/O\n transport mechanism, the SSLEngine can be used for a\n wide variety of I/O types, such as non-blocking I/O (polling), selectable non-blocking I/O, Socket and the\n traditional Input/OutputStreams, local ByteBuffers or byte arrays,  future asynchronous\n I/O models , and so on. At a high level, the SSLEngine appears thus: (In the context of an SSLEngine, the term \"handshake\n data\" is taken to mean any data exchanged to establish and control a\n secure connection.  Handshake data includes the SSL/TLS messages\n \"alert\", \"change_cipher_spec,\" and \"handshake.\") There are five distinct phases to an SSLEngine. Data moves through the engine by calling wrap() or unwrap() on outbound or inbound data, respectively.  Depending on\n the state of the SSLEngine, a wrap() call\n may consume application data from the source buffer and may produce\n network data in the destination buffer.  The outbound data\n may contain application and/or handshake data.  A call to\n unwrap() will examine the source buffer and may\n advance the handshake if the data is handshaking information, or\n may place application data in the destination buffer if the data\n is application.  The state of the underlying SSL/TLS algorithm\n will determine when data is consumed and produced. Calls to wrap() and unwrap() return an\n SSLEngineResult which indicates the status of the\n operation, and (optionally) how to interact with the engine to make\n progress. The SSLEngine produces/consumes complete SSL/TLS\n packets only, and does not store application data internally between\n calls to wrap()/unwrap().  Thus input and output\n ByteBuffers must be sized appropriately to hold the\n maximum record that can be produced.  Calls to SSLSession#getPacketBufferSize() and SSLSession#getApplicationBufferSize() should be used to determine\n the appropriate buffer sizes.  The size of the outbound application\n data buffer generally does not matter.  If buffer conditions do not\n allow for the proper consumption/production of data, the application\n must determine (via SSLEngineResult) and correct the\n problem, and then try the call again. For example, unwrap() will return a SSLEngineResult.Status#BUFFER_OVERFLOW result if the engine\n determines that there is not enough destination buffer space available.\n Applications should call SSLSession#getApplicationBufferSize()\n and compare that value with the space available in the destination buffer,\n enlarging the buffer if necessary.  Similarly, if unwrap()\n were to return a SSLEngineResult.Status#BUFFER_UNDERFLOW, the\n application should call SSLSession#getPacketBufferSize() to ensure\n that the source buffer has enough room to hold a record (enlarging if\n necessary), and then obtain more inbound data. Unlike SSLSocket, all methods of SSLEngine are\n non-blocking.  SSLEngine implementations may\n require the results of tasks that may take an extended period of\n time to complete, or may even block.  For example, a TrustManager\n may need to connect to a remote certificate validation service,\n or a KeyManager might need to prompt a user to determine which\n certificate to use as part of client authentication.  Additionally,\n creating cryptographic signatures and verifying them can be slow,\n seemingly blocking. For any operation which may potentially block, the\n SSLEngine will create a Runnable\n delegated task.  When SSLEngineResult indicates that a\n delegated task result is needed, the application must call getDelegatedTask() to obtain an outstanding delegated task and\n call its run() method (possibly using\n a different thread depending on the compute strategy).  The\n application should continue obtaining delegated tasks until no more\n exist, and try the original operation again. At the end of a communication session, applications should properly\n close the SSL/TLS link.  The SSL/TLS protocols have closure handshake\n messages, and these messages should be communicated to the peer\n before releasing the SSLEngine and closing the\n underlying transport mechanism.  A close can be initiated by one of:\n an SSLException, an inbound closure handshake message, or one of the\n close methods.  In all cases, closure handshake messages are\n generated by the engine, and wrap() should be repeatedly\n called until the resulting SSLEngineResult's status\n returns \"CLOSED\", or isOutboundDone() returns true.  All\n data obtained from the wrap() method should be sent to the\n peer. closeOutbound() is used to signal the engine that the\n application will not be sending any more data. A peer will signal its intent to close by sending its own closure\n handshake message.  After this message has been received and\n processed by the local SSLEngine's unwrap()\n call, the application can detect the close by calling\n unwrap() and looking for a SSLEngineResult\n with status \"CLOSED\", or if isInboundDone() returns true.\n If for some reason the peer closes the communication link without\n sending the proper SSL/TLS closure message, the application can\n detect the end-of-stream and can signal the engine via closeInbound() that there will no more inbound messages to\n process.  Some applications might choose to require orderly shutdown\n messages from a peer, in which case they can check that the closure\n was generated by a handshake message and not by an end-of-stream\n condition. There are two groups of cipher suites which you will need to know\n about when managing cipher suites: Each SSL/TLS connection must have one client and one server, thus\n each endpoint must decide which role to assume.  This choice determines\n who begins the handshaking process as well as which type of messages\n should be sent by each party.  The method setUseClientMode(boolean) configures the mode.  Once the initial\n handshaking has started, an SSLEngine can not switch\n between client and server modes, even when performing renegotiations. Applications might choose to process delegated tasks in different\n threads.  When an SSLEngine\n is created, the current AccessControlContext\n is saved.  All future delegated tasks will be processed using this\n context:  that is, all access control decisions will be made using the\n context captured at engine creation. SSLEngine instances obtained from the default SSLContext are configured as\n follows:\n\n \n   tr.deprecated {\n     background-color: #ccc;\n     color: #999;\n     font-style: italic;\n   } NOTE: PSK cipher suites are enabled by default only if the SSLContext through\n which the engine was created has been initialized with a PSKKeyManager. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Object"], "Methods": [], "class_name": "SSLEngine", "Vars": null}