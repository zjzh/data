{"package_name": "javax.net.ssl", "subclass_list": [], "class_description": "This class extends Sockets and provides secure\n socket using protocols such as the \"Secure\n Sockets Layer\" (SSL) or IETF \"Transport Layer Security\" (TLS) protocols. Such sockets are normal stream sockets, but they\n add a layer of security protections over the underlying network transport\n protocol, such as TCP.  Those protections include: These kinds of protection are specified by a \"cipher suite\", which\n is a combination of cryptographic algorithms used by a given SSL connection.\n During the negotiation process, the two endpoints must agree on\n a ciphersuite that is available in both environments.\n If there is no such suite in common, no SSL connection can\n be established, and no data can be exchanged. The cipher suite used is established by a negotiation process\n called \"handshaking\".  The goal of this\n process is to create or rejoin a \"session\", which may protect many\n connections over time.  After handshaking has completed, you can access\n session attributes by using the getSession method.\n The initial handshake on this connection can be initiated in\n one of three ways: If handshaking fails for any reason, the SSLSocket\n is closed, and no further communications can be done. There are two groups of cipher suites which you will need to know\n about when managing cipher suites: Implementation defaults require that only cipher\n suites which authenticate servers and provide confidentiality\n be enabled by default.\n Only if both sides explicitly agree to unauthenticated and/or\n non-private (unencrypted) communications will such a ciphersuite be\n selected. When SSLSockets are first created, no handshaking\n is done so that applications may first set their communication\n preferences:  what cipher suites to use, whether the socket should be\n in client or server mode, etc.\n However, security is always provided by the time that application data\n is sent over the connection. You may register to receive event notification of handshake\n completion.  This involves\n the use of two additional classes.  HandshakeCompletedEvent\n objects are passed to HandshakeCompletedListener instances,\n which are registered by users of this API.\n\n SSLSockets are created by SSLSocketFactorys,\n or by accepting a connection from a\n SSLServerSocket. A SSL socket must choose to operate in the client or server mode.\n This will determine who begins the handshaking process, as well\n as which messages should be sent by each party.  Each\n connection must have one client and one server, or handshaking\n will not progress properly.  Once the initial handshaking has started, a\n socket can not switch between client and server modes, even when\n performing renegotiations. SSLSocket instances obtained from default SSLSocketFactory,\n SSLServerSocketFactory, and SSLContext are configured as follows:\n\n \n   tr.deprecated {\n     background-color: #ccc;\n     color: #999;\n     font-style: italic;\n   } Client socket: Server socket: Methods that operate with cipher suite names (for example,\n getSupportedCipherSuites,\n setEnabledCipherSuites) have used\n standard names for cipher suites since API Level 9, as listed in the table\n below. Prior to API Level 9, non-standard (OpenSSL) names had been used (see\n the table following this table). NOTE: PSK cipher suites are enabled by default only if the SSLContext through\n which the socket was created has been initialized with a PSKKeyManager. API Levels 1 to 8 use OpenSSL names for cipher suites. The table below\n lists these OpenSSL names and their corresponding standard names used in API\n Levels 9 and newer. ", "class_type": "class", "typealias": [], "interface_list": [""], "class_inherit_list": ["Socket"], "Methods": [], "class_name": "SSLSocket", "Vars": null}