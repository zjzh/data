{"class_description": "Collections that conform to MutableCollection gain the ability to change the value of their elements. This example shows how you can modify one of the names in an array of students.\nIn addition to changing the value of an individual element, you can also change the values of a slice of elements in a mutable collection. For example, you can sort part of a mutable collection by calling the mutable sort() method on a subscripted subsequence. Here\u2019s an example that sorts the first half of an array of integers:\nThe MutableCollection protocol allows changing the values of a collection\u2019s elements but not the length of the collection itself. For operations that require adding or removing elements, see the RangeReplaceableCollection protocol instead.\nTo add conformance to the MutableCollection protocol to your own custom collection, upgrade your type\u2019s subscript to support both read and write access.\nA value stored into a subscript of a MutableCollection instance must subsequently be accessible at that same position. That is, for a mutable collection instance a, index i, and value x, the two sets of assignments in the following code sample must be equivalent:\n", "Methods": [], "class_inherit_list": ["Collection"], "class_name": "MutableCollection", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": []}