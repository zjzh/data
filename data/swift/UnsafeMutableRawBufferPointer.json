{"Methods": [{"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "(UInt8) throws -> Bool", "param_name": ["predicate"]}], "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "is_static": false, "method_name": "allSatisfy", "method_declar": "func allSatisfy(_ predicate: (UInt8) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["UnsafeMutableBufferPointer<T>"], "return_description": ["A typed buffer of the newly bound memory. The memory in this region is bound to T, but has not been modified in any other way. The typed buffer references self.count / MemoryLayout<T>.stride instances of T."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The type T to bind the memory to.", "param_type": "T.Type", "param_name": ["to", "type"]}], "method_description": "Binds this buffer\u2019s memory to the specified type and returns a typed buffer of the bound memory.", "is_static": false, "method_name": "bindMemory", "method_declar": "@discardableResult func bindMemory<T>(to type: T.Type) -> UnsafeMutableBufferPointer<T>"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "(UInt8) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "compactMap", "method_declar": "func compactMap<ElementOfResult>(_ transform: (UInt8) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the element was found in the sequence; otherwise, false."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The element to find in the sequence.", "param_type": "UInt8", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "is_static": false, "method_name": "contains", "method_declar": "func contains(_ element: UInt8) -> Bool"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(UInt8) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "is_static": false, "method_name": "contains", "method_declar": "func contains(where predicate: (UInt8) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A collection of UInt8 elements. source.count must be less than or equal to this buffer\u2019s count.", "param_type": "Collection", "param_name": ["from", "source"]}], "method_description": "Copies from a collection of UInt8 into this buffer\u2019s memory.", "is_static": false, "method_name": "copyBytes", "method_declar": "func copyBytes<C>(from source: C) where C : Collection, C.Element == UInt8"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A buffer of raw bytes from which to copy. source.count must be less than or equal to this buffer\u2019s count.", "param_type": "UnsafeRawBufferPointer", "param_name": ["from", "source"]}], "method_description": "Copies the bytes from the given buffer to this buffer\u2019s memory.", "is_static": false, "method_name": "copyMemory", "method_declar": "func copyMemory(from source: UnsafeRawBufferPointer)"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Deallocates the memory block previously allocated at this buffer pointer\u2019s base address.", "is_static": false, "method_name": "deallocate", "method_declar": "func deallocate()"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The distance between start and end."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection.", "param_type": "Int", "param_name": ["from", "start"]}, {"param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_type": "Int", "param_name": ["to", "end"]}], "method_description": "Returns the distance between two indices.", "is_static": false, "method_name": "distance", "method_declar": "func distance(from start: Int, to end: Int) -> Int"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_type": "(UInt8) throws -> Bool", "param_name": ["while", "predicate"]}], "method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "is_static": false, "method_name": "drop", "method_declar": "func drop(while predicate: (UInt8) throws -> Bool) rethrows -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence starting after the specified number of elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_type": "Int = 1", "param_name": ["k"]}], "method_description": "Returns a subsequence containing all but the given number of initial elements.", "is_static": false, "method_name": "dropFirst", "method_declar": "func dropFirst(_ k: Int = 1) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence that leaves off k elements from the end."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_type": "Int", "param_name": ["k"]}], "method_description": "Returns a subsequence containing all but the specified number of final elements.", "is_static": false, "method_name": "dropLast", "method_declar": "func dropLast(_ k: Int) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain the same elements in the same order."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(UInt8, OtherSequence.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (UInt8, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["EnumeratedSequence<UnsafeMutableRawBufferPointer>"], "return_description": ["A sequence of pairs enumerating the sequence."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "is_static": false, "method_name": "enumerated", "method_declar": "func enumerated() -> EnumeratedSequence<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["[UInt8]"], "return_description": ["An array of the elements that isIncluded allowed."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_type": "(UInt8) throws -> Bool", "param_name": ["isIncluded"]}], "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "is_static": false, "method_name": "filter", "method_declar": "func filter(_ isIncluded: (UInt8) throws -> Bool) rethrows -> [UInt8]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "(UInt8) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "is_static": false, "method_name": "first", "method_declar": "func first(where predicate: (UInt8) throws -> Bool) rethrows -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The first index where element is found. If element is not found in the collection, returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "An element to search for in the collection.", "param_type": "UInt8", "param_name": ["of", "element"]}], "method_description": "Returns the first index where the specified value appears in the collection.", "is_static": false, "method_name": "firstIndex", "method_declar": "func firstIndex(of element: UInt8) -> Int?"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(UInt8) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "is_static": false, "method_name": "firstIndex", "method_declar": "func firstIndex(where predicate: (UInt8) throws -> Bool) rethrows -> Int?"}, {"return_value": {"return_name": [""], "return_type": ["Void rethrows"], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "(UInt8) throws -> Void", "param_name": ["body"]}], "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "is_static": false, "method_name": "forEach", "method_declar": "func forEach(_ body: (UInt8) throws -> Void) rethrows"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection.", "param_type": "inout Int", "param_name": ["i"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}], "method_description": "Offsets the given index by the specified distance.", "is_static": false, "method_name": "formIndex", "method_declar": "func formIndex(_ i: inout Int, offsetBy distance: Int)"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection.", "param_type": "inout Int", "param_name": ["i"]}, {"param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}, {"param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_type": "Int", "param_name": ["limitedBy", "limit"]}], "method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "is_static": false, "method_name": "formIndex", "method_declar": "func formIndex(_ i: inout Int, offsetBy distance: Int, limitedBy limit: Int) -> Bool"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection. i must be less than endIndex.", "param_type": "inout Int", "param_name": ["after", "i"]}], "method_description": "Replaces the given index with its successor.", "is_static": false, "method_name": "formIndex", "method_declar": "func formIndex(after i: inout Int)"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection. i must be greater than startIndex.", "param_type": "inout Int", "param_name": ["before", "i"]}], "method_description": "Replaces the given index with its predecessor.", "is_static": false, "method_name": "formIndex", "method_declar": "func formIndex(before i: inout Int)"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection.", "param_type": "Int", "param_name": ["i"]}, {"param_description": "The distance to offset i.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}], "method_description": "Returns an index that is the specified distance from the given index.", "is_static": false, "method_name": "index", "method_declar": "func index(_ i: Int, offsetBy distance: Int) -> Int"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the array.", "param_type": "Int", "param_name": ["i"]}, {"param_description": "The distance to offset i.", "param_type": "Int", "param_name": ["offsetBy", "distance"]}, {"param_description": "A valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.", "param_type": "Int", "param_name": ["limitedBy", "limit"]}], "method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "is_static": false, "method_name": "index", "method_declar": "func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The index value immediately after i."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection. i must be less than endIndex.", "param_type": "Int", "param_name": ["after", "i"]}], "method_description": "Returns the position immediately after the given index.", "is_static": false, "method_name": "index", "method_declar": "func index(after i: Int) -> Int"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The index value immediately before i."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A valid index of the collection. i must be greater than startIndex.", "param_type": "Int", "param_name": ["before", "i"]}], "method_description": "Returns the position immediately after the given index.", "is_static": false, "method_name": "index", "method_declar": "func index(before i: Int) -> Int"}, {"return_value": {"return_name": [["unwritten"], ["initialized"]], "return_type": ["S.Iterator", "UnsafeMutableBufferPointer<S.Element>"], "return_description": ["An iterator to any elements of source that didn\u2019t fit in the buffer, and a typed buffer of the written elements. The returned buffer references memory starting at the same base address as this buffer."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The type of the elements to bind the buffer\u2019s memory to.", "param_type": "Sequence.Element.Type", "param_name": ["as", "type"]}, {"param_description": "A sequence of elements with which to initialize the buffer.", "param_type": "Sequence) -> (unwritte", "param_name": ["from", "source"]}, {"param_description": "", "param_type": "Sequence.Iterator", "param_name": ["S)", "->", "(unwritten"]}, {"param_description": "", "param_type": "UnsafeMutableBufferPointer<S.Element>", "param_name": ["initialized"]}], "method_description": "Initializes the buffer\u2019s memory with the given elements, binding the initialized memory to the elements\u2019 type.", "is_static": false, "method_name": "initializeMemory", "method_declar": "func initializeMemory<S>(as type: S.Element.Type, from source: S) -> (unwritten: S.Iterator, initialized: UnsafeMutableBufferPointer<S.Element>) where S : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["UnsafeMutableBufferPointer<T>"], "return_description": ["A typed buffer of the memory referenced by this raw buffer. The typed buffer contains self.count / MemoryLayout<T>.stride instances of T."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The type to bind this buffer\u2019s memory to.", "param_type": "T.Type", "param_name": ["as", "type"]}, {"param_description": "The instance to copy into memory.", "param_type": "T", "param_name": ["repeating", "repeatedValue"]}], "method_description": "Initializes the memory referenced by this buffer with the given value, binds the memory to the value\u2019s type, and returns a typed buffer of the initialized memory.", "is_static": false, "method_name": "initializeMemory", "method_declar": "@discardableResult func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T) -> UnsafeMutableBufferPointer<T>"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "(UInt8) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns the last element of the sequence that satisfies the given predicate.", "is_static": false, "method_name": "last", "method_declar": "func last(where predicate: (UInt8) throws -> Bool) rethrows -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "An element to search for in the collection.", "param_type": "UInt8", "param_name": ["of", "element"]}], "method_description": "Returns the last index where the specified value appears in the collection.", "is_static": false, "method_name": "lastIndex", "method_declar": "func lastIndex(of element: UInt8) -> Int?"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(UInt8) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns the index of the last element in the collection that matches the given predicate.", "is_static": false, "method_name": "lastIndex", "method_declar": "func lastIndex(where predicate: (UInt8) throws -> Bool) rethrows -> Int?"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(UInt8, UInt8) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["T"], "return_description": ["A new instance of type T, copied from the buffer pointer\u2019s memory."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The offset, in bytes, into the buffer pointer\u2019s memory at which to begin reading data for the new instance. The buffer pointer plus offset must be properly aligned for accessing an instance of type T. The default is zero.", "param_type": "Int", "param_name": ["fromByteOffset", "offset"]}, {"param_description": "The type to use for the newly constructed instance. The memory must be initialized to a value of a type that is layout compatible with type.", "param_type": "T.Type", "param_name": ["as", "type"]}], "method_description": "Returns a new instance of the given type, read from the buffer pointer\u2019s raw memory at the specified byte offset.", "is_static": false, "method_name": "load", "method_declar": "func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T"}, {"return_value": {"return_name": [""], "return_type": ["UnsafeMutableRawBufferPointer.Iterator"], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns an iterator over the bytes of this sequence.", "is_static": false, "method_name": "makeIterator", "method_declar": "func makeIterator() -> UnsafeMutableRawBufferPointer.Iterator"}, {"return_value": {"return_name": [""], "return_type": ["[T]"], "return_description": ["An array containing the transformed elements of this sequence."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(UInt8) throws -> T", "param_name": ["transform"]}], "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "is_static": false, "method_name": "map", "method_declar": "func map<T>(_ transform: (UInt8) throws -> T) rethrows -> [T]"}, {"return_value": {"return_name": [""], "return_type": ["[T]"], "return_description": ["An array containing the transformed elements of this sequence."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(UInt8) throws -> T", "param_name": ["transform"]}], "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "is_static": false, "method_name": "map", "method_declar": "func map<T>(_ transform: (UInt8) throws -> T) rethrows -> [T]"}, {"return_value": {"return_name": [""], "return_type": ["UInt8"], "return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns the maximum element in the sequence.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max() -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["UInt8"], "return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(UInt8, UInt8) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["UInt8"], "return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns the minimum element in the sequence.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min() -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["UInt8"], "return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(UInt8, UInt8) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_type": "(UInt8) throws -> Bool", "param_name": ["by", "belongsInSecondPartition"]}], "method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "is_static": false, "method_name": "partition", "method_declar": "mutating func partition(by belongsInSecondPartition: (UInt8) throws -> Bool) rethrows -> Int"}, {"return_value": {"return_name": [""], "return_type": ["Int"], "return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_type": "(UInt8) throws -> Bool", "param_name": ["by", "belongsInSecondPartition"]}], "method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "is_static": false, "method_name": "partition", "method_declar": "mutating func partition(by belongsInSecondPartition: (UInt8) throws -> Bool) rethrows -> Int"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_type": "Int", "param_name": ["maxLength"]}], "method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "is_static": false, "method_name": "prefix", "method_declar": "func prefix(_ maxLength: Int) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence up to, and including, the end position."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "", "param_type": "Int", "param_name": ["through", "position"]}], "method_description": "Returns a subsequence from the start of the collection through the specified position.", "is_static": false, "method_name": "prefix", "method_declar": "func prefix(through position: Int) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence up to, but not including, the end position."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_type": "Int", "param_name": ["upTo", "end"]}], "method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "is_static": false, "method_name": "prefix", "method_declar": "func prefix(upTo end: Int) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_type": "(UInt8) throws -> Bool", "param_name": ["while", "predicate"]}], "method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "is_static": false, "method_name": "prefix", "method_declar": "func prefix(while predicate: (UInt8) throws -> Bool) rethrows -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["UInt8"], "return_description": ["A random element from the collection. If the collection is empty, the method returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns a random element of the collection.", "is_static": false, "method_name": "randomElement", "method_declar": "func randomElement() -> UInt8?"}, {"return_value": {"return_name": [""], "return_type": ["UInt8"], "return_description": ["A random element from the collection. If the collection is empty, the method returns nil."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The random number generator to use when choosing a random element.", "param_type": "inout T", "param_name": ["using", "generator"]}], "method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "is_static": false, "method_name": "randomElement", "method_declar": "func randomElement<T>(using generator: inout T) -> UInt8? where T : RandomNumberGenerator"}, {"return_value": {"return_name": [""], "return_type": ["Result"], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result, UInt8) throws -> Result", "param_name": ["nextPartialResult"]}], "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "is_static": false, "method_name": "reduce", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, UInt8) throws -> Result) rethrows -> Result"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Reverses the elements of the collection in place.", "is_static": false, "method_name": "reverse", "method_declar": "mutating func reverse()"}, {"return_value": {"return_name": [""], "return_type": ["ReversedCollection<UnsafeMutableRawBufferPointer>"], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns a view presenting the elements of the collection in reverse order.", "is_static": false, "method_name": "reversed", "method_declar": "func reversed() -> ReversedCollection<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Shuffles the collection in place.", "is_static": false, "method_name": "shuffle", "method_declar": "mutating func shuffle()"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The random number generator to use when shuffling the collection.", "param_type": "inout T", "param_name": ["using", "generator"]}], "method_description": "Shuffles the collection in place, using the given generator as a source for randomness.", "is_static": false, "method_name": "shuffle", "method_declar": "mutating func shuffle<T>(using generator: inout T) where T : RandomNumberGenerator"}, {"return_value": {"return_name": [""], "return_type": ["[UInt8]"], "return_description": ["A shuffled array of this sequence\u2019s elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns the elements of the sequence, shuffled.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled() -> [UInt8]"}, {"return_value": {"return_name": [""], "return_type": ["[UInt8]"], "return_description": ["An array of this sequence\u2019s elements in a shuffled order."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout T", "param_name": ["using", "generator"]}], "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled<T>(using generator: inout T) -> [UInt8] where T : RandomNumberGenerator"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Sorts the collection in place.", "is_static": false, "method_name": "sort", "method_declar": "mutating func sort()"}, {"return_value": {"return_name": [""], "return_type": ["Bool rethrows"], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.", "param_type": "(UInt8, UInt8) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Sorts the collection in place, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "sort", "method_declar": "mutating func sort(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows"}, {"return_value": {"return_name": [""], "return_type": ["[UInt8]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [], "method_description": "Returns the elements of the sequence, sorted.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted() -> [UInt8]"}, {"return_value": {"return_name": [""], "return_type": ["[UInt8]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(UInt8, UInt8) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> [UInt8]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["An array of subsequences, split from this collection\u2019s elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_type": "Int", "param_name": ["maxSplits"]}, {"param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_type": "Bool", "param_name": ["omittingEmptySubsequences"]}, {"param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_type": "(UInt8) throws -> Bool", "param_name": ["whereSeparator", "isSeparator"]}], "method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "is_static": false, "method_name": "split", "method_declar": "func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (UInt8) throws -> Bool) rethrows -> [Slice<UnsafeMutableRawBufferPointer>]"}, {"return_value": {"return_name": [""], "return_type": ["[Slice<UnsafeMutableRawBufferPointer>]"], "return_description": ["An array of subsequences, split from this collection\u2019s elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The element that should be split upon.", "param_type": "UInt8", "param_name": ["separator"]}, {"param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_type": "Int", "param_name": ["maxSplits"]}, {"param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.", "param_type": "Bool = true", "param_name": ["omittingEmptySubsequences"]}], "method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "is_static": false, "method_name": "split", "method_declar": "func split(separator: UInt8, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Slice<UnsafeMutableRawBufferPointer>]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(UInt8, PossiblePrefix.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (UInt8, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "", "param_type": "T", "param_name": ["of", "value"]}, {"param_description": "The offset in bytes into the buffer pointer\u2019s memory to begin reading data for the new instance. The buffer pointer plus offset must be properly aligned for accessing an instance of type T. The default is zero.", "param_type": "Int", "param_name": ["toByteOffset", "offset"]}, {"param_description": "", "param_type": "T.Type", "param_name": ["as"]}], "method_description": "Stores a value\u2019s bytes into the buffer pointer\u2019s raw memory at the specified byte offset.", "is_static": false, "method_name": "storeBytes", "method_declar": "func storeBytes<T>(of value: T, toByteOffset offset: Int = 0, as: T.Type)"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_type": "Int", "param_name": ["maxLength"]}], "method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "is_static": false, "method_name": "suffix", "method_declar": "func suffix(_ maxLength: Int) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [""], "return_type": ["Slice<UnsafeMutableRawBufferPointer>"], "return_description": ["A subsequence starting at the start position."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_type": "Int", "param_name": ["from", "start"]}], "method_description": "Returns a subsequence from the specified position to the end of the collection.", "is_static": false, "method_name": "suffix", "method_declar": "func suffix(from start: Int) -> Slice<UnsafeMutableRawBufferPointer>"}, {"return_value": {"return_name": [], "return_type": [], "return_description": []}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The index of the first byte to swap.", "param_type": "Int", "param_name": ["i"]}, {"param_description": "The index of the second byte to swap.", "param_type": "Int", "param_name": ["j"]}], "method_description": "Exchanges the byte values at the specified indices in this buffer\u2019s memory.", "is_static": false, "method_name": "swapAt", "method_declar": "func swapAt(_ i: Int, _ j: Int)"}, {"return_value": {"return_name": [""], "return_type": ["UnsafeMutableRawBufferPointer"], "return_description": ["A buffer pointer to a newly allocated region of memory aligned to alignment."]}, "class_name": "UnsafeMutableRawBufferPointer", "params": [{"param_description": "The number of bytes to allocate.", "param_type": "Int", "param_name": ["byteCount"]}, {"param_description": "The alignment of the new region of allocated memory, in bytes.", "param_type": "Int", "param_name": ["alignment"]}], "method_description": "Returns a newly allocated buffer with the given size, in bytes.", "is_static": true, "method_name": "allocate", "method_declar": "static func allocate(byteCount: Int, alignment: Int) -> UnsafeMutableRawBufferPointer"}], "Vars": [{"var_description": "A pointer to the first byte of the buffer.", "is_static": false, "var_name": "baseAddress", "var_type": "UnsafeMutableRawPointer"}, {"var_description": "The number of bytes in the buffer.", "is_static": false, "var_name": "count", "var_type": "Int"}, {"var_description": "The number of bytes in the buffer.", "is_static": false, "var_name": "count", "var_type": "Int"}, {"var_description": "A textual representation of the buffer, suitable for debugging.", "is_static": false, "var_name": "debugDescription", "var_type": "String"}, {"var_description": "The \u201cpast the end\u201d position\u2014that is, the position one greater than the last valid subscript argument.", "is_static": false, "var_name": "endIndex", "var_type": "UnsafeMutableRawBufferPointer.Index"}, {"var_description": "The first element of the collection.", "is_static": false, "var_name": "first", "var_type": "UInt8"}, {"var_description": "", "is_static": false, "var_name": "indices", "var_type": "UnsafeMutableRawBufferPointer.Indices"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "is_static": false, "var_name": "indices", "var_type": "Range<Int>"}, {"var_description": "A Boolean value indicating whether the collection is empty.", "is_static": false, "var_name": "isEmpty", "var_type": "Bool"}, {"var_description": "The last element of the collection.", "is_static": false, "var_name": "last", "var_type": "UInt8"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "is_static": false, "var_name": "lazy", "var_type": "LazySequence<UnsafeMutableRawBufferPointer>"}, {"var_description": "Always zero, which is the index of the first byte in a nonempty buffer.", "is_static": false, "var_name": "startIndex", "var_type": "UnsafeMutableRawBufferPointer.Index"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "is_static": false, "var_name": "underestimatedCount", "var_type": "Int"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "is_static": false, "var_name": "underestimatedCount", "var_type": "Int"}], "class_name": "UnsafeMutableRawBufferPointer", "interface_list": ["CustomDebugStringConvertible", "MutableCollection", "Sequence"], "class_description": "You can use an UnsafeMutableRawBufferPointer instance in low-level operations to eliminate uniqueness checks and release mode bounds checks. Bounds checks are always performed in debug mode.\nAn UnsafeMutableRawBufferPointer instance is a view of the raw bytes in a region of memory. Each byte in memory is viewed as a UInt8 value independent of the type of values held in that memory. Reading from and writing to memory through a raw buffer are untyped operations. Accessing this collection\u2019s bytes does not bind the underlying memory to UInt8.\nIn addition to its collection interface, an UnsafeMutableRawBufferPointer instance also supports the following methods provided by UnsafeMutableRawPointer, including bounds checks in debug mode:\nload(fromByteOffset:as:)\nstoreBytes(of:toByteOffset:as:)\ncopyMemory(from:)\nTo access the underlying memory through typed operations, the memory must be bound to a trivial type.\nNote\nA trivial type can be copied bit for bit with no indirection or reference-counting operations. Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enums. Copying memory that contains values of nontrivial types can only be done safely with a typed pointer. Copying bytes directly from nontrivial, in-memory values does not produce valid copies and can only be done by calling a C API, such as memmove().\nAn UnsafeMutableRawBufferPointer instance is a view into memory and does not own the memory that it references. Copying a variable or constant of type UnsafeMutableRawBufferPointer does not copy the underlying memory. However, initializing another collection with an UnsafeMutableRawBufferPointer instance copies bytes out of the referenced memory and into the new collection.\nThe following example uses someBytes, an UnsafeMutableRawBufferPointer instance, to demonstrate the difference between assigning a buffer pointer and using a buffer pointer as the source for another collection\u2019s elements. Here, the assignment to destBytes creates a new, nonowning buffer pointer covering the first n bytes of the memory that someBytes references\u2014nothing is copied:\nNext, the bytes referenced by destBytes are copied into byteArray, a new [UInt] array, and then the remainder of someBytes is appended to byteArray:\nAssigning into a ranged subscript of an UnsafeMutableRawBufferPointer instance copies bytes into the memory. The next n bytes of the memory that someBytes references are copied in this code:\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}