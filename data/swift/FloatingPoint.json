{"class_description": "Floating-point types are used to represent fractional numbers, like 5.5, 100.0, or 3.14159274. Each floating-point type has its own possible range and precision. The floating-point types in the standard library are Float, Double, and Float80 where available.\nCreate new instances of floating-point types using integer or floating-point literals. For example:\nThe FloatingPoint protocol declares common arithmetic operations, so you can write functions and algorithms that work on any floating-point type. The following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides. Because the hypotenuse(_:_:) function uses a generic parameter constrained to the FloatingPoint protocol, you can call it using any floating-point type.\nFloating-point values are represented as a sign and a magnitude, where the magnitude is calculated using the type\u2019s radix and the instance\u2019s significand and exponent. This magnitude calculation takes the following form for a floating-point value x of type F, where ** is exponentiation:\nHere\u2019s an example of the number -8.5 represented as an instance of the Double type, which defines a radix of 2.\nTypes that conform to the FloatingPoint protocol provide most basic (clause 5) operations of the IEEE 754 specification. The base, precision, and exponent range are not fixed in any way by this protocol, but it enforces the basic requirements of any IEEE 754 floating-point type.\nIn addition to representing specific numbers, floating-point types also have special values for working with overflow and nonnumeric results of calculation.\nAny value whose magnitude is so great that it would round to a value outside the range of representable numbers is rounded to infinity. For a type F, positive and negative infinity are represented as F.infinity and -F.infinity, respectively. Positive infinity compares greater than every finite value and negative infinity, while negative infinity compares less than every finite value and positive infinity. Infinite values with the same sign are equal to each other.\nOperations with infinite values follow real arithmetic as much as possible: Adding or subtracting a finite value, or multiplying or dividing infinity by a nonzero finite value, results in infinity.\nFloating-point types represent values that are neither finite numbers nor infinity as NaN, an abbreviation for \u201cnot a number.\u201d Comparing a NaN with any value, including another NaN, results in false.\nBecause testing whether one NaN is equal to another NaN results in false, use the isNaN property to test whether a value is NaN.\nNaN propagates through many arithmetic operations. When you are operating on many values, this behavior is valuable because operations on NaN simply forward the value and don\u2019t cause runtime errors. The following example shows how NaN values operate in different contexts.\nImagine you have a set of temperature data for which you need to report some general statistics: the total number of observations, the number of valid observations, and the average temperature. First, a set of observations in Celsius is parsed from strings to Double values:\nNote that some elements in the temperatureData array are not valid numbers. When these invalid strings are parsed by the Double failable initializer, the example uses the nil-coalescing operator (??) to provide NaN as a fallback value.\nNext, the observations in Celsius are converted to Fahrenheit:\nThe NaN values in the tempsCelsius array are propagated through the conversion and remain NaN in tempsFahrenheit.\nBecause calculating the average of the observations involves combining every value of the tempsFahrenheit array, any NaN values cause the result to also be NaN, as seen in this example:\nInstead, when you need an operation to have a specific numeric result, filter out any NaN values using the isNaN property.\nFinally, report the average temperature and observation counts:\n", "Methods": [], "class_inherit_list": ["Hashable", "SignedNumeric", "Strideable"], "class_name": "FloatingPoint", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["BinaryFloatingPoint"]}