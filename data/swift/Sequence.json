{"class_description": "A sequence is a list of values that you can step through one at a time. The most common way to iterate over the elements of a sequence is to use a for-in loop:\nWhile seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence. As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you\u2019ve found a match or reached the end of the sequence. This example checks to see whether a particular insect is in an array.\nThe Sequence protocol provides default implementations for many common operations that depend on sequential access to a sequence\u2019s values. For clearer, more concise code, the example above could use the array\u2019s contains(_:) method, which every sequence inherits from Sequence, instead of iterating manually:\nThe Sequence protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don\u2019t assume that multiple for-in loops on a sequence will either resume iteration or restart from the beginning:\nIn this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element. A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second for-in loop.\nTo establish that a type you\u2019ve created supports nondestructive iteration, add conformance to the Collection protocol.\nMaking your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.\nAlternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.\nHere\u2019s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.\nA sequence should provide its iterator in O(1). The Sequence protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(n) unless documented otherwise.\n", "Methods": [], "class_inherit_list": [], "class_name": "Sequence", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["Collection", "LazySequenceProtocol"]}