{"class_description": "The NSMutableArray class declares the programmatic interface to objects that manage a modifiable array of objects. This class adds insertion and deletion operations to the basic array-handling behavior inherited from NSArray.\nNSMutableArray is \u201ctoll-free bridged\u201d with its Core Foundation counterpart, CFMutableArray. See Toll-Free Bridging for more information.\nIn addition to the provided instance methods, such as replaceObject(at:with:), you can access NSArray values by their indexes using subscripting.\nThere is typically little reason to subclass NSMutableArray. The class does well what it is designed to do\u2014maintain a mutable, ordered collection of objects. But there are situations where a custom NSArray object might come in handy. Here are a few possibilities:\nChanging how NSMutableArray stores the elements of its collection. You might do this for performance reasons or for better compatibility with legacy code.\nAcquiring more information about what is happening to the collection (for example, statistics gathering).\nNSMutableArray defines five primitive methods:\ninsert(_:at:)\nremoveObject(at:)\nadd(_:)\nremoveLastObject()\nreplaceObject(at:with:)\nIn a subclass, you must override all these methods. You must also override the primitive methods of the NSArray class.\n", "Methods": [], "class_inherit_list": ["NSArray"], "class_name": "NSMutableArray", "typealias": [], "Vars": [], "class_type": "class", "interface_list": ["CustomReflectable", "CVarArg", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "Sequence"], "package_name": "foundation", "subclass_list": []}