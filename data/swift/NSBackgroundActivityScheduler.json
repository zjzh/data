{"package_name": "foundation", "subclass_list": [], "class_description": "Use an NSBackgroundActivityScheduler object to schedule an arbitrary maintenance or background task. It\u2019s similar to an Timer object, in that it lets you schedule a repeating or non-repeating task. However, NSBackgroundActivityScheduler gives the system flexibility to determine the most efficient time to execute based on energy usage, thermal conditions, and CPU use.\nFor example, use an NSBackgroundActivityScheduler object to schedule:\nAutomatic saves\nBackups\nData maintenance\nPeriodic content fetches\nInstallation of updates\nActivities occurring in intervals of 10 minutes or more\nAny other deferrable task\nFor information about performing non-deferrable tasks efficiently, see Specify Nondeferrable Background Activities in Energy Efficiency Guide for Mac Apps.\nNote\nThe NSBackgroundActivityScheduler class interfaces with the XPC Activity API. However, your app doesn\u2019t need to be an XPC service in order to use NSBackgroundActivityScheduler.\nTo initialize a scheduler, call init(identifier:) for NSBackgroundActivityScheduler, and pass it a unique identifier string in reverse DNS notation (nil and zero-length strings are not allowed) that remains constant across launches of your application. See Listing 1.\nCreating a scheduler\nNote\nThe system uses this unique identifier to track the number of times the activity has run and to improve the heuristics for deciding when to run it again in the future.\nConfigure the scheduler with any of the following scheduling properties:\nrepeats\u2014If set to true, the activity is rescheduled at the specified interval after finishing.\ninterval\u2014For repeating schedulers, the average interval between invocations of the activity. For nonrepeating schedulers, interval is the suggested interval of time between scheduling the activity and the invocation of the activity.\ntolerance\u2014The amount of time before or after the nominal fire date when the activity should be invoked. The nominal fire date is calculated by using the interval combined with the previous fire date or the time when the activity is started. These two properties create a window in time, during which the activity may be scheduled. The system will more aggressively schedule the activity as it nears the end of the grace period after the nominal fire date. The default value is half the interval.\nqualityOfService\u2014The default value is NSQualityOfServiceBackground. If you upgrade the quality of service above this level, the system schedules the activity more aggressively. The default value is the recommended value for most activities. For information on quality of service, see Prioritize Work at the Task Level in Energy Efficiency Guide for Mac Apps.\nListing 2, Listing 3, and Listing 4 demonstrate different scheduling scenarios.\nScheduling an activity to fire in the next 10 minutes\nScheduling an activity to fire between 15 and 45 minutes from now\nScheduling an activity to fire once each hour\nWhen you\u2019re ready to schedule the activity, call scheduleWithBlock: and provide a block of code to execute when the scheduler runs, as shown in Listing 5. The block will be called on a serial background queue appropriate for the level of quality of service specified. The system automatically uses the beginActivity(options:reason:) method (of ProcessInfo) while invoking the block, choosing appropriate options based on the specified quality of service.\nWhen your block is called, it\u2019s passed a completion handler as an argument. Configure the block to invoke this handler, passing it a result of type NSBackgroundActivityScheduler.Result to indicate whether the activity finished (NSBackgroundActivityScheduler.Result.finished) or should be deferred (NSBackgroundActivityScheduler.Result.deferred) and rescheduled for a later time. Failure to invoke the completion handler results in the activity not being rescheduled. For work that will be deferred and rescheduled, the block may optionally adjust scheduler properties, such as interval or tolerance, before calling the completion handler.\nScheduling background activity\nIt\u2019s conceivable that while a lengthy activity is running, conditions may change, resulting in the activity now requiring deferral. For example, perhaps the user has unplugged the Mac and it\u2019s now running on battery power. Your activity can call shouldDefer to determine whether this has occurred. A value of true indicates that the block should finish what it\u2019s currently doing and invoke its completion handler with a value of NSBackgroundActivityScheduler.Result.deferred. See Listing 6.\nDetecting deferred background activity\nCall invalidate() to stop scheduling an activity, as shown in Listing 7.\nStopping background activity\nNote\nWhen an activity is stopped, a block that\u2019s currently executing will still finish executing.\n", "class_type": "class", "typealias": ["typealias CompletionHandler = (NSBackgroundActivityScheduler.Result) -> Void"], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["NSObject"], "Methods": [{"params": [{"param_name": ["identifier"], "param_type": "String", "param_description": "A unique string, in reverse DNS notation, that identifies the activity. For example, com.example.MyApp.updatecheck. nil and zero-length strings are not allowed."}], "class_name": "NSBackgroundActivityScheduler", "is_static": false, "return_value": {"return_name": [], "return_description": ["A new background activity scheduler object of type NSBackgroundActivityScheduler."], "return_type": []}, "method_name": "init", "method_description": "Initializes a background activity scheduler object with a specified unique identifier.", "method_declar": "init(identifier: String)"}, {"params": [{"param_name": ["block"], "param_type": "@escaping (NSBackgroundActivityScheduler.CompletionHandler) -> Void", "param_description": "A block of code to execute when the scheduler runs. This block will be called on a serial background queue appropriate for the level of quality of service specified. See qualityOfService."}], "class_name": "NSBackgroundActivityScheduler", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "schedule", "method_description": "Begins scheduling the background activity.", "method_declar": "func schedule(_ block: @escaping (NSBackgroundActivityScheduler.CompletionHandler) -> Void)"}, {"params": [], "class_name": "NSBackgroundActivityScheduler", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "invalidate", "method_description": "Prevents the background activity from being scheduled again.", "method_declar": "func invalidate()"}], "class_name": "NSBackgroundActivityScheduler", "Vars": [{"var_description": "A unique reverse DNS notation string, such as com.example.MyApp.updatecheck, that identifies the activity.", "var_type": "String", "is_static": false, "var_name": "identifier"}, {"var_description": "A Boolean value indicating whether the activity should be rescheduled after it completes.", "var_type": "Bool", "is_static": false, "var_name": "repeats"}, {"var_description": "An integer providing a suggested interval between scheduling and invoking the activity.", "var_type": "TimeInterval", "is_static": false, "var_name": "interval"}, {"var_description": "A value of type NSQualityOfService, which controls how aggressively the system schedules the activity.", "var_type": "QualityOfService", "is_static": false, "var_name": "qualityOfService"}, {"var_description": "A Boolean value indicating whether your app should stop performing background activity and resume at a more optimal time.", "var_type": "Bool", "is_static": false, "var_name": "shouldDefer"}, {"var_description": "A value of type TimeInterval, which specifies a range of time during which the background activity may occur.", "var_type": "TimeInterval", "is_static": false, "var_name": "tolerance"}]}