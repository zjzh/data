{"package_name": "foundation", "subclass_list": [], "class_description": "Timers work in conjunction with run loops. Run loops maintain strong references to their timers, so you don\u2019t have to maintain your own strong reference to a timer after you have added it to a run loop. \nTo use a timer effectively, you should be aware of how run loops operate. See Threading Programming Guide for more information.\nA timer is not a real-time mechanism. If a timer\u2019s firing time occurs during a long run loop callout or while the run loop is in a mode that isn't monitoring the timer, the timer doesn't fire until the next time the run loop checks the timer. Therefore, the actual time at which a timer fires can be significantly later. See also Timer Tolerance.\nTimer is toll-free bridged with its Core Foundation counterpart, CFRunLoopTimer.  See Toll-Free Bridging for more information.\nYou specify whether a timer is repeating or nonrepeating at creation time. A nonrepeating timer fires once and then invalidates itself automatically, thereby preventing the timer from firing again. By contrast, a repeating timer fires and then reschedules itself on the same run loop.  A repeating timer always schedules itself based on the scheduled firing time, as opposed to the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5-second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so far that it passes one or more of the scheduled firing times, the timer is fired only once for that time period; the timer is then rescheduled, after firing, for the next scheduled firing time in the future.\nIn iOS\u00a07 and later and macOS\u00a010.9 and later, you can specify a tolerance for a timer (tolerance). This flexibility in when a timer fires improves the system's ability to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer doesn't fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of the tolerance property.\nAs the user of the timer, you can determine the appropriate tolerance for a timer. A general rule, set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance has significant positive impact on the power usage of your application. The system may enforce a maximum value for the tolerance.\nYou can register a timer in only one run loop at a time, although it can be added to multiple run loop modes within that run loop. There are three ways to create a timer:\nUse the scheduledTimer(timeInterval:invocation:repeats:) or scheduledTimer(timeInterval:target:selector:userInfo:repeats:) class method to create the timer and schedule it on the current run loop in the default mode.\nUse the init(timeInterval:invocation:repeats:) or init(timeInterval:target:selector:userInfo:repeats:) class method to create the timer object without scheduling it on a run loop. (After creating it, you must add the timer to a run loop manually by calling the add(_:forMode:) method of the corresponding RunLoop object.)\nAllocate the timer and initialize it using the init(fireAt:interval:target:selector:userInfo:repeats:) method. (After creating it, you must add the timer to a run loop manually by calling the add(_:forMode:) method of the corresponding RunLoop object.)\nOnce scheduled on a run loop, the timer fires at the specified interval until it is invalidated. A nonrepeating timer invalidates itself immediately after it fires. However, for a repeating timer, you must invalidate the timer object yourself by calling its invalidate() method. Calling this method requests the removal of the timer from the current run loop; as a result, you should always call the invalidate() method from the same thread on which the timer was installed. Invalidating the timer immediately disables it so that it no longer affects the run loop. The run loop then removes the timer (and the strong reference it had to the timer), either just before the invalidate() method returns or at some later point. Once invalidated, timer objects cannot be reused.\nAfter a repeating timer fires, it schedules the next firing for the nearest future date that is an integer multiple of the timer interval after the last scheduled fire date, within the specified tolerance. If the time taken to call out to perform a selector or invocation is longer than the specified interval, the timer schedules only the next firing; that is, the timer doesn't attempt to compensate for any missed firings that would have occurred while calling the specified selector or invocation.\nDo not subclass Timer.\n", "class_type": "class", "typealias": [], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["NSObject"], "Methods": [{"params": [{"param_name": ["withTimeInterval", "interval"], "param_type": "TimeInterval", "param_description": "The number of seconds between firings of the timer. If interval is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead."}, {"param_name": ["repeats"], "param_type": "Bool", "param_description": "If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires."}, {"param_name": ["block"], "param_type": "@escaping (Timer) -> Void", "param_description": "A block to be executed when the timer fires.The block takes a single NSTimer parameter and has no return value."}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSTimer object, configured according to the specified parameters."], "return_type": ["Time"]}, "method_name": "scheduledTimer", "method_description": "Creates a timer and schedules it on the current run loop in the default mode.", "method_declar": "class func scheduledTimer(withTimeInterval interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -> Void) -> Timer"}, {"params": [{"param_name": ["timeInterval", "ti"], "param_type": "TimeInterval", "param_description": "The number of seconds between firings of the timer. If ti is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead."}, {"param_name": ["target", "aTarget"], "param_type": "Any", "param_description": "The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated."}, {"param_name": ["selector", "aSelector"], "param_type": "Selector", "param_description": "The message to send to target when the timer fires.The selector should have the following signature: timerFireMethod: (including a colon to indicate that the method takes an argument). The timer passes itself as the argument, thus the method would adopt the following pattern:- (void)timerFireMethod:(NSTimer *)timer\n"}, {"param_name": ["userInfo"], "param_type": "Any", "param_description": "The user info for the timer. The timer maintains a strong reference to this object until it (the timer) is invalidated. This parameter may be nil."}, {"param_name": ["repeats", "yesOrNo"], "param_type": "Bool", "param_description": "If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires."}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSTimer object, configured according to the specified parameters."], "return_type": ["Time"]}, "method_name": "scheduledTimer", "method_description": "Creates a timer and schedules it on the current run loop in the default mode.", "method_declar": "class func scheduledTimer(timeInterval ti: TimeInterval, target aTarget: Any, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) -> Timer"}, {"params": [{"param_name": ["timeInterval", "ti"], "param_type": "TimeInterval", "param_description": "The number of seconds between firings of the timer. If ti is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead."}, {"param_name": ["invocation"], "param_type": "NSInvocation", "param_description": "The invocation to use when the timer fires. The invocation object maintains a strong reference to its arguments until the timer is invalidated."}, {"param_name": ["repeats", "yesOrNo"], "param_type": "Bool", "param_description": "If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires."}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSTimer object, configured according to the specified parameters."], "return_type": ["Time"]}, "method_name": "scheduledTimer", "method_description": "Creates a new timer and schedules it on the current run loop in the default mode.", "method_declar": "class func scheduledTimer(timeInterval ti: TimeInterval, invocation: NSInvocation, repeats yesOrNo: Bool) -> Timer"}, {"params": [{"param_name": ["timeInterval", "interval"], "param_type": "TimeInterval", "param_description": ""}, {"param_name": ["repeats"], "param_type": "Bool", "param_description": ""}, {"param_name": ["block"], "param_type": "@escaping (Timer) -> Void", "param_description": ""}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "init", "method_description": "Initializes a timer object with the specified time interval and block. ", "method_declar": "init(timeInterval interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -> Void)"}, {"params": [{"param_name": ["timeInterval", "ti"], "param_type": "TimeInterval", "param_description": "The number of seconds between firings of the timer. If ti is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead."}, {"param_name": ["target", "aTarget"], "param_type": "Any", "param_description": "The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated."}, {"param_name": ["selector", "aSelector"], "param_type": "Selector", "param_description": "The message to send to target when the timer fires.The selector should have the following signature: timerFireMethod: (including a colon to indicate that the method takes an argument). The timer passes itself as the argument, thus the method would adopt the following pattern:- (void)timerFireMethod:(NSTimer *)timer\n"}, {"param_name": ["userInfo"], "param_type": "Any", "param_description": "Custom user info for the timer.The timer maintains a strong reference to this object until it (the timer) is invalidated. This parameter may be nil."}, {"param_name": ["repeats", "yesOrNo"], "param_type": "Bool", "param_description": "If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires."}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [], "return_description": ["A new NSTimer object, configured according to the specified parameters."], "return_type": []}, "method_name": "init", "method_description": "Initializes a timer object with the specified object and selector.", "method_declar": "init(timeInterval ti: TimeInterval, target aTarget: Any, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool)"}, {"params": [{"param_name": ["timeInterval", "ti"], "param_type": "TimeInterval", "param_description": "The number of seconds between firings of the timer. If ti is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead"}, {"param_name": ["invocation"], "param_type": "NSInvocation", "param_description": "The invocation to use when the timer fires. The timer instructs the invocation object to maintain a strong reference to its arguments."}, {"param_name": ["repeats", "yesOrNo"], "param_type": "Bool", "param_description": "If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires."}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [], "return_description": ["A new NSTimer object, configured according to the specified parameters."], "return_type": []}, "method_name": "init", "method_description": "Initializes a timer object with the specified invocation object.", "method_declar": "init(timeInterval ti: TimeInterval, invocation: NSInvocation, repeats yesOrNo: Bool)"}, {"params": [{"param_name": ["fire", "date"], "param_type": "Date", "param_description": ""}, {"param_name": ["interval"], "param_type": "TimeInterval", "param_description": ""}, {"param_name": ["repeats"], "param_type": "Bool", "param_description": ""}, {"param_name": ["block"], "param_type": "@escaping (Timer) -> Void", "param_description": ""}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "init", "method_description": "Initializes a timer for the specified date and time interval with the specified block.  ", "method_declar": "convenience init(fire date: Date, interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -> Void)"}, {"params": [{"param_name": ["fireAt", "date"], "param_type": "Date", "param_description": "The time at which the timer should first fire."}, {"param_name": ["interval", "ti"], "param_type": "TimeInterval", "param_description": "For a repeating timer, this parameter contains the number of seconds between firings of the timer. If ti is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead."}, {"param_name": ["target", "t"], "param_type": "Any", "param_description": "The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated."}, {"param_name": ["selector", "s"], "param_type": "Selector", "param_description": ""}, {"param_name": ["userInfo", "ui"], "param_type": "Any", "param_description": "Custom user info for the timer. The timer maintains a strong reference to this object until it (the timer) is invalidated. This parameter may be nil."}, {"param_name": ["repeats", "rep"], "param_type": "Bool", "param_description": "If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires."}], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [], "return_description": ["The receiver, initialized such that, when added to a run loop, it will fire at date and then, if repeats is true, every ti after that."], "return_type": []}, "method_name": "init", "method_description": "Initializes a timer using the specified object and selector. ", "method_declar": "init(fireAt date: Date, interval ti: TimeInterval, target t: Any, selector s: Selector, userInfo ui: Any?, repeats rep: Bool)"}, {"params": [], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "fire", "method_description": "Causes the timer's message to be sent to its target.", "method_declar": "func fire()"}, {"params": [], "class_name": "Timer", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "invalidate", "method_description": "Stops the timer from ever firing again and requests its removal from its run loop.", "method_declar": "func invalidate()"}], "class_name": "Timer", "Vars": [{"var_description": "A Boolean value that indicates whether the timer is currently valid.", "var_type": "Bool", "is_static": false, "var_name": "isValid"}, {"var_description": "The date at which the timer will fire.", "var_type": "Date", "is_static": false, "var_name": "fireDate"}, {"var_description": "The timer\u2019s time interval, in seconds.", "var_type": "TimeInterval", "is_static": false, "var_name": "timeInterval"}, {"var_description": "The receiver's userInfo object.", "var_type": "Any", "is_static": false, "var_name": "userInfo"}, {"var_description": "The amount of time after the scheduled fire date that the timer may fire.", "var_type": "TimeInterval", "is_static": false, "var_name": "tolerance"}]}