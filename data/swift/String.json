{"class_description": "A string is a series of characters, such as \"Swift\", that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The String type bridges with the Objective-C class NSString and offers interoperability with C functions that works with strings.\nYou can create new strings using string literals or string interpolations. A string literal is a series of characters enclosed in quotes.\nString interpolations are string literals that evaluate any included expressions and convert the results to string form. String interpolations give you an easy way to build a string from multiple pieces. Wrap each expression in a string interpolation in parentheses, prefixed by a backslash.\nCombine strings using the concatenation operator (+).\nMultiline string literals are enclosed in three double quotation marks (\"\"\"), with each delimiter on its own line. Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter.\nStrings always have value semantics. Modifying a copy of a string leaves the original unaffected.\nComparing strings for equality using the equal-to operator (==) or a relational operator (like < or >=) is always performed using Unicode canonical representation. As a result, different representations of a string compare as being equal.\nThe Unicode scalar value \"\\u{301}\" modifies the preceding character to include an accent, so \"e\\u{301}\" has the same canonical representation as the single Unicode scalar value \"\u00e9\".\nBasic string operations are not sensitive to locale settings, ensuring that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in Dictionary instances and for other purposes.\nA string is a collection of extended grapheme clusters, which approximate human-readable characters. Many individual characters, such as \u201c\u00e9\u201d, \u201c\uae40\u201d, and \u201c\ud83c\uddee\ud83c\uddf3\u201d, can be made up of multiple Unicode scalar values. These scalar values are combined by Unicode\u2019s boundary algorithms into extended grapheme clusters, represented by the Swift Character type. Each element of a string is represented by a Character instance.\nFor example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point:\nThe firstName constant is an instance of the Substring type\u2014a type that represents substrings of a string while sharing the original string\u2019s storage. Substrings present the same interface as strings.\nIf you need to access the contents of a string as encoded in different Unicode encodings, use one of the string\u2019s unicodeScalars, utf16, or utf8 properties. Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode encoding.\nTo demonstrate the different views available for every string, the following examples use this String instance:\nThe cafe string is a collection of the nine characters that are visible when the string is displayed.\nA string\u2019s unicodeScalars property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode. Each scalar value is represented by a Unicode.Scalar instance and is equivalent to a UTF-32 code unit.\nThe unicodeScalars view\u2019s elements comprise each Unicode scalar value in the cafe string. In particular, because cafe was declared using the decomposed form of the \"\u00e9\" character, unicodeScalars contains the scalar values for both the letter \"e\" (101) and the accent character \"\u00b4\" (769).\nA string\u2019s utf16 property is a collection of UTF-16 code units, the 16-bit encoding form of the string\u2019s Unicode scalar values. Each code unit is stored as a UInt16 instance.\nThe elements of the utf16 view are the code units for the string when encoded in UTF-16. These elements match those accessed through indexed NSString APIs.\nA string\u2019s utf8 property is a collection of UTF-8 code units, the 8-bit encoding form of the string\u2019s Unicode scalar values. Each code unit is stored as a UInt8 instance.\nThe elements of the utf8 view are the code units for the string when encoded in UTF-8. This representation matches the one used when String instances are passed to C APIs.\nWhen you need to know the length of a string, you must first consider what you\u2019ll use the length for. Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding? A single string can have greatly differing lengths when measured by its different views.\nFor example, an ASCII character like the capital letter A is represented by a single element in each of its four views. The Unicode scalar value of A is 65, which is small enough to fit in a single code unit in both UTF-16 and UTF-8.\nOn the other hand, an emoji flag character is constructed from a pair of Unicode scalar values, like \"\\u{1F1F5}\" and \"\\u{1F1F7}\". Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit. As a result, each view of the string \"\ud83c\uddf5\ud83c\uddf7\" reports a different length.\nTo check whether a string is empty, use its isEmpty property instead of comparing the length of one of the views to 0. Unlike with isEmpty, calculating a view\u2019s count property requires iterating through the elements of the string.\nTo find individual elements of a string, use the appropriate view for your task. For example, to retrieve the first word of a longer string, you can search the string for a space and then create a new string from a prefix of the string up to that point.\nStrings and their views share indices, so you can access the UTF-8 view of the name string using the same firstSpace index.\nNote that an index into one view may not have an exact corresponding position in another view. For example, the flag string declared above comprises a single character, but is composed of eight code units when encoded as UTF-8. The following code creates constants for the first and second positions in the flag.utf8 view. Accessing the utf8 view with these indices yields the first and second code UTF-8 units.\nWhen used to access the elements of the flag string itself, however, the secondCodeUnit index does not correspond to the position of a specific character. Instead of only accessing the specific UTF-8 code unit, that index is treated as the position of the character at the index\u2019s encoded offset. In the case of secondCodeUnit, that character is still the flag itself.\nIf you need to validate that an index from one string\u2019s view corresponds with an exact position in another view, use the index\u2019s samePosition(in:) method or the init(_:within:) initializer.\nAlthough strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer. This buffer can then be shared by different copies of a string. A string\u2019s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer. Therefore, the first in any sequence of mutating operations may cost O(n) time and space.\nWhen a string\u2019s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage. String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations.\nAny String instance can be bridged to NSString using the type-cast operator (as), and any String instance that originates in Objective-C may use an NSString instance as its storage. Because any arbitrary subclass of NSString can become a String instance, there are no guarantees about representation or efficiency when a String instance is backed by NSString storage. Because NSString is immutable, it is just as though the storage was shared by a copy. The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(n) time and space, where n is the length of the string\u2019s encoded representation (or more, if the underlying NSString has unusual performance characteristics).\nFor more information about the Unicode terms used in this discussion, see the Unicode.org glossary. In particular, this discussion mentions extended grapheme clusters, Unicode scalar values, and canonical equivalence.\n", "Methods": [], "class_inherit_list": [], "class_name": "String", "typealias": [], "Vars": [], "class_type": "struct", "interface_list": ["CKRecordValueProtocol", "Comparable", "CustomDebugStringConvertible", "CustomPlaygroundQuickLookable", "CustomReflectable", "CustomStringConvertible", "CVarArg", "Equatable", "ExpressibleByStringLiteral", "Hashable", "RangeReplaceableCollection", "StringProtocol", "TextOutputStream", "TextOutputStreamable"], "package_name": "foundation", "subclass_list": []}