{"package_name": "foundation", "subclass_list": [], "class_description": "A file manager object lets you examine the contents of the file system and make changes to it. The FileManager class provides convenient access to a shared file manager object that is suitable for most types of file-related manipulations. A file manager object is typically your primary mode of interaction with the file system. You use it to locate, create, copy, and move files and directories. You also use it to get information about a file or directory or change some of its attributes.\nWhen specifying the location of files, you can use either NSURL or NSString objects. The use of the NSURL class is generally preferred for specifying file-system items because URLs can convert path information to a more efficient representation internally. You can also obtain a bookmark from an NSURL object, which is similar to an alias and offers a more sure way of locating the file or directory later.\nIf you are moving, copying, linking, or removing files or directories, you can use a delegate in conjunction with a file manager object to manage those operations. The delegate\u2019s role is to affirm the operation and to decide whether to proceed when errors occur. In macOS 10.7 and later, the delegate must conform to the FileManagerDelegate protocol.\nIn iOS 5.0 and later and in macOS 10.7 and later, FileManager includes methods for managing items stored in iCloud. Files and directories tagged for cloud storage are synced to iCloud so that they can be made available to the user\u2019s iOS devices and Macintosh computers. Changes to an item in one location are propagated to all other locations to ensure the items stay in sync.\nThe methods of the shared FileManager object can be called from multiple threads safely. However, if you use a delegate to receive notifications about the status of move, copy, remove, and link operations, you should create a unique instance of the file manager object, assign your delegate to that object, and use that file manager to initiate your operations.\n", "class_type": "class", "typealias": [], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_inherit_list": ["NSObject"], "Methods": [{"params": [{"param_name": ["authorization"], "param_type": "NSWorkspace.Authorization", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Initializes a file manager object that is authorized to perform privileged file system operations.", "method_declar": "convenience init(authorization: NSWorkspace.Authorization)"}, {"params": [], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The path to the current home directory.."], "return_type": ["Strin"]}, "method_name": "NSHomeDirectory", "method_description": "Returns the path to either the user\u2019s or application\u2019s home directory, depending on the platform.", "method_declar": "func NSHomeDirectory() -> String"}, {"params": [], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The logon name of the current user."], "return_type": ["Strin"]}, "method_name": "NSUserName", "method_description": "Returns the logon name of the current user.", "method_declar": "func NSUserName() -> String"}, {"params": [], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A string containing the full name of the current user. "], "return_type": ["Strin"]}, "method_name": "NSFullUserName", "method_description": "Returns a string containing the full name of the current user.", "method_declar": "func NSFullUserName() -> String"}, {"params": [{"param_name": ["forUser", "userName"], "param_type": "String", "param_description": "The username of the owner of the desired home directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A URL object containing the location of the specified user\u2019s home directory, or nil if no such user exists or the user\u2019s home directory is not available."], "return_type": ["UR"]}, "method_name": "homeDirectory", "method_description": "Returns the home directory for the specified user.", "method_declar": "func homeDirectory(forUser userName: String) -> URL?"}, {"params": [{"param_name": ["userName"], "param_type": "String", "param_description": "The name of a user."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The path to the home directory for the user specified by userName."], "return_type": ["Strin"]}, "method_name": "NSHomeDirectoryForUser", "method_description": "Returns the path to a given user\u2019s home directory.", "method_declar": "func NSHomeDirectoryForUser(_ userName: String?) -> String?"}, {"params": [], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A string containing the path of the temporary directory for the current user."], "return_type": ["Strin"]}, "method_name": "NSTemporaryDirectory", "method_description": "Returns the path of the temporary directory for the current user.", "method_declar": "func NSTemporaryDirectory() -> String"}, {"params": [{"param_name": ["for", "directory"], "param_type": "FileManager.SearchPathDirectory", "param_description": "The search path directory. The supported values are described in FileManager.SearchPathDirectory."}, {"param_name": ["in", "domain"], "param_type": "FileManager.SearchPathDomainMask", "param_description": "The file system domain to search. The value for this parameter is one of the constants described in FileManager.SearchPathDomainMask. You should specify only one domain for your search and you may not specify the allDomainsMask constant for this parameter."}, {"param_name": ["appropriateFor", "url"], "param_type": "URL", "param_description": "The file URL used to determine the location of the returned URL. Only the volume of this parameter is used.This parameter is ignored unless the directory parameter contains the value FileManager.SearchPathDirectory.itemReplacementDirectory and the domain parameter contains the value userDomainMask."}, {"param_name": ["create", "shouldCreate"], "param_type": "Bool", "param_description": "Whether to create the directory if it does not already exist.When creating a temporary directory, this parameter is ignored and the directory is always created."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The NSURL for the requested directory."], "return_type": ["UR"]}, "method_name": "url", "method_description": "Locates and optionally creates the specified common directory in a domain.", "method_declar": "func url(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, appropriateFor url: URL?, create shouldCreate: Bool) throws -> URL"}, {"params": [{"param_name": ["for", "directory"], "param_type": "FileManager.SearchPathDirectory", "param_description": "The search path directory. The supported values are described in FileManager.SearchPathDirectory."}, {"param_name": ["in", "domainMask"], "param_type": "FileManager.SearchPathDomainMask", "param_description": "The file system domain to search. The value for this parameter is one or more of the constants described in FileManager.SearchPathDomainMask. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSURL objects identifying the requested directories. The directories are ordered according to the order of the domain mask constants, with items in the user domain first and items in the system domain last. "], "return_type": ["[URL"]}, "method_name": "urls", "method_description": "Returns an array of URLs for the specified common directory in the requested domains.", "method_declar": "func urls(for directory: FileManager.SearchPathDirectory, in domainMask: FileManager.SearchPathDomainMask) -> [URL]"}, {"params": [{"param_name": ["directory"], "param_type": "FileManager.SearchPathDirectory", "param_description": ""}, {"param_name": ["domainMask"], "param_type": "FileManager.SearchPathDomainMask", "param_description": ""}, {"param_name": ["expandTilde"], "param_type": "Bool", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["[String"]}, "method_name": "NSSearchPathForDirectoriesInDomains", "method_description": "Creates a list of directory search paths.", "method_declar": "func NSSearchPathForDirectoriesInDomains(_ directory: FileManager.SearchPathDirectory, _ domainMask: FileManager.SearchPathDomainMask, _ expandTilde: Bool) -> [String]"}, {"params": [], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A string identifying the root directory of the user\u2019s system."], "return_type": ["Strin"]}, "method_name": "NSOpenStepRootDirectory", "method_description": "Returns the root directory of the user\u2019s system.", "method_declar": "func NSOpenStepRootDirectory() -> String"}, {"params": [{"param_name": ["forSecurityApplicationGroupIdentifier", "groupIdentifier"], "param_type": "String", "param_description": "A string that names the group whose shared directory you want to obtain. This input should exactly match one of the strings in the app's App Groups Entitlement. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A URL indicating the location of the group's shared directory in the file system. In iOS, the value is nil when the group identifier is invalid. In macOS, a URL of the expected form is always returned, even if the app group is invalid, so be sure to test that you can access the underlying directory before attempting to use it."], "return_type": ["UR"]}, "method_name": "containerURL", "method_description": "Returns the container directory associated with the specified security application group identifier.", "method_declar": "func containerURL(forSecurityApplicationGroupIdentifier groupIdentifier: String) -> URL?"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The URL for the directory whose contents you want to enumerate."}, {"param_name": ["includingPropertiesForKeys", "keys"], "param_type": "[URLResourceKey]", "param_description": "An array of keys that identify the file properties that you want pre-fetched for each item in the directory. For each returned URL, the specified properties are fetched and cached in the NSURL object. For a list of keys you can specify, see Common File System Resource Keys.If you want directory contents to have no pre-fetched file properties, pass an empty array to this parameter. If you want directory contents to have default set of pre-fetched file properties, pass nil to this parameter."}, {"param_name": ["options", "mask"], "param_type": "FileManager.DirectoryEnumerationOptions = []", "param_description": "Options for the enumeration. Because this method performs only shallow enumerations, options that prevent descending into subdirectories or packages are not allowed; the only supported option is skipsHiddenFiles."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSURL objects, each of which identifies a file, directory, or symbolic link contained in url. If the directory contains no entries, this method returns an empty array."], "return_type": ["[URL"]}, "method_name": "contentsOfDirectory", "method_description": "Performs a shallow search of the specified directory and returns URLs for the contained items. ", "method_declar": "func contentsOfDirectory(at url: URL, includingPropertiesForKeys keys: [URLResourceKey]?, options mask: FileManager.DirectoryEnumerationOptions = []) throws -> [URL]"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path to the directory whose contents you want to enumerate. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSString objects, each of which identifies a file, directory, or symbolic link contained in path. Returns an empty array if the directory exists but has no contents."], "return_type": ["[String"]}, "method_name": "contentsOfDirectory", "method_description": "Performs a shallow search of the specified directory and returns the paths of any contained items.", "method_declar": "func contentsOfDirectory(atPath path: String) throws -> [String]"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The location of the directory for which you want an enumeration. This URL must not be a symbolic link that points to the desired directory. You can use the resolvingSymlinksInPath method to resolve any symlinks in the URL. "}, {"param_name": ["includingPropertiesForKeys", "keys"], "param_type": "[URLResourceKey]", "param_description": "An array of keys that identify the properties that you want pre-fetched for each item in the enumeration. The values for these keys are cached in the corresponding NSURL objects. You may specify nil for this parameter. For a list of keys you can specify, see URLResourceKey. "}, {"param_name": ["options", "mask"], "param_type": "FileManager.DirectoryEnumerationOptions", "param_description": "Options for the enumeration. For a list of valid options, see FileManager.DirectoryEnumerationOptions."}, {"param_name": ["errorHandler", "handler"], "param_type": "((URL, Error) -> Bool) = nil", "param_description": "An optional error handler block for the file manager to call when an error occurs. The handler block should return true if you want the enumeration to continue or false if you want the enumeration to stop. The block takes the following parameters:  urlA URL that identifies the item for which the error occurred. errorAn NSError object that contains information about the error.If you specify nil for this parameter, the enumerator object continues to enumerate items as if you had specified a block that returned true."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An directory enumerator object that enumerates the contents of the directory at url. If url is a filename, the method returns an enumerator object that enumerates no files\u2014the first call to nextObject() returns nil. "], "return_type": ["FileManager.DirectoryEnumerato"]}, "method_name": "enumerator", "method_description": "Returns a directory enumerator object that can be used to perform a deep enumeration of the directory at the specified URL.", "method_declar": "@nonobjc func enumerator(at url: URL, includingPropertiesForKeys keys: [URLResourceKey]?, options mask: FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((URL, Error) -> Bool)? = nil) -> FileManager.DirectoryEnumerator?"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of the directory to enumerate."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSDirectoryEnumerator object that enumerates the contents of the directory at path."], "return_type": ["FileManager.DirectoryEnumerato"]}, "method_name": "enumerator", "method_description": "Returns a directory enumerator object that can be used to perform a deep enumeration of the directory at the specified path.", "method_declar": "func enumerator(atPath path: String) -> FileManager.DirectoryEnumerator?"}, {"params": [{"param_name": ["includingResourceValuesForKeys", "propertyKeys"], "param_type": "[URLResourceKey]", "param_description": "An array of keys that identify the file properties that you want pre-fetched for each volume. For each returned URL, the values for these keys are cached in the corresponding NSURL objects. You may specify nil for this parameter. For a list of keys you can specify, see Common File System Resource Keys. "}, {"param_name": ["options"], "param_type": "FileManager.VolumeEnumerationOptions = []", "param_description": "Option flags for the enumeration. For a list of possible values, see FileManager.VolumeEnumerationOptions."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSURL objects identifying the mounted volumes. "], "return_type": ["[URL"]}, "method_name": "mountedVolumeURLs", "method_description": "Returns an array of URLs that identify the mounted volumes available on the device.", "method_declar": "func mountedVolumeURLs(includingResourceValuesForKeys propertyKeys: [URLResourceKey]?, options: FileManager.VolumeEnumerationOptions = []) -> [URL]?"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of the directory to list."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of strings, each containing the path of an item in the directory specified by path."], "return_type": ["[String"]}, "method_name": "subpathsOfDirectory", "method_description": "Performs a deep enumeration of the specified directory and returns the paths of all of the contained subdirectories. ", "method_declar": "func subpathsOfDirectory(atPath path: String) throws -> [String]"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of the directory to list."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSString objects, each of which contains the path of an item in the directory specified by path. If path is a symbolic link, this method traverses the link. This method returns nil if it cannot retrieve the device of the linked-to file."], "return_type": ["[String"]}, "method_name": "subpaths", "method_description": "Returns an array of strings identifying the paths for all items in the specified directory. ", "method_declar": "func subpaths(atPath path: String) -> [String]?"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "A file URL that specifies the directory to create. If you want to specify a relative path, you must set the current working directory before creating the corresponding NSURL object. This parameter must not be nil. "}, {"param_name": ["withIntermediateDirectories", "createIntermediates"], "param_type": "Bool", "param_description": "If true, this method creates any nonexistent parent directories as part of creating the directory in url. If false, this method fails if any of the intermediate parent directories does not exist. "}, {"param_name": ["attributes"], "param_type": "[FileAttributeKey", "param_description": "The file attributes for the new directory. You can set the owner and group numbers, file permissions, and modification date. If you specify nil for this parameter, the directory is created according to the umask(2) macOS Developer Tools Manual Page of the process. The Supporting Types section lists the global constants used as keys in the attributes dictionary. Some of the keys, such as hfsCreatorCode and hfsTypeCode, do not apply to directories."}, {"param_name": ["[FileAttributeKey"], "param_type": "Any] = nil", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the directory was created, true if createIntermediates is set and the directory already exists, or false if an error occurred."], "return_type": []}, "method_name": "createDirectory", "method_description": "Creates a directory with the given attributes at the specified URL.", "method_declar": "func createDirectory(at url: URL, withIntermediateDirectories createIntermediates: Bool, attributes: [FileAttributeKey : Any]? = nil) throws"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A path string identifying the directory to create. You may specify a full path or a path that is relative to the current working directory. This parameter must not be nil."}, {"param_name": ["withIntermediateDirectories", "createIntermediates"], "param_type": "Bool", "param_description": "If true, this method creates any nonexistent parent directories as part of creating the directory in path. If false, this method fails if any of the intermediate parent directories does not exist. This method also fails if any of the intermediate path elements corresponds to a file and not a directory."}, {"param_name": ["attributes"], "param_type": "[FileAttributeKey", "param_description": "The file attributes for the new directory and any newly created intermediate directories. You can set the owner and group numbers, file permissions, and modification date. If you specify nil for this parameter or omit a particular value, one or more default values are used as described in the discussion. For a list of keys you can include in this dictionary, see Supporting Types. Some of the keys, such as hfsCreatorCode and hfsTypeCode, do not apply to directories."}, {"param_name": ["[FileAttributeKey"], "param_type": "Any] = nil", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the directory was created, true if createIntermediates is set and the directory already exists, or false if an error occurred."], "return_type": []}, "method_name": "createDirectory", "method_description": "Creates a directory with given attributes at the specified path.", "method_declar": "func createDirectory(atPath path: String, withIntermediateDirectories createIntermediates: Bool, attributes: [FileAttributeKey : Any]? = nil) throws"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path for the new file."}, {"param_name": ["contents", "data"], "param_type": "Data", "param_description": "A data object containing the contents of the new file."}, {"param_name": ["attributes", "attr"], "param_type": "[FileAttributeKey", "param_description": "A dictionary containing the attributes to associate with the new file. You can use these attributes to set the owner and group numbers, file permissions, and modification date. For a list of keys, see FileAttributeKey. If you specify nil for attributes, the file is created with a set of default attributes."}, {"param_name": ["[FileAttributeKey"], "param_type": "Any] = nil", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the operation was successful or if the item already exists, otherwise false."], "return_type": ["Boo"]}, "method_name": "createFile", "method_description": "Creates a file with the specified content and attributes at the given location.", "method_declar": "func createFile(atPath path: String, contents data: Data?, attributes attr: [FileAttributeKey : Any]? = nil) -> Bool"}, {"params": [{"param_name": ["at", "URL"], "param_type": "URL", "param_description": "A file URL specifying the file or directory to remove. If the URL specifies a directory, the contents of that directory are recursively removed. You may specify nil for this parameter."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item was removed successfully or if URL was nil. Returns false if an error occurred. If the delegate stops the operation for a file, this method returns true. However, if the delegate stops the operation for a directory, this method returns false.  "], "return_type": []}, "method_name": "removeItem", "method_description": "Removes the file or directory at the specified URL.", "method_declar": "func removeItem(at URL: URL) throws"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A path string indicating the file or directory to remove. If the path specifies a directory, the contents of that directory are recursively removed. You may specify nil for this parameter. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item was removed successfully or if path was nil. Returns false if an error occurred. If the delegate stops the operation for a file, this method returns true. However, if the delegate stops the operation for a directory, this method returns false. "], "return_type": []}, "method_name": "removeItem", "method_description": "Removes the file or directory at the specified path.", "method_declar": "func removeItem(atPath path: String) throws"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The item to move to the trash. "}, {"param_name": ["resultingItemURL", "outResultingURL"], "param_type": "AutoreleasingUnsafeMutablePointer<NSURL>", "param_description": "On input, a pointer to a URL object. On output, this pointer is set to the item\u2019s location in the trash. The actual name of the item may be changed when moving it to the trash, so use this URL to access it. You may specify nil for this parameter if you do not want the information."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item at url was successfully moved to the trash, or false if the item was not moved to the trash."], "return_type": []}, "method_name": "trashItem", "method_description": "Moves an item to the trash.", "method_declar": "func trashItem(at url: URL, resultingItemURL outResultingURL: AutoreleasingUnsafeMutablePointer<NSURL?>?) throws"}, {"params": [{"param_name": ["originalItemURL"], "param_type": "URL", "param_description": "The item containing the content you want to replace."}, {"param_name": ["withItemAt", "newItemURL"], "param_type": "URL", "param_description": "The item containing the new content for originalItemURL. It is recommended that you put this item in a temporary directory as provided by the OS. If a temporary directory is not available, put this item in a uniquely named directory that is in the same directory as the original item."}, {"param_name": ["backupItemName"], "param_type": "String", "param_description": "If provided, the name used to create a backup of the original item.The backup is placed in the same directory as the original item. If an error occurs during the creation of the backup item, the operation fails. If there is already an item with the same name as the backup item, that item will be removed.The backup item will be removed in the event of success unless the withoutDeletingBackupItem option is provided in options."}, {"param_name": ["options"], "param_type": "FileManager.ItemReplacementOptions = []", "param_description": "The options to use during the replacement. Typically, you pass usingNewMetadataOnly for this parameter, which uses only the metadata from the new item. You can also combine the options described in FileManager.ItemReplacementOptions using the C-bitwise OR operator."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The URL of the new item. If no new file system object is required, the URL object in this parameter may be the same passed to the originalItemURL parameter. However, if a new file system object is required, the URL object may be different. For example, replacing an RTF document with an RTFD document requires the creation of a new file."], "return_type": ["UR"]}, "method_name": "replaceItemAt", "method_description": "Replaces the contents of the item at the specified URL in a manner that ensures no data loss occurs.", "method_declar": "func replaceItemAt(_ originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> URL?"}, {"params": [{"param_name": ["at", "originalItemURL"], "param_type": "URL", "param_description": "The item containing the content you want to replace."}, {"param_name": ["withItemAt", "newItemURL"], "param_type": "URL", "param_description": "The item containing the new content for originalItemURL. It is recommended that you put this item in a temporary directory as provided by the OS. If a temporary directory is not available, put this item in a uniquely named directory that is in the same directory as the original item."}, {"param_name": ["backupItemName"], "param_type": "String", "param_description": "If provided, the name used to create a backup of the original item.The backup is placed in the same directory as the original item. If an error occurs during the creation of the backup item, the operation fails. If there is already an item with the same name as the backup item, that item will be removed.The backup item will be removed in the event of success unless the withoutDeletingBackupItem option is provided in options."}, {"param_name": ["options"], "param_type": "FileManager.ItemReplacementOptions", "param_description": "The options to use during the replacement. Typically, you pass usingNewMetadataOnly for this parameter, which uses only the metadata from the new item. You can also combine the options described in FileManager.ItemReplacementOptions using the C-bitwise OR operator."}, {"param_name": ["resultingItemURL", "resultingURL"], "param_type": "AutoreleasingUnsafeMutablePointer<NSURL>", "param_description": "On input, a pointer for a URL object. When the item is replaced, this pointer is set to the URL of the new item. If no new file system object is required, the URL object in this parameter may be the same passed to the originalItemURL parameter. However, if a new file system object is required, the URL object may be different. For example, replacing an RTF document with an RTFD document requires the creation of a new file."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the replacement was successful or false if an error occurred."], "return_type": []}, "method_name": "replaceItem", "method_description": "Replaces the contents of the item at the specified URL in a manner that ensures no data loss occurs.", "method_declar": "func replaceItem(at originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String?, options: FileManager.ItemReplacementOptions = [], resultingItemURL resultingURL: AutoreleasingUnsafeMutablePointer<NSURL?>?) throws"}, {"params": [{"param_name": ["at", "srcURL"], "param_type": "URL", "param_description": "The file URL that identifies the file you want to copy. The URL in this parameter must not be a file reference URL. This parameter must not be nil."}, {"param_name": ["to", "dstURL"], "param_type": "URL", "param_description": "The URL at which to place the copy of srcURL. The URL in this parameter must not be a file reference URL and must include the name of the file in its new location. This parameter must not be nil. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item was copied successfully or the file manager\u2019s delegate stopped the operation deliberately. Returns false if an error occurred. "], "return_type": []}, "method_name": "copyItem", "method_description": "Copies the file at the specified URL to a new location synchronously.", "method_declar": "func copyItem(at srcURL: URL, to dstURL: URL) throws"}, {"params": [{"param_name": ["atPath", "srcPath"], "param_type": "String", "param_description": "The path to the file or directory you want to move. This parameter must not be nil. "}, {"param_name": ["toPath", "dstPath"], "param_type": "String", "param_description": "The path at which to place the copy of srcPath. This path must include the name of the file or directory in its new location. This parameter must not be nil."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item was copied successfully or the file manager\u2019s delegate stopped the operation deliberately. Returns false if an error occurred. "], "return_type": []}, "method_name": "copyItem", "method_description": "Copies the item at the specified path to a new location synchronously.", "method_declar": "func copyItem(atPath srcPath: String, toPath dstPath: String) throws"}, {"params": [{"param_name": ["at", "srcURL"], "param_type": "URL", "param_description": "The file URL that identifies the file or directory you want to move. The URL in this parameter must not be a file reference URL. This parameter must not be nil."}, {"param_name": ["to", "dstURL"], "param_type": "URL", "param_description": "The new location for the item in srcURL. The URL in this parameter must not be a file reference URL and must include the name of the file or directory in its new location. This parameter must not be nil. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item was moved successfully or the file manager\u2019s delegate stopped the operation deliberately. Returns false if an error occurred. "], "return_type": []}, "method_name": "moveItem", "method_description": "Moves the file or directory at the specified URL to a new location synchronously.", "method_declar": "func moveItem(at srcURL: URL, to dstURL: URL) throws"}, {"params": [{"param_name": ["atPath", "srcPath"], "param_type": "String", "param_description": "The path to the file or directory you want to move. This parameter must not be nil. "}, {"param_name": ["toPath", "dstPath"], "param_type": "String", "param_description": "The new path for the item in srcPath. This path must include the name of the file or directory in its new location. This parameter must not be nil."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item was moved successfully or the file manager\u2019s delegate stopped the operation deliberately. Returns false if an error occurred."], "return_type": []}, "method_name": "moveItem", "method_description": "Moves the file or directory at the specified path to a new location synchronously.", "method_declar": "func moveItem(atPath srcPath: String, toPath dstPath: String) throws"}, {"params": [{"param_name": ["forUbiquityContainerIdentifier", "containerIdentifier"], "param_type": "String", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A URL pointing to the specified ubiquity container, or nil if the container could not be located or if iCloud storage is unavailable for the current user or device."], "return_type": ["UR"]}, "method_name": "url", "method_description": "Returns the URL for the iCloud container associated with the specified identifier and establishes access to that container.", "method_declar": "func url(forUbiquityContainerIdentifier containerIdentifier: String?) -> URL?"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "Specify the URL for the file or directory whose status you want to check."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the item is targeted for iCloud storage or false if it is not. This method also returns false if no item exists at url."], "return_type": ["Boo"]}, "method_name": "isUbiquitousItem", "method_description": "Returns a Boolean indicating whether the item is targeted for storage in iCloud.", "method_declar": "func isUbiquitousItem(at url: URL) -> Bool"}, {"params": [{"param_name": ["flag"], "param_type": "Bool", "param_description": "true to move the item to iCloud or false to remove it from iCloud (if it is there currently)."}, {"param_name": ["itemAt", "url"], "param_type": "URL", "param_description": "The URL of the item (file or directory) that you want to store in iCloud."}, {"param_name": ["destinationURL"], "param_type": "URL", "param_description": "Moving a file into iCloud The location in iCloud at which to store the file or directory. This URL must be constructed from a URL returned by the url(forUbiquityContainerIdentifier:) method, which you use to retrieve the desired iCloud container directory. The URL you specify may contain additional subdirectories so that you can organize your files hierarchically in iCloud. However, you are responsible for creating those intermediate subdirectories (using the FileManager class) in your iCloud container directory.Moving a file out of iCloud The location on the local device."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the item\u2019s status was updated successfully or false if an error occurred. If this method returns false and you specified a value for the errorOut parameter, this method returns an error object in the provided pointer. "], "return_type": []}, "method_name": "setUbiquitous", "method_description": "Indicates whether the item at the specified URL should be stored in iCloud.", "method_declar": "func setUbiquitous(_ flag: Bool, itemAt url: URL, destinationURL: URL) throws"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The URL for the file or directory in the cloud that you want to download."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the download started successfully or was not necessary, otherwise false. If false is returned and errorOut is not nil, an NSError object describing the error is returned in that parameter."], "return_type": []}, "method_name": "startDownloadingUbiquitousItem", "method_description": "Starts downloading (if necessary) the specified item to the local system.", "method_declar": "func startDownloadingUbiquitousItem(at url: URL) throws"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The URL to a file or directory in iCloud storage. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the local item was removed successfully or false if it was not. If false is returned and error is not nil, an NSError object describing the error is returned in that parameter."], "return_type": []}, "method_name": "evictUbiquitousItem", "method_description": "Removes the local copy of the specified item that\u2019s stored in iCloud.", "method_declar": "func evictUbiquitousItem(at url: URL) throws"}, {"params": [{"param_name": ["forPublishingUbiquitousItemAt", "url"], "param_type": "URL", "param_description": "The URL of the item in the cloud that you want to share. The URL must be prefixed with the base URL returned from the url(forUbiquityContainerIdentifier:) method that corresponds to the item\u2019s location. The file must be a flat file, not a bundle. The file at the specified URL must already be uploaded to iCloud when you call this method."}, {"param_name": ["expiration", "outDate"], "param_type": "AutoreleasingUnsafeMutablePointer<NSDate>", "param_description": "On input, a pointer to a variable for a date object. On output, this parameter contains the date after which the item is no longer available at the returned URL. You may specify nil for this parameter if you are not interested in the date."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A URL with which users can download a copy of the item at url."], "return_type": ["UR"]}, "method_name": "url", "method_description": "Returns a URL that can be emailed to users to allow them to download a copy of a flat file item from iCloud.", "method_declar": "func url(forPublishingUbiquitousItemAt url: URL, expiration outDate: AutoreleasingUnsafeMutablePointer<NSDate?>?) throws -> URL"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The file URL of a document or directory."}, {"param_name": ["completionHandler"], "param_type": "@escaping ([NSFileProviderServiceName", "param_description": "A block that is called on an anonymous background queue. The system passes this block the following parameters:servicesIf the request is successful, this property contains a dictionary with zero or more NSFileProviderServiceName keys and their corresponding NSFileProviderService values; otherwise, it is set to nil.errorIf an error occurs, this property contains an object that describes the error; otherwise, it is set to nil."}, {"param_name": ["@escaping", "([NSFileProviderServiceName"], "param_type": "NSFileProviderService], Error) -> Void", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "getFileProviderServicesForItem", "method_description": "Returns the services provided by the File Provider extension that manages the item at the given URL.", "method_declar": "func getFileProviderServicesForItem(at url: URL, completionHandler: @escaping ([NSFileProviderServiceName : NSFileProviderService]?, Error?) -> Void)"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "The file URL at which to create the new symbolic link. The last path component of the URL issued as the name of the link."}, {"param_name": ["withDestinationURL", "destURL"], "param_type": "URL", "param_description": "The file URL that contains the item to be pointed to by the link. In other words, this is the destination of the link."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the symbolic link was created or false if an error occurred. This method also returns false if a file, directory, or link already exists at url."], "return_type": []}, "method_name": "createSymbolicLink", "method_description": "Creates a symbolic link at the specified URL that points to an item at the given URL. ", "method_declar": "func createSymbolicLink(at url: URL, withDestinationURL destURL: URL) throws"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path at which to create the new symbolic link. The last path component is used as the name of the link."}, {"param_name": ["withDestinationPath", "destPath"], "param_type": "String", "param_description": "The path that contains the item to be pointed to by the link. In other words, this is the destination of the link."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the symbolic link was created or false if an error occurred. This method also returns false if a file, directory, or link already exists at path."], "return_type": []}, "method_name": "createSymbolicLink", "method_description": "Creates a symbolic link that points to the specified destination. ", "method_declar": "func createSymbolicLink(atPath path: String, withDestinationPath destPath: String) throws"}, {"params": [{"param_name": ["at", "srcURL"], "param_type": "URL", "param_description": "The file URL that identifies the source of the link. The URL in this parameter must not be a file reference URL; it must specify the actual path to the item. The value in this parameter must not be nil."}, {"param_name": ["to", "dstURL"], "param_type": "URL", "param_description": "The file URL that specifies where you want to create the hard link. The URL in this parameter must not be a file reference URL; it must specify the actual path to the item. The value in this parameter must not be nil. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the hard link was created or false if an error occurred. This method also returns false if a file, directory, or link already exists at dstURL."], "return_type": []}, "method_name": "linkItem", "method_description": "Creates a hard link between the items at the specified URLs.", "method_declar": "func linkItem(at srcURL: URL, to dstURL: URL) throws"}, {"params": [{"param_name": ["atPath", "srcPath"], "param_type": "String", "param_description": "The path that specifies the item you wish to link to. The value in this parameter must not be nil. "}, {"param_name": ["toPath", "dstPath"], "param_type": "String", "param_description": "The path that identifies the location where the link will be created. The value in this parameter must not be nil. "}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the hard link was created or false if an error occurred. This method also returns false if a file, directory, or link already exists at dstPath."], "return_type": []}, "method_name": "linkItem", "method_description": "Creates a hard link between the items at the specified paths.", "method_declar": "func linkItem(atPath srcPath: String, toPath dstPath: String) throws"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of a file or directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSString object containing the path of the directory or file to which the symbolic link path refers. If the symbolic link is specified as a relative path, that relative path is returned."], "return_type": ["Strin"]}, "method_name": "destinationOfSymbolicLink", "method_description": "Returns the path of the item pointed to by a symbolic link.", "method_declar": "func destinationOfSymbolicLink(atPath path: String) throws -> String"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of the file or directory. If path begins with a tilde (~), it must first be expanded with expandingTildeInPath; otherwise, this method returns false.App Sandbox does not restrict which path values may be passed to this parameter."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if a file at the specified path exists, or false if the file does not exist or its existence could not be determined. "], "return_type": ["Boo"]}, "method_name": "fileExists", "method_description": "Returns a Boolean value that indicates whether a file or directory exists at a specified path.", "method_declar": "func fileExists(atPath path: String) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of a file or directory. If path begins with a tilde (~), it must first be expanded with expandingTildeInPath, or this method will return false."}, {"param_name": ["isDirectory"], "param_type": "UnsafeMutablePointer<ObjCBool>", "param_description": "Upon return, contains true if path is a directory or if the final path element is a symbolic link that points to a directory; otherwise, contains false. If path doesn\u2019t exist, this value is undefined upon return. Pass NULL if you do not need this information."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if a file at the specified path exists, or false if the file\u2019s does not exist or its existence could not be determined. "], "return_type": ["Boo"]}, "method_name": "fileExists", "method_description": "Returns a Boolean value that indicates whether a file or directory exists at a specified path.", "method_declar": "func fileExists(atPath path: String, isDirectory: UnsafeMutablePointer<ObjCBool>?) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A file path."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the current process has read privileges for the file at path; otherwise false if the process does not have read privileges or the existence of the file could not be determined. "], "return_type": ["Boo"]}, "method_name": "isReadableFile", "method_description": "Returns a Boolean value that indicates whether the invoking object appears able to read a specified file. ", "method_declar": "func isReadableFile(atPath path: String) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A file path."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the current process has write privileges for the file at path; otherwise false if the process does not have write privileges or the existence of the file could not be determined. "], "return_type": ["Boo"]}, "method_name": "isWritableFile", "method_description": "Returns a Boolean value that indicates whether the invoking object appears able to write to a specified file.", "method_declar": "func isWritableFile(atPath path: String) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A file path."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the current process has execute privileges for the file at path; otherwise false if the process does not have execute privileges or the existence of the file could not be determined. "], "return_type": ["Boo"]}, "method_name": "isExecutableFile", "method_description": "Returns a Boolean value that indicates whether the operating system appears able to execute a specified file.", "method_declar": "func isExecutableFile(atPath path: String) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A file path."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the current process has delete privileges for the file at path; otherwise false if the process does not have delete privileges or the existence of the file could not be determined. "], "return_type": ["Boo"]}, "method_name": "isDeletableFile", "method_description": "Returns a Boolean value that indicates whether the invoking object appears able to delete a specified file.", "method_declar": "func isDeletableFile(atPath path: String) -> Bool"}, {"params": [{"param_name": ["forPath", "path"], "param_type": "String", "param_description": "A pathname."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSString objects representing the user-visible (for the Finder, Open and Save panels, and so on) components of path. Returns nil if path does not exist."], "return_type": ["[String"]}, "method_name": "componentsToDisplay", "method_description": "Returns an array of strings representing the user-visible components of a given path.", "method_declar": "func componentsToDisplay(forPath path: String) -> [String]?"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of a file or directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The name of the file or directory at path in a localized form appropriate for presentation to the user. If there is no file or directory at path, or if an error occurs, returns path as is."], "return_type": ["Strin"]}, "method_name": "displayName", "method_description": "Returns the display name of the file or directory at a specified path.", "method_declar": "func displayName(atPath path: String) -> String"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of a file or directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [["[FileAttributeKey"]], "return_description": ["A dictionary object that describes the attributes (file, directory, symlink, and so on) of the file specified by path. The keys in the dictionary are described in File Attribute Keys."], "return_type": ["Any"]}, "method_name": "attributesOfItem", "method_description": "Returns the attributes of the item at a given path.", "method_declar": "func attributesOfItem(atPath path: String) throws -> [FileAttributeKey : Any]"}, {"params": [{"param_name": ["forPath", "path"], "param_type": "String", "param_description": "Any pathname within the mounted file system."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [["[FileAttributeKey"]], "return_description": ["A dictionary object that describes the attributes of the mounted file system on which path resides. See File-System Attribute Keys for a description of the keys available in the dictionary."], "return_type": ["Any"]}, "method_name": "attributesOfFileSystem", "method_description": "Returns a dictionary that describes the attributes of the mounted file system on which a given path resides.", "method_declar": "func attributesOfFileSystem(forPath path: String) throws -> [FileAttributeKey : Any]"}, {"params": [{"param_name": ["attributes"], "param_type": "[FileAttributeKey", "param_description": "A dictionary containing as keys the attributes to set for path and as values the corresponding value for the attribute. You can set the following attributes: busy, creationDate, extensionHidden, groupOwnerAccountID, groupOwnerAccountName, hfsCreatorCode, hfsTypeCode, immutable, modificationDate, ownerAccountID, ownerAccountName, posixPermissions. You can change single attributes or any combination of attributes; you need not specify keys for all attributes."}, {"param_name": ["[FileAttributeKey"], "param_type": "Any]", "param_description": ""}, {"param_name": ["ofItemAtPath", "path"], "param_type": "String", "param_description": "The path of a file or directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if all changes succeed. If any change fails, returns false, but it is undefined whether any changes actually occurred."], "return_type": []}, "method_name": "setAttributes", "method_description": "Sets the attributes of the specified file or directory. ", "method_declar": "func setAttributes(_ attributes: [FileAttributeKey : Any], ofItemAtPath path: String) throws"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of the file whose contents you want."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSData object with the contents of the file. If path specifies a directory, or if some other error occurs, this method returns nil."], "return_type": ["Dat"]}, "method_name": "contents", "method_description": "Returns the contents of the file at the specified path.", "method_declar": "func contents(atPath path: String) -> Data?"}, {"params": [{"param_name": ["atPath", "path1"], "param_type": "String", "param_description": "The path of a file or directory to compare with the contents of path2."}, {"param_name": ["andPath", "path2"], "param_type": "String", "param_description": "The path of a file or directory to compare with the contents of path1."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if file or directory specified in path1 has the same contents as that specified in path2, otherwise false."], "return_type": ["Boo"]}, "method_name": "contentsEqual", "method_description": "Returns a Boolean value that indicates whether the files or directories in specified paths have the same contents.", "method_declar": "func contentsEqual(atPath path1: String, andPath path2: String) -> Bool"}, {"params": [{"param_name": ["outRelationship"], "param_type": "UnsafeMutablePointer<FileManager.URLRelationship>", "param_description": "A pointer to a variable in which to put the relationship between directoryURL and otherURL. For a list of possible values, see FileManager.URLRelationship.  "}, {"param_name": ["ofDirectoryAt", "directoryURL"], "param_type": "URL", "param_description": "The URL of the directory that potentially contains the item in otherURL. The URL in this parameter must specify a directory. This parameter must not be nil."}, {"param_name": ["toItemAt", "otherURL"], "param_type": "URL", "param_description": "The URL of the file or directory whose relationship to directoryURL is being tested. This parameter must not be nil."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the relationship between the items was successfully determined, or false if an error occurred."], "return_type": []}, "method_name": "getRelationship", "method_description": "Determines the type of relationship that exists between a directory and an item.", "method_declar": "func getRelationship(_ outRelationship: UnsafeMutablePointer<FileManager.URLRelationship>, ofDirectoryAt directoryURL: URL, toItemAt otherURL: URL) throws"}, {"params": [{"param_name": ["outRelationship"], "param_type": "UnsafeMutablePointer<FileManager.URLRelationship>", "param_description": "A pointer to a variable in which to put the relationship between directoryURL and otherURL. For a list of possible values, see FileManager.URLRelationship.  "}, {"param_name": ["of", "directory"], "param_type": "FileManager.SearchPathDirectory", "param_description": "The search path directory. For a list of possible values, see FileManager.SearchPathDirectory."}, {"param_name": ["in", "domainMask"], "param_type": "FileManager.SearchPathDomainMask", "param_description": "The file system domain to search. Specify 0 for this parameter if you want the file manager to choose the domain that is most appropriate for the specified url. "}, {"param_name": ["toItemAt", "url"], "param_type": "URL", "param_description": "The URL of the file or directory whose relationship to directoryURL is being tested. This parameter must not be nil."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": ["true if the relationship between the items was successfully determined, or false if an error occurred."], "return_type": []}, "method_name": "getRelationship", "method_description": "Determines the type of relationship that exists between a system directory and the specified item. ", "method_declar": "func getRelationship(_ outRelationship: UnsafeMutablePointer<FileManager.URLRelationship>, of directory: FileManager.SearchPathDirectory, in domainMask: FileManager.SearchPathDomainMask, toItemAt url: URL) throws"}, {"params": [{"param_name": ["withPath", "path"], "param_type": "String", "param_description": "A string object containing a path to a file. This parameter must not be nil or contain the empty string."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A C-string representation of path that properly encodes Unicode strings for use by the file system."], "return_type": ["UnsafePointer<Int8"]}, "method_name": "fileSystemRepresentation", "method_description": "Returns a C-string representation of a given path that properly encodes Unicode strings for use by the file system.", "method_declar": "func fileSystemRepresentation(withPath path: String) -> UnsafePointer<Int8>"}, {"params": [{"param_name": ["withFileSystemRepresentation", "str"], "param_type": "UnsafePointer<Int8>", "param_description": ""}, {"param_name": ["length", "len"], "param_type": "Int", "param_description": "The number of characters in string."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSString object converted from the C-string representation string with length len of a pathname in the current file system."], "return_type": ["Strin"]}, "method_name": "string", "method_description": "Returns an NSString object whose contents are derived from the specified C-string path.", "method_declar": "func string(withFileSystemRepresentation str: UnsafePointer<Int8>, length len: Int) -> String"}, {"params": [{"param_name": ["path"], "param_type": "String", "param_description": "The path of the directory to which to change."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if successful, otherwise false."], "return_type": ["Boo"]}, "method_name": "changeCurrentDirectoryPath", "method_description": "Changes the path of the current working directory to the specified path. ", "method_declar": "func changeCurrentDirectoryPath(_ path: String) -> Bool"}, {"params": [{"param_name": ["at", "url"], "param_type": "URL", "param_description": "A file URL specifying the volume to be unmounted."}, {"param_name": ["options", "mask"], "param_type": "FileManager.UnmountOptions", "param_description": "A bitmask of FileManager.UnmountOptions that you can use to customize the unmount operation\u2019s behavior."}, {"param_name": ["completionHandler"], "param_type": "@escaping (Error) -> Void", "param_description": "A block executed when the unmount operation completes. The block receives an Error parameter which is nil if unmounting was successful. Otherwise, it indicates why unmounting failed."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "unmountVolume", "method_description": "Starts the process of unmounting the specified volume.", "method_declar": "func unmountVolume(at url: URL, options mask: FileManager.UnmountOptions = [], completionHandler: @escaping (Error?) -> Void)"}, {"params": [{"param_name": ["hfsFileTypeCode"], "param_type": "OSType", "param_description": "An HFS file type code."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A string that encodes hfsFileTypeCode."], "return_type": ["String"]}, "method_name": "NSFileTypeForHFSTypeCode", "method_description": "Returns a string encoding a file type code.", "method_declar": "func NSFileTypeForHFSTypeCode(_ hfsFileTypeCode: OSType) -> String!"}, {"params": [{"param_name": ["fileTypeString"], "param_type": "String!", "param_description": "A string of the sort encoded by NSFileTypeForHFSTypeCode()."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The HFS file type code corresponding to fileTypeString, or 0 if it cannot be found."], "return_type": ["OSTyp"]}, "method_name": "NSHFSTypeCodeFromFileType", "method_description": "Returns a file type code.", "method_declar": "func NSHFSTypeCodeFromFileType(_ fileTypeString: String!) -> OSType"}, {"params": [{"param_name": ["fullFilePath"], "param_type": "String!", "param_description": "The full absolute path of a file."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A string that encodes fullFilePath\u2018s HFS file type, or nil if the operation was not successful"], "return_type": ["String"]}, "method_name": "NSHFSTypeOfFile", "method_description": "Returns a string encoding a file type.", "method_declar": "func NSHFSTypeOfFile(_ fullFilePath: String!) -> String!"}, {"params": [{"param_name": ["attributes"], "param_type": "[AnyHashable", "param_description": "A dictionary containing as keys the attributes to set for path and as values the corresponding value for the attribute. You can set following: NSFileBusy, NSFileCreationDate, NSFileExtensionHidden, NSFileGroupOwnerAccountID, NSFileGroupOwnerAccountName, NSFileHFSCreatorCode, NSFileHFSTypeCode, NSFileImmutable, NSFileModificationDate, NSFileOwnerAccountID, NSFileOwnerAccountName, NSFilePosixPermissions. You can change single attributes or any combination of attributes; you need not specify keys for all attributes.For the NSFilePosixPermissions value, specify a file mode from the OR\u2019d permission bit masks defined in sys/stat.h. See the man page for the chmod function (man 2 chmod) for an explanation."}, {"param_name": ["[AnyHashable"], "param_type": "Any]", "param_description": ""}, {"param_name": ["Any]", "=", "["], "param_type": "]", "param_description": ""}, {"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A path to a file or directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if all changes succeed. If any change fails, returns false, but it is undefined whether any changes actually occurred."], "return_type": ["Boo"]}, "method_name": "changeFileAttributes", "method_description": "Changes the attributes of a given file or directory. DeprecatedUse setAttributes(_:ofItemAtPath:) instead.", "method_declar": "func changeFileAttributes(_ attributes: [AnyHashable : Any] = [:], atPath path: String) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A file path."}, {"param_name": ["traverseLink", "yorn"], "param_type": "Bool", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [["[AnyHashable"]], "return_description": ["An NSDictionary object that describes the POSIX attributes of the file specified at path. The keys in the dictionary are described in File Attribute Keys. If there is no item at path, returns nil."], "return_type": ["Any"]}, "method_name": "fileAttributes", "method_description": "Returns a dictionary that describes the POSIX attributes of the file specified at a given.DeprecatedUse attributesOfItem(atPath:) instead.", "method_declar": "func fileAttributes(atPath path: String, traverseLink yorn: Bool) -> [AnyHashable : Any]?"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "Any pathname within the mounted file system."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [["[AnyHashable"]], "return_description": ["An NSDictionary object that describes the attributes of the mounted file system on which path resides. See File-System Attribute Keys for a description of the keys available in the dictionary."], "return_type": ["Any"]}, "method_name": "fileSystemAttributes", "method_description": "Returns a dictionary that describes the attributes of the mounted file system on which a given path resides.DeprecatedUse attributesOfFileSystem(forPath:) instead.", "method_declar": "func fileSystemAttributes(atPath path: String) -> [AnyHashable : Any]?"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "A path to a directory."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An array of NSString objects identifying the directories and files (including symbolic links) contained in path. Returns an empty array if the directory exists but has no contents. Returns nil if the directory specified at path does not exist or there is some other error accessing it. "], "return_type": ["[Any"]}, "method_name": "directoryContents", "method_description": "Returns the directories and files (including symbolic links) contained in a given directory.DeprecatedUse contentsOfDirectory(atPath:) instead.", "method_declar": "func directoryContents(atPath path: String) -> [Any]?"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path at which to create the new directory. The directory to be created must not yet exist, but its parent directory must exist."}, {"param_name": ["attributes"], "param_type": "[AnyHashable", "param_description": "The file attributes for the new directory. The attributes you can set are owner and group numbers, file permissions, and modification date. If you specify nil for attributes, default values for these attributes are set (particularly write access for the creator and read access for others). For a list of keys you can include in this dictionary, Supporting Types. Some of the keys, such as NSFileHFSCreatorCode and NSFileHFSTypeCode, do not apply to directories."}, {"param_name": ["[AnyHashable"], "param_type": "Any]", "param_description": ""}, {"param_name": ["Any]", "=", "["], "param_type": "]", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the operation was successful, otherwise false."], "return_type": ["Boo"]}, "method_name": "createDirectory", "method_description": "Creates a directory (without contents) at a given path with given attributes.DeprecatedUse createDirectory(at:withIntermediateDirectories:attributes:) instead.", "method_declar": "func createDirectory(atPath path: String, attributes: [AnyHashable : Any] = [:]) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path for a symbolic link."}, {"param_name": ["pathContent", "otherpath"], "param_type": "String", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the operation is successful, otherwise false. Returns false if a file, directory, or symbolic link identical to path already exists."], "return_type": ["Boo"]}, "method_name": "createSymbolicLink", "method_description": "Creates a symbolic link identified by a given path that refers to a given location.DeprecatedUse createSymbolicLink(at:withDestinationURL:) instead.", "method_declar": "func createSymbolicLink(atPath path: String, pathContent otherpath: String) -> Bool"}, {"params": [{"param_name": ["atPath", "path"], "param_type": "String", "param_description": "The path of a symbolic link."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The path of the directory or file to which the symbolic link path refers, or nil upon failure. If the symbolic link is specified as a relative path, that relative path is returned."], "return_type": ["Strin"]}, "method_name": "pathContentOfSymbolicLink", "method_description": "Returns the path of the directory or file that a symbolic link at a given path refers to.DeprecatedUse destinationOfSymbolicLink(atPath:) instead.", "method_declar": "func pathContentOfSymbolicLink(atPath path: String) -> String?"}, {"params": [{"param_name": ["fm"], "param_type": "FileManager", "param_description": ""}, {"param_name": ["shouldProceedAfterError", "errorInfo"], "param_type": "[AnyHashable", "param_description": "A dictionary that contains two or three pieces of information (all NSString objects) related to the error:KeyValue@\"Path\"The path related to the error (usually the source path)@\"Error\"A description of the error@\"ToPath\" The destination path (not all errors)"}, {"param_name": ["[AnyHashable"], "param_type": "Any]", "param_description": ""}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the operation (which is often continuous within a loop) should proceed, otherwise false. "], "return_type": ["Boo"]}, "method_name": "fileManager", "method_description": "An NSFileManager object sends this message to its handler for each error it encounters when copying, moving, removing, or linking files or directories. DeprecatedSee delegate methods for copy, move, remove, and link methods.", "method_declar": "func fileManager(_ fm: FileManager, shouldProceedAfterError errorInfo: [AnyHashable : Any]) -> Bool"}, {"params": [{"param_name": ["fm"], "param_type": "FileManager", "param_description": ""}, {"param_name": ["willProcessPath", "path"], "param_type": "String", "param_description": "The path or a file or directory that manager is about to attempt to move, copy, rename, delete, or link to."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "fileManager", "method_description": "An NSFileManager object sends this message to a handler immediately before attempting to move, copy, rename, or delete, or before attempting to link to a given path.DeprecatedSee delegate methods for copy, move, link, and remove methods.", "method_declar": "func fileManager(_ fm: FileManager, willProcessPath path: String)"}, {"params": [{"param_name": ["originalItemURL"], "param_type": "NSURL", "param_description": "The item containing the content you want to replace."}, {"param_name": ["withItemAtURL", "newItemURL"], "param_type": "NSURL", "param_description": "The item containing the new content for originalItemURL. It is recommended that you put this item in a temporary directory as provided by the OS. If a temporary directory is not available, put this item in a uniquely named directory that is in the same directory as the original item."}, {"param_name": ["backupItemName"], "param_type": "String", "param_description": "If provided, the name used to create a backup of the original item.The backup is placed in the same directory as the original item. If an error occurs during the creation of the backup item, the operation fails. If there is already an item with the same name as the backup item, that item will be removed.The backup item will be removed in the event of success unless the withoutDeletingBackupItem option is provided in options."}, {"param_name": ["options"], "param_type": "FileManager.ItemReplacementOptions = []", "param_description": "The options to use during the replacement. Typically, you pass usingNewMetadataOnly for this parameter, which uses only the metadata from the new item. You can also combine the options described in FileManager.ItemReplacementOptions using the C-bitwise OR operator."}], "class_name": "FileManager", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The URL of the new item. If no new file system object is required, the URL object in this parameter may be the same passed to the originalItemURL parameter. However, if a new file system object is required, the URL object may be different. For example, replacing an RTF document with an RTFD document requires the creation of a new file."], "return_type": ["NSUR"]}, "method_name": "replaceItemAtURL", "method_description": "Replaces the contents of the item at the specified URL in a manner that ensures no data loss occurs.DeprecatedUse replaceItemAt(_:withItemAt:backupItemName:options:) instead.", "method_declar": "func replaceItemAtURL(originalItemURL: NSURL, withItemAtURL newItemURL: NSURL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> NSURL?"}], "class_name": "FileManager", "Vars": [{"var_description": "The shared file manager object for the process.", "var_type": "FileManager", "is_static": false, "var_name": "`default`"}, {"var_description": "The home directory for the current user.", "var_type": "URL", "is_static": false, "var_name": "homeDirectoryForCurrentUser"}, {"var_description": "The temporary directory for the current user.", "var_type": "URL", "is_static": false, "var_name": "temporaryDirectory"}, {"var_description": "An opaque token that represents the current user\u2019s iCloud identity.", "var_type": "(NSCoding", "is_static": false, "var_name": "ubiquityIdentityToken"}, {"var_description": "The delegate of the file manager object.", "var_type": "FileManagerDelegate", "is_static": false, "var_name": "delegate"}, {"var_description": "The path to the program\u2019s current directory.", "var_type": "String", "is_static": false, "var_name": "currentDirectoryPath"}, {"var_description": "The process identifier of the process that prevented a volume from unmounting.", "var_type": "String", "is_static": false, "var_name": "NSFileManagerUnmountDissentingProcessIdentifierErrorKey"}, {"var_description": "The version of the Foundation framework in which NSFileManager first supported resource forks.", "var_type": "Int32", "is_static": false, "var_name": "NSFoundationVersionWithFileManagerResourceForkSupport"}, {"var_description": "Sent after the iCloud (\u201cubiquity\u201d) identity has changed.", "var_type": "NSNotification.Name", "is_static": false, "var_name": "NSUbiquityIdentityDidChange"}]}