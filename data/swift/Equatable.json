{"class_description": "Types that conform to the Equatable protocol can be compared for equality using the equal-to operator (==) or inequality using the not-equal-to operator (!=). Most basic types in the Swift standard library conform to Equatable.\nSome sequence and collection operations can be used more simply when the elements conform to Equatable. For example, to check whether an array contains a particular value, you can pass the value itself to the contains(_:) method when the array\u2019s element conforms to Equatable instead of providing a closure that determines equivalence. The following example shows how the contains(_:) method can be used with an array of strings.\nAdding Equatable conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection. Equatable is also the base protocol for the Hashable and Comparable protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.\nYou can rely on automatic synthesis of the Equatable protocol\u2019s requirements for a custom type when you declare Equatable conformance in the type\u2019s original declaration and your type meets these criteria:\nFor a struct, all its stored properties must conform to Equatable.\nFor an enum, all its associated values must conform to Equatable. (An enum without associated values has Equatable conformance even without the declaration.)\nTo customize your type\u2019s Equatable conformance, to adopt Equatable in a type that doesn\u2019t meet the criteria listed above, or to extend an existing type to conform to Equatable, implement the equal-to operator (==) as a static method of your type. The standard library provides an implementation for the not-equal-to operator (!=) for any Equatable type, which calls the custom == function and negates its result.\nAs an example, consider a StreetAddress class that holds the parts of a street address: a house or building number, the street name, and an optional unit number. Here\u2019s the initial declaration of the StreetAddress type:\nNow suppose you have an array of addresses that you need to check for a particular address. To use the contains(_:) method without including a closure in each call, extend the StreetAddress type to conform to Equatable.\nThe StreetAddress type now conforms to Equatable. You can use == to check for equality between any two instances or call the Equatable-constrained contains(_:) method.\nEquality implies substitutability\u2014any two instances that compare equally can be used interchangeably in any code that depends on their values. To maintain substitutability, the == operator should take into account all visible aspects of an Equatable type. Exposing nonvalue aspects of Equatable types other than class identity is discouraged, and any that are exposed should be explicitly pointed out in documentation.\nSince equality between instances of Equatable types is an equivalence relation, any of your custom types that conform to Equatable must satisfy three conditions, for any values a, b, and c:\na == a is always true (Reflexivity)\na == b implies b == a (Symmetry)\na == b and b == c implies a == c (Transitivity)\nMoreover, inequality is the inverse of equality, so any custom implementation of the != operator must guarantee that a != b implies !(a == b). The default implementation of the != operator function satisfies this requirement.\nThe identity of a class instance is not part of an instance\u2019s value. Consider a class called IntegerRef that wraps an integer value. Here\u2019s the definition for IntegerRef and the == function that makes it conform to Equatable:\nThe implementation of the == function returns the same value whether its two arguments are the same instance or are two different instances with the same integer stored in their value properties. For example:\nClass instance identity, on the other hand, is compared using the triple-equals identical-to operator (===). For example:\n", "Methods": [], "class_inherit_list": [], "class_name": "Equatable", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["Comparable", "Hashable", "Numeric", "SetAlgebra"]}