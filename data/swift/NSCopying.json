{"class_description": "The exact meaning of \u201ccopy\u201d can vary from class to class, but a copy must be a functionally independent object with values identical to the original at the time the copy was made. A copy produced with NSCopying is implicitly retained by the sender, who is responsible for releasing it.\nNSCopying declares one method, copy(with:), but copying is commonly invoked with the convenience method copy(). The copy() method is defined for all objects inheriting from NSObject and simply invokes copy(with:) with the default zone.\nYour options for implementing this protocol are as follows:\nImplement NSCopying using alloc and init... in classes that don\u2019t inherit copy(with:).\nImplement NSCopying by invoking the superclass\u2019s copy(with:) when NSCopying behavior is inherited. If the superclass implementation might use the NSCopyObject function, make explicit assignments to pointer instance variables for retained objects.\nImplement NSCopying by retaining the original instead of creating a new copy when the class and its contents are immutable.\nIf a subclass inherits NSCopying from its superclass and declares additional instance variables, the subclass has to override copy(with:) to properly handle its own instance variables, invoking the superclass\u2019s implementation first.\n", "Methods": [], "class_inherit_list": [], "class_name": "NSCopying", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "foundation", "subclass_list": ["ARAnchorCopying", "DOMEventTarget", "GKGameModel", "MDLMeshBuffer", "MPSCNNBatchNormalizationDataSource", "MPSCNNConvolutionDataSource", "MPSCNNInstanceNormalizationDataSource", "NFCTag", "UITimingCurveProvider"]}