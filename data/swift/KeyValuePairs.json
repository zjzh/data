{"Methods": [], "Vars": [], "class_name": "KeyValuePairs", "interface_list": ["CustomDebugStringConvertible", "CustomStringConvertible", "ExpressibleByDictionaryLiteral", "RandomAccessCollection"], "class_description": "Use a KeyValuePairs instance when you need an ordered collection of key-value pairs and don\u2019t require the fast key lookup that the Dictionary type provides. Unlike key-value pairs in a true dictionary, neither the key nor the value of a KeyValuePairs instance must conform to the Hashable protocol.\nYou initialize a KeyValuePairs instance using a Swift dictionary literal. Besides maintaining the order of the original dictionary literal, KeyValuePairs also allows duplicates keys. For example:\nSome operations that are efficient on a dictionary are slower when using KeyValuePairs. In particular, to find the value matching a key, you must search through every element of the collection. The call to firstIndex(where:) in the following example must traverse the whole collection to find the element that matches the predicate:\nWhen calling a function with a KeyValuePairs parameter, you can pass a Swift dictionary literal without causing a Dictionary to be created. This capability can be especially important when the order of elements in the literal is significant.\nFor example, you could create an IntPairs structure that holds a list of two-integer tuples and use an initializer that accepts a KeyValuePairs instance.\nWhen you\u2019re ready to create a new IntPairs instance, use a dictionary literal as the parameter to the IntPairs initializer. The KeyValuePairs instance preserves the order of the elements as passed.\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}