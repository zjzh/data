{"class_description": "A dictionary is a type of hash table, providing fast access to the entries it contains. Each entry in the table is identified using its key, which is a hashable type such as a string or number. You use that key to retrieve the corresponding value, which can be any object. In other languages, similar data types are known as hashes or associated arrays.\nCreate a new dictionary by using a dictionary literal. A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets. You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.\nHere\u2019s how you would create a dictionary of HTTP response codes and their related messages:\nThe responseMessages variable is inferred to have type [Int: String]. The Key type of the dictionary is Int, and the Value type of the dictionary is String.\nTo create a dictionary with no key-value pairs, use an empty dictionary literal ([:]).\nAny type that conforms to the Hashable protocol can be used as a dictionary\u2019s Key type, including all of Swift\u2019s basic types. You can use your own custom types as dictionary keys by making them conform to the Hashable protocol.\nThe most common way to access values in a dictionary is to use a key as a subscript. Subscripting with a key takes the following form:\nSubscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.\nThe next example uses key-based subscripting of the responseMessages dictionary with two keys that exist in the dictionary and one that does not.\nYou can also update, modify, or remove keys and values from a dictionary using the key-based subscript. To add a new key-value pair, assign a value to a key that isn\u2019t yet a part of the dictionary.\nUpdate an existing value by assigning a new value to a key that already exists in the dictionary. If you assign nil to an existing key, the key and its associated value are removed. The following example updates the value for the 404 code to be simply \u201cNot found\u201d and removes the key-value pair for the 500 code entirely.\nIn a mutable Dictionary instance, you can modify in place a value that you\u2019ve accessed through a keyed subscript. The code sample below declares a dictionary called interestingNumbers with string keys and values that are integer arrays, then sorts each array in-place in descending order.\nEvery dictionary is an unordered collection of key-value pairs. You can iterate over a dictionary using a for-in loop, decomposing each key-value pair into the elements of a tuple.\nThe order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable. If you need an ordered collection of key-value pairs and don\u2019t need the fast key lookup that Dictionary provides, see the DictionaryLiteral type for an alternative.\nYou can search a dictionary\u2019s contents for a particular value using the contains(where:) or firstIndex(where:) methods supplied by default implementation. The following example checks to see if imagePaths contains any paths in the \"/glyphs\" directory:\nNote that in this example, imagePaths is subscripted using a dictionary index. Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a nonoptional tuple.\nA dictionary\u2019s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer. When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.\nWhen you know how many new values you\u2019re adding to a dictionary, use the init(minimumCapacity:) initializer to allocate the correct amount of buffer.\nYou can bridge between Dictionary and NSDictionary using the as operator. For bridging to be possible, the Key and Value types of a dictionary must be classes, @objc protocols, or types that bridge to Foundation types.\nBridging from Dictionary to NSDictionary always takes O(1) time and space. When the dictionary\u2019s Key and Value types are neither classes nor @objc protocols, any required bridging of elements occurs at the first access of each element. For this reason, the first operation that uses the contents of the dictionary may take O(n).\nBridging from NSDictionary to Dictionary first calls the copy(with:) method (- copyWithZone: in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of NSDictionary that are already immutable, copy(with:) usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified. The instances of NSDictionary and Dictionary share buffer using the same copy-on-write optimization that is used when two instances of Dictionary share buffer.\n", "Methods": [{"method_description": "Returns the index for the given key.", "method_name": "index", "params": [{"param_type": "Key", "param_description": "The key to find in the dictionary.", "param_name": ["forKey", "key"]}], "class_name": "Dictionary", "method_declar": "func index(forKey key: Key) -> Dictionary<Key, Value>.Index?", "return_value": {"return_description": ["The index for key and its associated value if key is in the dictionary; otherwise, nil."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "is_static": false}, {"method_description": "Returns a random element of the collection.", "method_name": "randomElement", "params": [{"param_type": "Key", "param_description": "", "param_name": [")", "->", "(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func randomElement() -> (key: Key, value: Value)?", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [["key"], ["value"]], "return_type": ["Key", "Value"]}, "is_static": false}, {"method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "params": [{"param_type": "inout RandomNumberGenerator) -> (ke", "param_description": "The random number generator to use when choosing a random element.", "param_name": ["using", "generator"]}, {"param_type": "Key", "param_description": "", "param_name": ["inout", "T)", "->", "(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func randomElement<T>(using generator: inout T) -> (key: Key, value: Value)? where T : RandomNumberGenerator", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [["key"], ["value"]], "return_type": ["Key", "Value"]}, "is_static": false}, {"method_description": "Reserves enough space to store the specified number of key-value pairs.", "method_name": "reserveCapacity", "params": [{"param_type": "Int", "param_description": "The requested number of key-value pairs to store.", "param_name": ["minimumCapacity"]}], "class_name": "Dictionary", "method_declar": "mutating func reserveCapacity(_ minimumCapacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new dictionary containing the key-value pairs of the dictionary that satisfy the given predicate.", "method_name": "filter", "params": [{"param_type": "(Dictionary<Key, Value>.Element) throws -> Bool", "param_description": "A closure that takes a key-value pair as its argument and returns a Boolean value indicating whether the pair should be included in the returned dictionary.", "param_name": ["isIncluded"]}], "class_name": "Dictionary", "method_declar": "func filter(_ isIncluded: (Dictionary<Key, Value>.Element) throws -> Bool) rethrows -> [Key : Value]", "return_value": {"return_description": ["A dictionary of the key-value pairs that isIncluded allows."], "return_name": [["[Key"]], "return_type": ["Value]"]}, "is_static": false}, {"method_description": "Removes the given key and its associated value from the dictionary.", "method_name": "removeValue", "params": [{"param_type": "Key", "param_description": "The key to remove along with its associated value.", "param_name": ["forKey", "key"]}], "class_name": "Dictionary", "method_declar": "@discardableResult mutating func removeValue(forKey key: Key) -> Value?", "return_value": {"return_description": ["The value that was removed, or nil if the key was not present in the dictionary."], "return_name": [""], "return_type": ["Value"]}, "is_static": false}, {"method_description": "Removes and returns the key-value pair at the specified index.", "method_name": "remove", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "The position of the key-value pair to remove. index must be a valid index of the dictionary, and must not equal the dictionary\u2019s end index.", "param_name": ["at", "index"]}], "class_name": "Dictionary", "method_declar": "@discardableResult mutating func remove(at index: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Element", "return_value": {"return_description": ["The key-value pair that correspond to index."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Element"]}, "is_static": false}, {"method_description": "Removes all key-value pairs from the dictionary.", "method_name": "removeAll", "params": [{"param_type": "Bool = false", "param_description": "Whether the dictionary should keep its underlying buffer. If you pass true, the operation preserves the buffer capacity that the collection has, otherwise the underlying buffer is released.  The default is false.", "param_name": ["keepingCapacity", "keepCapacity"]}], "class_name": "Dictionary", "method_declar": "mutating func removeAll(keepingCapacity keepCapacity: Bool = false)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "==", "params": [{"param_type": "[Key", "param_description": "", "param_name": ["lhs"]}, {"param_type": "Value]", "param_description": "", "param_name": ["[Key"]}, {"param_type": "[Key", "param_description": "", "param_name": ["rhs"]}, {"param_type": "Value]", "param_description": "", "param_name": ["[Key"]}], "class_name": "Dictionary", "method_declar": "static func == (lhs: [Key : Value], rhs: [Key : Value]) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": true}, {"method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "params": [{"param_type": "Dictionary<Key, Value>", "param_description": "A value to compare.", "param_name": ["lhs"]}, {"param_type": "Dictionary<Key, Value>", "param_description": "Another value to compare.", "param_name": ["rhs"]}], "class_name": "Dictionary", "method_declar": "static func != (lhs: Dictionary<Key, Value>, rhs: Dictionary<Key, Value>) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": true}, {"method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element of the sequence as a parameter.", "param_name": ["body"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Void", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "is_static": false}, {"method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "params": [], "class_name": "Dictionary", "method_declar": "func enumerated() -> EnumeratedSequence<Dictionary<Key, Value>>", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": ["", ""], "return_type": ["EnumeratedSequence<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func contains(where predicate: ((key: Key, value: Value)) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_name": ["predicate"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func allSatisfy(_ predicate: ((key: Key, value: Value)) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool) rethrows -> (ke", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["Value))", "throws", "->", "Bool)", "rethrows", "->", "(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func first(where predicate: ((key: Key, value: Value)) throws -> Bool) rethrows -> (key: Key, value: Value)?", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func firstIndex(where predicate: ((key: Key, value: Value)) throws -> Bool) rethrows -> Dictionary<Key, Value>.Index?", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "params": [{"param_type": "((ke", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["(key"]}, {"param_type": "Value)) throws -> Bool) rethrows -> (ke", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["Value))", "throws", "->", "Bool)", "rethrows", "->", "(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: ((key: Key, value: Value), (key: Key, value: Value)) throws -> Bool) rethrows -> (key: Key, value: Value)?", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [["key"], ["value"]], "return_type": ["Key", "Value"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "params": [{"param_type": "((ke", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["(key"]}, {"param_type": "Value)) throws -> Bool) rethrows -> (ke", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["Value))", "throws", "->", "Bool)", "rethrows", "->", "(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: ((key: Key, value: Value), (key: Key, value: Value)) throws -> Bool) rethrows -> (key: Key, value: Value)?", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [["key"], ["value"]], "return_type": ["Key", "Value"]}, "is_static": false}, {"method_description": "Returns a new dictionary containing the keys of this dictionary with the values transformed by the given closure.", "method_name": "mapValues", "params": [{"param_type": "(Value) throws -> T", "param_description": "A closure that transforms a value. transform accepts each value of the dictionary as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Dictionary", "method_declar": "func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Dictionary<Key, T>", "return_value": {"return_description": ["A dictionary containing the keys and transformed values of this dictionary."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "T>"]}, "is_static": false}, {"method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_name": ["initialResult"]}, {"param_type": "(Result", "param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_name": ["nextPartialResult"]}, {"param_type": "Key", "param_description": "", "param_name": ["(key"]}, {"param_type": "Value)) throws -> Result", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, (key: Key, value: Value)) throws -> Result) rethrows -> Result", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "((ke", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> T", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func map<T>(_ transform: ((key: Key, value: Value)) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T]"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "((ke", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> T", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func map<T>(_ transform: ((key: Key, value: Value)) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T]"]}, "is_static": false}, {"method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "params": [{"param_type": "((ke", "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_name": ["transform"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> ElementOfResult", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func compactMap<ElementOfResult>(_ transform: ((key: Key, value: Value)) throws -> ElementOfResult?) rethrows -> [ElementOfResult]", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["[ElementOfResult]"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "params": [{"param_type": "((ke", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["(key"]}, {"param_type": "Value)) throws -> Bool) rethrows -> [(ke", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["Value))", "throws", "->", "Bool)", "rethrows", "->", "[(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func sorted(by areInIncreasingOrder: ((key: Key, value: Value), (key: Key, value: Value)) throws -> Bool) rethrows -> [(key: Key, value: Value)]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "params": [{"param_type": "Key", "param_description": "", "param_name": [")", "->", "[(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func shuffled() -> [(key: Key, value: Value)]", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "params": [{"param_type": "inout RandomNumberGenerator) -> [(ke", "param_description": "The random number generator to use when shuffling the sequence.", "param_name": ["using", "generator"]}, {"param_type": "Key", "param_description": "", "param_name": ["inout", "T)", "->", "[(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func shuffled<T>(using generator: inout T) -> [(key: Key, value: Value)] where T : RandomNumberGenerator", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "((ke", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value), OtherSequence.Element) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: ((key: Key, value: Value), OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}, {"param_type": "((ke", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value), PossiblePrefix.Element) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: ((key: Key, value: Value), PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "((ke", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)", "param_description": "", "param_name": ["value"]}, {"param_type": "Key", "param_description": "", "param_name": ["(key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: ((key: Key, value: Value), (key: Key, value: Value)) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "", "method_name": "index", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "", "param_name": ["after", "i"]}], "class_name": "Dictionary", "method_declar": "func index(after i: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Index", "return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "is_static": false}, {"method_description": "Replaces the given index with its successor.", "method_name": "formIndex", "params": [{"param_type": "inout Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection. i must be less than endIndex.", "param_name": ["after", "i"]}], "class_name": "Dictionary", "method_declar": "func formIndex(after i: inout Dictionary<Key, Value>.Index)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "Dictionary", "method_declar": "func index(_ i: Dictionary<Key, Value>.Index, offsetBy distance: Int) -> Dictionary<Key, Value>.Index", "return_value": {"return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "params": [{"param_type": "inout Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "Dictionary", "method_declar": "func formIndex(_ i: inout Dictionary<Key, Value>.Index, offsetBy distance: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Dictionary", "method_declar": "func index(_ i: Dictionary<Key, Value>.Index, offsetBy distance: Int, limitedBy limit: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Index?", "return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Index"]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "params": [{"param_type": "inout Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Dictionary", "method_declar": "func formIndex(_ i: inout Dictionary<Key, Value>.Index, offsetBy distance: Int, limitedBy limit: Dictionary<Key, Value>.Index) -> Bool", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the distance between two indices.", "method_name": "distance", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "A valid index of the collection.", "param_name": ["from", "start"]}, {"param_type": "Dictionary<Key, Value>.Index", "param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_name": ["to", "end"]}], "class_name": "Dictionary", "method_declar": "func distance(from start: Dictionary<Key, Value>.Index, to end: Dictionary<Key, Value>.Index) -> Int", "return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Dictionary", "method_declar": "func prefix(_ maxLength: Int) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "", "param_name": ["through", "position"]}], "class_name": "Dictionary", "method_declar": "func prefix(through position: Dictionary<Key, Value>.Index) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_name": ["upTo", "end"]}], "class_name": "Dictionary", "method_declar": "func prefix(upTo end: Dictionary<Key, Value>.Index) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func prefix(while predicate: ((key: Key, value: Value)) throws -> Bool) rethrows -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. The value of maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Dictionary", "method_declar": "func suffix(_ maxLength: Int) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "params": [{"param_type": "Dictionary<Key, Value>.Index", "param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_name": ["from", "start"]}], "class_name": "Dictionary", "method_declar": "func suffix(from start: Dictionary<Key, Value>.Index) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Dictionary", "method_declar": "func dropFirst(_ k: Int = 1) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "params": [{"param_type": "((ke", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func drop(while predicate: ((key: Key, value: Value)) throws -> Bool) rethrows -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": [], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Dictionary", "method_declar": "func dropLast(_ k: Int = 1) -> Slice<Dictionary<Key, Value>>", "return_value": {"return_description": ["A subsequence that leaves off the specified number of elements at the end."], "return_name": ["", ""], "return_type": ["Slice<Dictionary<Key", "Value>>"]}, "is_static": false}, {"method_description": "Removes and returns the first key-value pair of the dictionary if the dictionary isn\u2019t empty.", "method_name": "popFirst", "params": [], "class_name": "Dictionary", "method_declar": "mutating func popFirst() -> Dictionary<Key, Value>.Element?", "return_value": {"return_description": ["The first key-value pair of the dictionary if the dictionary is not empty; otherwise, nil."], "return_name": ["", ""], "return_type": ["Dictionary<Key", "Value>.Element"]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "params": [{"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool", "param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_name": ["omittingEmptySubsequences"]}, {"param_type": "((ke", "param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_name": ["whereSeparator", "isSeparator"]}, {"param_type": "Key", "param_description": "", "param_name": ["((key"]}, {"param_type": "Value)) throws -> Bool", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: ((key: Key, value: Value)) throws -> Bool) rethrows -> [Slice<Dictionary<Key, Value>>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns an array containing the elements of this sequence in reverse order.", "method_name": "reversed", "params": [{"param_type": "Key", "param_description": "", "param_name": [")", "->", "[(key"]}, {"param_type": "Value", "param_description": "", "param_name": ["value"]}], "class_name": "Dictionary", "method_declar": "func reversed() -> [(key: Key, value: Value)]", "return_value": {"return_description": ["An array containing the elements of this sequence in reverse order."], "return_name": [["[key"], ["value"]], "return_type": ["Key", "Value]"]}, "is_static": false}, {"method_description": "Encodes the contents of this dictionary into the given encoder.", "method_name": "encode", "params": [{"param_type": "Encoder", "param_description": "The encoder to write data to.", "param_name": ["to", "encoder"]}], "class_name": "Dictionary", "method_declar": "func encode(to encoder: Encoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "params": [{"param_type": "inout Hasher", "param_description": "The hasher to use when combining the components of this instance.", "param_name": ["into", "hasher"]}], "class_name": "Dictionary", "method_declar": "func hash(into hasher: inout Hasher)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}], "class_inherit_list": [], "class_name": "Dictionary", "typealias": [], "Vars": [{"var_description": "A Boolean value that indicates whether the dictionary is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "A Boolean value that indicates whether the dictionary is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "The number of key-value pairs in the dictionary.", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The number of key-value pairs in the dictionary.", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The total number of key-value pairs that the dictionary can contain without allocating new storage.", "var_type": "Int", "is_static": false, "var_name": "capacity"}, {"var_description": "A collection containing just the keys of the dictionary.", "var_type": "Dictionary<Key,", "is_static": false, "var_name": "keys"}, {"var_description": "A collection containing just the values of the dictionary.", "var_type": "Dictionary<Key,", "is_static": false, "var_name": "values"}, {"var_description": "The first element of the collection.", "var_type": "(key", "is_static": false, "var_name": "first"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<Dictionary<Key,", "is_static": false, "var_name": "lazy"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "The position of the first element in a nonempty dictionary.", "var_type": "Dictionary<Key,", "is_static": false, "var_name": "startIndex"}, {"var_description": "The dictionary\u2019s \u201cpast the end\u201d position\u2014that is, the position one greater than the last valid subscript argument.", "var_type": "Dictionary<Key,", "is_static": false, "var_name": "endIndex"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<Dictionary<Key,", "is_static": false, "var_name": "indices"}, {"var_description": "A string that represents the contents of the dictionary.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A string that represents the contents of the dictionary, suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the dictionary.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}, {"var_description": "", "var_type": "MLDataValue", "is_static": false, "var_name": "dataValue"}, {"var_description": "The kind of machine learning data value to which the dictionary may be converted.", "var_type": "MLDataValue.ValueType", "is_static": false, "var_name": "dataValueType"}], "class_type": "struct", "interface_list": ["Collection", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "CVarArg", "Decodable", "Encodable", "Equatable", "ExpressibleByDictionaryLiteral", "Hashable", "MLDataValueConvertible", "Sequence"], "package_name": "foundation", "subclass_list": []}