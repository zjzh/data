{"class_description": "Each process has a single, shared ProcessInfo object, known as a process information agent.\nThe process information agent can return information such as arguments, environment variables, host name, and process name. The processInfo class method returns the shared agent for the current process\u2014that is, the process whose object sent the message. For example, the following line returns the ProcessInfo object, which then provides the name of the current process:\nNote\nProcessInfo is thread-safe in macOS 10.7 and later.\nThe ProcessInfo class also includes the operatingSystem() method, which returns an enum constant identifying the operating system on which the process is executing.\nProcessInfo objects attempt to interpret environment variables and command-line arguments in the user's default C string encoding if they cannot be converted to Unicode as UTF-8 strings. If neither the Unicode nor C string conversion works, these values are ignored by the ProcessInfo object.\nThe system has heuristics to improve battery life, performance, and responsiveness of applications for the benefit of the user. You can use the following methods to manage activities that give hints to the system that your application has special requirements:\nbeginActivity(options:reason:)\nendActivity(_:)\nperformActivity(options:reason:using:)\nIn response to creating an activity, the system will disable some or all of the heuristics so your application can finish quickly while still providing responsive behavior if the user needs it.\nYou use activities when your application is performing a long-running operation. If the activity can take different amounts of time (for example, calculating the next move in a chess game), it should use this API. This will ensure correct behavior when the amount of data or the capabilities of the user's computer varies. You should put your activity into one of two major categories:\nUser initiated: These are finite length activities that the user has explicitly started. Examples include exporting or downloading a user specified file.\nBackground: These are finite length activities that are part of the normal operation of your application but are not explicitly started by the user. Examples include autosaving, indexing, and automatic downloading of files.\nIn addition, if your application requires high priority I/O, you can include the latencyCritical flag (using a bitwise OR). You should only use this flag for activities like audio or video recording that really do require high priority.\nIf your activity takes place synchronously inside an event callback on the main thread, you do not need to use this API.\nBe aware that failing to end these activities for an extended period of time can have significant negative impacts to the performance of your user's computer, so be sure to use only the minimum amount of time required. User preferences may override your application\u2019s request.\nYou can also use this API to control automatic termination or sudden termination (see Sudden Termination). For example:\nis equivalent to:\nBecause this API returns an object, it may be easier to pair begins and ends than when using the automatic termination API\u2014if the object is deallocated before the endActivity(_:) call, the activity will be automatically ended.\nThis API also provides a mechanism to disable system-wide idle sleep and display idle sleep. These can have a large impact on the user experience, so be sure not to forget to end activities that disable sleep (including userInitiated).\nmacOS 10.6 and later includes a mechanism that allows the system to log out or shut down more quickly by, whenever possible, killing applications instead of requesting that they quit themselves. \nYour application can enable this capability on a global basis and then manually override its availability during actions that could cause data corruption or a poor user experience by allowing sudden termination. Alternately, your application can just manually enable and disable this functionality. \nThe methods enableSuddenTermination() and disableSuddenTermination() decrement or increment, respectively, a counter whose value is 1 when the process is first created. When the counter's value is 0 the application is considered to be safely killable and may be killed by the system without any notification or event being sent to the process first.\nYour application can support sudden termination upon launch by adding a key to the application\u2019s Info.plist. If the NSSupportsSuddenTermination key exists in the Info.plist and has a value of true, it is the equivalent of calling enableSuddenTermination() during your application launch. This renders the application process killable right away. You can still override this behavior by invoking disableSuddenTermination().\nTypically, you disable sudden termination whenever your application defers work that must be done before the application terminates. If, for example, your application defers writing data to disk, and sudden termination is enabled, you should bracket the sensitive operations with a call to disableSuddenTermination(), perform the necessary operations, and then send a balancing enableSuddenTermination() message.\nIn agents or daemon executables that don't depend on AppKit you can manually invoke enableSuddenTermination() right away. You can then use the enable and disable methods whenever the process has work it must do before it terminates.\nSome AppKit functionality automatically disables sudden termination on a temporary basis to ensure data integrity.\nUserDefaults temporarily disables sudden termination to prevent process killing between the time at which a default has been set and the time at which the preferences file including that default has been written to disk.\nNSDocument temporarily disables sudden termination to prevent process killing between the time at which the user has made a change to a document and the time at which the user's change has been written to disk.\nDebugging tip\nYou can determine the value of the sudden termination using the following LLDB command.\nDo not attempt to invoke or override suddenTerminationDisablingCount (a private method) in your application. It is there just for this debugging purpose, and may disappear at any time. \nIn macOS, use the current thermal state to determine if your app should reduce system usage. In macOS 10.10.3 and later, you can register for the thermalStateDidChangeNotification to be notified when the thermal state changes. Use thermalState to query the current state. Your app should reduce system usage at higher thermal states. For recommended actions, see ProcessInfo.ThermalState.\n", "Methods": [], "class_inherit_list": ["NSObject"], "class_name": "ProcessInfo", "typealias": [], "Vars": [{"var_description": "Posted when the power state (Low Power Mode is enabled or disabled) of an iOS device changes. ", "var_type": "NSNotification.Name", "is_static": false, "var_name": "NSProcessInfoPowerStateDidChange"}], "class_type": "class", "interface_list": ["CVarArg", "Equatable", "Hashable"], "package_name": "foundation", "subclass_list": []}