{"subclass_list": [], "typealias": [], "class_inherit_list": ["URLSessionTaskDelegate"], "Methods": [{"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_description": "Tells the delegate that the data task received the initial reply (headers) from the server.", "is_static": false, "method_name": "urlSession", "class_name": "URLSessionDataDelegate", "method_declar": "optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)", "params": [{"param_type": "URLSession", "param_description": "The session containing the data task that received an initial reply.", "param_name": ["session"]}, {"param_type": "URLSessionDataTask", "param_description": "The data task that received an initial reply.", "param_name": ["dataTask"]}, {"param_type": "URLResponse", "param_description": "A URL response object populated with headers.", "param_name": ["didReceive", "response"]}, {"param_type": "@escaping (URLSession.ResponseDisposition) -> Void", "param_description": "A completion handler that your code calls to continue a transfer, passing a URLSession.ResponseDisposition constant to indicate whether the transfer should continue as a data task or should become a download task.If you pass URLSession.ResponseDisposition.allow, the task continues as a data task.If you pass URLSession.ResponseDisposition.cancel, the task is canceled.If you pass URLSession.ResponseDisposition.becomeDownload, your delegate\u2019s urlSession(_:dataTask:didBecome:) method is called to provide the new download task that supersedes the current task.", "param_name": ["completionHandler"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Tells the delegate that the data task was changed to a download task.", "is_static": false, "method_name": "urlSession", "class_name": "URLSessionDataDelegate", "method_declar": "optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didBecome downloadTask: URLSessionDownloadTask)", "params": [{"param_type": "URLSession", "param_description": "The session containing the task that was replaced by a download task.", "param_name": ["session"]}, {"param_type": "URLSessionDataTask", "param_description": "The data task that was replaced by a download task.", "param_name": ["dataTask"]}, {"param_type": "URLSessionDownloadTask", "param_description": "The new download task that replaced the data task.", "param_name": ["didBecome", "downloadTask"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Tells the delegate that the data task was changed to a stream task.", "is_static": false, "method_name": "urlSession", "class_name": "URLSessionDataDelegate", "method_declar": "optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didBecome streamTask: URLSessionStreamTask)", "params": [{"param_type": "URLSession", "param_description": "The session containing the task that was replaced by a stream task.", "param_name": ["session"]}, {"param_type": "URLSessionDataTask", "param_description": "The data task that was replaced by a stream task.", "param_name": ["dataTask"]}, {"param_type": "URLSessionStreamTask", "param_description": "The new stream task that replaced the data task.", "param_name": ["didBecome", "streamTask"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Tells the delegate that the data task has received some of the expected data.", "is_static": false, "method_name": "urlSession", "class_name": "URLSessionDataDelegate", "method_declar": "optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)", "params": [{"param_type": "URLSession", "param_description": "The session containing the data task that provided data.", "param_name": ["session"]}, {"param_type": "URLSessionDataTask", "param_description": "The data task that provided data.", "param_name": ["dataTask"]}, {"param_type": "Data", "param_description": "A data object containing the transferred data.", "param_name": ["didReceive", "data"]}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_description": "Asks the delegate whether the data (or upload) task should store the response in the cache.", "is_static": false, "method_name": "urlSession", "class_name": "URLSessionDataDelegate", "method_declar": "optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -> Void)", "params": [{"param_type": "URLSession", "param_description": "The session containing the data (or upload) task.", "param_name": ["session"]}, {"param_type": "URLSessionDataTask", "param_description": "The data (or upload) task.", "param_name": ["dataTask"]}, {"param_type": "CachedURLResponse", "param_description": "The default caching behavior. This behavior is determined based on the current caching policy and the values of certain received headers, such as the Pragma and Cache-Control headers.", "param_name": ["willCacheResponse", "proposedResponse"]}, {"param_type": "@escaping (CachedURLResponse) -> Void", "param_description": "A block that your handler must call, providing either the original proposed response, a modified version of that response, or NULL to prevent caching the response. If your delegate implements this method, it must call this completion handler; otherwise, your app leaks memory.", "param_name": ["completionHandler"]}]}], "class_type": "protocol", "class_name": "URLSessionDataDelegate", "Vars": [], "interface_list": [], "class_description": "Your session delegate should also implement the methods in the URLSessionTaskDelegate protocol to handle task-level events that are common to all task types, and methods in the URLSessionDelegate protocol to handle session-level events.\nNote\nA URLSession object need not have a delegate. If no delegate is assigned, when you create tasks in that session, you must provide a completion handler block to obtain the data.\nCompletion handler blocks are primarily intended as an alternative to using a custom delegate. If you create a task using a method that takes a completion handler block, the delegate methods for response and data delivery are not called.\n", "package_name": "foundation"}