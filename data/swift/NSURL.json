{"class_description": "You can use URL objects to construct URLs and access their parts. For URLs that represent local files, you can also manipulate properties of those files directly, such as changing the file\u2019s last modification date. Finally, you can pass URL objects to other APIs to retrieve the contents of those URLs. For example, you can use the URLSession, NSURLConnection, and NSURLDownload classes to access the contents of remote resources, as described in URL Session Programming Guide.\nURL objects are the preferred way to refer to local files. Most objects that read data from or write data to a file have methods that accept an NSURL object instead of a pathname as the file reference. For example, you can get the contents of a local file URL as an NSString object using the init(contentsOf:encoding:) initializer, or as an NSData object using the init(contentsOf:options:) initializer.\nYou can also use URLs for interapplication communication. In macOS, the NSWorkspace class provides the open(_:) method to open a location specified by a URL. Similarly, in iOS, the UIApplication class provides the open(_:options:completionHandler:) method.\nAdditionally, you can use URLs when working with pasteboards, as described in NSURL Additions Reference (part of the AppKit framework).\nThe NSURL class is \u201ctoll-free bridged\u201d with its Core Foundation counterpart, CFURL. See Toll-Free Bridging for more information on toll-free bridging.\nImportant\nThe Swift overlay to the Foundation framework provides the URL structure, which bridges to the NSURL class. For more information about value types, see Classes and Structures in The Swift Programming Language (Swift 4.1) and Working with Cocoa Frameworks in Using Swift with Cocoa and Objective-C (Swift 4.1).\nAn NSURL object is composed of two parts\u2014a potentially nil base URL and a string that is resolved relative to the base URL. An NSURL object is considered absolute if its string part is fully resolved without a base; all other URLs are considered relative.\nFor example, when constructing an NSURL object, you might specify file:///path/to/user/ as the base URL and folder/file.html as the string part, as follows:\nWhen fully resolved, the absolute URL is file:///path/to/user/folder/file.html.\nA URL can be also be divided into pieces based on its structure. For example, the URL https://johnny:p4ssw0rd@www.example.com:443/script.ext;param=value?query=value#ref contains the following URL components:\nComponent\nValue\nscheme\nhttps\nuser\njohnny\npassword\np4ssw0rd\nhost\nwww.example.com\nport\n443\npath\n/script.ext\npathExtension\next\npathComponents\n[\"/\", \"script.ext\"]\nparameterString\nparam=value\nquery\nquery=value\nfragment\nref\nThe NSURL class provides properties that let you examine each of these components.\nNote\nThe URLs employed by the NSURL class are described in RFC 1808, RFC 1738, and RFC 2732.\nStarting with OS X v10.6 and iOS 4.0, the NSURL class provides a facility for creating and using bookmark objects. A bookmark provides a persistent reference to a file-system resource. When you resolve a bookmark, you obtain a URL to the resource\u2019s current location. A bookmark\u2019s association with a file-system resource (typically a file or folder) usually continues to work if the user moves or renames the resource, or if the user relaunches your app or restarts the system.\nFor a general introduction to using bookmarks, read Locating Files Using Bookmarks in File System Programming Guide.\nIn a macOS app that adopts App Sandbox, you can use security-scoped bookmarks to gain access to file-system resources outside your app\u2019s sandbox. These bookmarks preserve the user\u2019s intent to give your app access to a resource across app launches. For details on how this works, including information on the entitlements you need in your Xcode project, read Security-Scoped Bookmarks and Persistent Resource Access in App Sandbox Design Guide. The methods for using security-scoped bookmarks are described in this document in Working with Bookmark Data. \nWhen you resolve a security-scoped bookmark, you get a security-scoped URL.\nSecurity-scoped URLs provide access to resources outside an app\u2019s sandbox. In macOS, you get access to security-scoped URLs when you resolve a security-scoped bookmark. In iOS, apps that open or move documents using a UIDocumentPickerViewController also receive security-scoped URLs.\nTo gain access to a security-scoped URL, you must call the startAccessingSecurityScopedResource() method (or its Core Foundation equivalent, the CFURLStartAccessingSecurityScopedResource(_:) function). For iOS apps, if you use a UIDocument to access the URL, it automatically manages the security-scoped URL for you.\nIf startAccessingSecurityScopedResource (or CFUrLStartAccessingSecurityScopedResource) returns true, you must relinquish your access by calling the\u00a0stopAccessingSecurityScopedResource()\u00a0method (or its Core Foundation equivalent, the CFURLStopAccessingSecurityScopedResource(_:) function). You should relinquish your access as soon as you have finished using the file. After you call these methods, you immediately lose access to the resource in question.\nWarning\nIf you fail to relinquish your access when you no longer need a file-system resource, your app leaks kernel resources. If sufficient kernel resources are leaked, your app loses its ability to add file-system locations to its sandbox, using Powerbox, security-scoped bookmarks, or similar APIs, until relaunched.\nIn a macOS app, when you copy a security-scoped URL, the copy has the security scope of the original. You gain access to the file-system resource (that the URL points to) just as you would with the original URL: by calling the startAccessingSecurityScopedResource() method (or its Core Foundation equivalent).\nIf you need a security-scoped URL\u2019s path as a string value (as provided by the path method), such as to provide to an API that requires a string value, obtain the path from the URL as needed. Note, however, that a string-based path obtained from a security-scoped URL does not have security scope and you cannot use that string to obtain access to a security-scoped resource.\nWith OS X v10.10 and iOS 8.0, the NSURL class includes the ability to get and set document thumbnails as a resource property for iCloud documents. You can get a dictionary of NSImage objects in macOS or UIImage objects in iOS using the getResourceValue(_:forKey:) or getPromisedItemResourceValue(_:forKey:) methods.\nIn macOS, you can set a dictionary of thumbnails using the setResourceValue(_:forKey:) method. You can also get or set all the thumbnails as an NSImage object with multiple representations by using the thumbnailKey.\nNote\nDo not set the thumbnailDictionaryKey key directly. Modifying this key interferes with document tracking and can create duplicates of your document, as well as other possible problems. \nIn iOS, use a UIDocument subclass to manage your file. Set the thumbnail by overriding the document\u2019s fileAttributesToWrite(to:for:) method and returning a dictionary that contains the proper thumbnail keys (along with any other file attributes). \nIn macOS, follow the instructions for creating thumbnails given in Quick Look Programming Guide.\nNote\nAlthough the thumbnail API is designed to support multiple image resolutions, currently it only supports 1024 x 1024 pixel thumbnails.\n", "Methods": [{"method_description": "Initializes an NSURL object with a provided URL string.", "method_name": "init", "params": [{"param_type": "String", "param_description": "The URL string with which to initialize the NSURL object. This URL string must conform to URL format as described in RFC 2396, and must not be nil. This method parses URLString according to RFCs 1738 and 1808.", "param_name": ["string", "URLString"]}], "class_name": "NSURL", "method_declar": "convenience init?(string URLString: String)", "return_value": {"return_description": ["An NSURL object initialized with URLString. If the URL string was malformed, returns nil."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes an NSURL object with a base URL and a relative string.", "method_name": "init", "params": [{"param_type": "String", "param_description": "The URL string with which to initialize the NSURL object. Must conform to RFC 2396. URLString is interpreted relative to baseURL.", "param_name": ["string", "URLString"]}, {"param_type": "URL", "param_description": "The base URL for the NSURL object.", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "init?(string URLString: String, relativeTo baseURL: URL?)", "return_value": {"return_description": ["An NSURL object initialized with URLString and baseURL. If URLString was malformed, returns nil."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes and returns a newly created NSURL object as a file URL with a specified path.", "method_name": "fileURL", "params": [{"param_type": "String", "param_description": "The path that the NSURL object will represent. path should be a valid system path, and must not be an empty path. If path begins with a tilde, it must first be expanded with expandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.", "param_name": ["withPath", "path"]}, {"param_type": "Bool", "param_description": "A Boolean value that specifies whether path is treated as a directory path when resolving against relative path components. Pass true if the path indicates a directory, false otherwise.", "param_name": ["isDirectory", "isDir"]}], "class_name": "NSURL", "method_declar": "class func fileURL(withPath path: String, isDirectory isDir: Bool) -> URL", "return_value": {"return_description": ["An NSURL object initialized with path."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Initializes a newly created NSURL referencing the local file or directory at path.", "method_name": "init", "params": [{"param_type": "String", "param_description": "The path that the NSURL object will represent. path should be a valid system path, and must not be an empty path. If path begins with a tilde, it must first be expanded with expandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.", "param_name": ["fileURLWithPath", "path"]}, {"param_type": "Bool", "param_description": "A Boolean value that specifies whether path is treated as a directory path when resolving against relative path components. Pass true if the path indicates a directory, false otherwise", "param_name": ["isDirectory", "isDir"]}], "class_name": "NSURL", "method_declar": "init(fileURLWithPath path: String, isDirectory isDir: Bool)", "return_value": {"return_description": ["An NSURL object initialized with path."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "fileURL", "params": [{"param_type": "String", "param_description": "", "param_name": ["withPath", "path"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "class func fileURL(withPath path: String, relativeTo baseURL: URL?) -> URL", "return_value": {"return_description": [], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "String", "param_description": "", "param_name": ["fileURLWithPath", "path"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "init(fileURLWithPath path: String, relativeTo baseURL: URL?)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "fileURL", "params": [{"param_type": "String", "param_description": "", "param_name": ["withPath", "path"]}, {"param_type": "Bool", "param_description": "", "param_name": ["isDirectory", "isDir"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "class func fileURL(withPath path: String, isDirectory isDir: Bool, relativeTo baseURL: URL?) -> URL", "return_value": {"return_description": [], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "String", "param_description": "", "param_name": ["fileURLWithPath", "path"]}, {"param_type": "Bool", "param_description": "", "param_name": ["isDirectory", "isDir"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "init(fileURLWithPath path: String, isDirectory isDir: Bool, relativeTo baseURL: URL?)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes and returns a newly created NSURL object as a file URL with a specified path.", "method_name": "fileURL", "params": [{"param_type": "String", "param_description": "The path that the NSURL object will represent. path should be a valid system path, and must not be an empty path. If path begins with a tilde, it must first be expanded with expandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.", "param_name": ["withPath", "path"]}], "class_name": "NSURL", "method_declar": "class func fileURL(withPath path: String) -> URL", "return_value": {"return_description": ["An NSURL object initialized with path."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Initializes a newly created NSURL referencing the local file or directory at path.", "method_name": "init", "params": [{"param_type": "String", "param_description": "The path that the NSURL object will represent. path should be a valid system path, and must not be an empty path. If path begins with a tilde, it must first be expanded with expandingTildeInPath. If path is a relative path, it is treated as being relative to the current working directory.", "param_name": ["fileURLWithPath", "path"]}], "class_name": "NSURL", "method_declar": "init(fileURLWithPath path: String)", "return_value": {"return_description": ["An NSURL object initialized with path."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes and returns a newly created NSURL object as a file URL with specified path components.", "method_name": "fileURL", "params": [{"param_type": "[String]", "param_description": "An array of path components.", "param_name": ["withPathComponents", "components"]}], "class_name": "NSURL", "method_declar": "class func fileURL(withPathComponents components: [String]) -> URL?", "return_value": {"return_description": ["An NSURL object initialized with components."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Returns a new URL made by resolving the alias file at url.", "method_name": "init", "params": [{"param_type": "URL", "param_description": "The URL pointing to the alias file.", "param_name": ["resolvingAliasFileAt", "url"]}, {"param_type": "NSURL.BookmarkResolutionOptions = []", "param_description": "Options taken into account when resolving the bookmark data. The withSecurityScope option is not supported by this method.", "param_name": ["options"]}], "class_name": "NSURL", "method_declar": "convenience init(resolvingAliasFileAt url: URL, options: NSURL.BookmarkResolutionOptions = []) throws", "return_value": {"return_description": ["A new URL created by resolving the bookmark data derived from the provided alias file. If an error occurs, this method returns nil. "], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes a newly created NSURL that points to a location specified by resolving bookmark data.", "method_name": "init", "params": [{"param_type": "Data", "param_description": "The bookmark data the URL is derived from.", "param_name": ["resolvingBookmarkData", "bookmarkData"]}, {"param_type": "NSURL.BookmarkResolutionOptions", "param_description": "Options taken into account when resolving the bookmark data.", "param_name": ["options"]}, {"param_type": "URL", "param_description": "The base URL that the bookmark data is relative to.", "param_name": ["relativeTo", "relativeURL"]}, {"param_type": "UnsafeMutablePointer<ObjCBool>", "param_description": "If true, the bookmark data is stale.", "param_name": ["bookmarkDataIsStale", "isStale"]}], "class_name": "NSURL", "method_declar": "convenience init(resolvingBookmarkData bookmarkData: Data, options: NSURL.BookmarkResolutionOptions = [], relativeTo relativeURL: URL?, bookmarkDataIsStale isStale: UnsafeMutablePointer<ObjCBool>?) throws", "return_value": {"return_description": ["An NSURL initialized by resolving bookmarkData."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new URL object initialized with a C string representing a local file system path.", "method_name": "fileURL", "params": [{"param_type": "UnsafePointer<Int8>", "param_description": "A null-terminated C string in file system representation containing the path to represent as a URL. If this path is a relative path, it is treated as being relative to the current working directory.", "param_name": ["withFileSystemRepresentation", "path"]}, {"param_type": "Bool", "param_description": "true if the last path part is a directory, otherwise false.", "param_name": ["isDirectory", "isDir"]}, {"param_type": "URL", "param_description": "The base URL for the new URL object. This must be a file URL. If path is absolute, this URL is ignored.", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "class func fileURL(withFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory isDir: Bool, relativeTo baseURL: URL?) -> URL", "return_value": {"return_description": ["Returns the new object."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Fills the provided buffer with a C string representing a local file system path.", "method_name": "getFileSystemRepresentation", "params": [{"param_type": "UnsafeMutablePointer<Int8>", "param_description": "A buffer large enough to hold the path. On return, contains a null-terminated C string in file system representation.", "param_name": ["buffer"]}, {"param_type": "Int", "param_description": "The size of buffer in bytes (typically MAXPATHLEN or PATH_MAX).", "param_name": ["maxLength", "maxBufferLength"]}], "class_name": "NSURL", "method_declar": "func getFileSystemRepresentation(_ buffer: UnsafeMutablePointer<Int8>, maxLength maxBufferLength: Int) -> Bool", "return_value": {"return_description": ["Returns true if the URL could be converted into a file system representation, otherwise false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Initializes a URL object with a C string representing a local file system path.", "method_name": "init", "params": [{"param_type": "UnsafePointer<Int8>", "param_description": "A null-terminated C string in file system representation containing the path to represent as a URL. If this path is a relative path, it is treated as being relative to the current working directory.", "param_name": ["fileURLWithFileSystemRepresentation", "path"]}, {"param_type": "Bool", "param_description": "true if the last path part is a directory, otherwise false.", "param_name": ["isDirectory", "isDir"]}, {"param_type": "URL", "param_description": "The base URL for the new URL object. This must be a file URL. If path is absolute, this URL is ignored.", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory isDir: Bool, relativeTo baseURL: URL?)", "return_value": {"return_description": ["Returns the initialized object."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "absoluteURL", "params": [{"param_type": "Data", "param_description": "", "param_name": ["withDataRepresentation", "data"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "class func absoluteURL(withDataRepresentation data: Data, relativeTo baseURL: URL?) -> URL", "return_value": {"return_description": [], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "Data", "param_description": "", "param_name": ["absoluteURLWithDataRepresentation", "data"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "init(absoluteURLWithDataRepresentation data: Data, relativeTo baseURL: URL?)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "Data", "param_description": "", "param_name": ["dataRepresentation", "data"]}, {"param_type": "URL", "param_description": "", "param_name": ["relativeTo", "baseURL"]}], "class_name": "NSURL", "method_declar": "init(dataRepresentation data: Data, relativeTo baseURL: URL?)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns whether the resource pointed to by a file URL can be reached.", "method_name": "checkResourceIsReachableAndReturnError", "params": [{"param_type": "NSErrorPointer", "param_description": "The error that occurred when the resource could not be reached.", "param_name": ["error"]}], "class_name": "NSURL", "method_declar": "func checkResourceIsReachableAndReturnError(_ error: NSErrorPointer) -> Bool", "return_value": {"return_description": ["true if the resource is reachable; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns whether the URL is a file reference URL.", "method_name": "isFileReferenceURL", "params": [], "class_name": "NSURL", "method_declar": "func isFileReferenceURL() -> Bool", "return_value": {"return_description": ["true if the URL is a file reference URL; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns the resource values for the properties identified by specified array of keys.", "method_name": "resourceValues", "params": [{"param_type": "[URLResourceKey]", "param_description": "An array of property keys for the desired resource properties.", "param_name": ["forKeys", "keys"]}], "class_name": "NSURL", "method_declar": "func resourceValues(forKeys keys: [URLResourceKey]) throws -> [URLResourceKey : Any]", "return_value": {"return_description": ["A dictionary of resource values indexed by key."], "return_name": [["[URLResourceKey"]], "return_type": ["Any"]}, "is_static": false}, {"method_description": "Returns the value of the resource property for the specified key.", "method_name": "getResourceValue", "params": [{"param_type": "AutoreleasingUnsafeMutablePointer<AnyObject>", "param_description": "The location where the value for the resource property identified by key should be stored.", "param_name": ["value"]}, {"param_type": "URLResourceKey", "param_description": "The name of one of the URL\u2019s resource properties.", "param_name": ["forKey", "key"]}], "class_name": "NSURL", "method_declar": "func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer<AnyObject?>, forKey key: URLResourceKey) throws", "return_value": {"return_description": ["true if value is successfully populated; otherwise, false."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Sets the URL\u2019s resource property for a given key to a given value.", "method_name": "setResourceValue", "params": [{"param_type": "Any", "param_description": "The value for the resource property defined by key.", "param_name": ["value"]}, {"param_type": "URLResourceKey", "param_description": "The name of one of the URL\u2019s resource properties.", "param_name": ["forKey", "key"]}], "class_name": "NSURL", "method_declar": "func setResourceValue(_ value: Any?, forKey key: URLResourceKey) throws", "return_value": {"return_description": ["true if the resource property named key is successfully set to value; otherwise, false."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Sets the URL\u2019s resource properties for a given set of keys to a given set of values.", "method_name": "setResourceValues", "params": [{"param_type": "[URLResourceKey", "param_description": "A dictionary of resource values to be set.", "param_name": ["keyedValues"]}, {"param_type": "Any]", "param_description": "", "param_name": ["[URLResourceKey"]}], "class_name": "NSURL", "method_declar": "func setResourceValues(_ keyedValues: [URLResourceKey : Any]) throws", "return_value": {"return_description": ["true if all resource values in keyedValues are successfully set; otherwise, false."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes all cached resource values and temporary resource values from the URL object.", "method_name": "removeAllCachedResourceValues", "params": [], "class_name": "NSURL", "method_declar": "func removeAllCachedResourceValues()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the cached resource value identified by a given key from the URL object.", "method_name": "removeCachedResourceValue", "params": [{"param_type": "URLResourceKey", "param_description": "The resource value key whose cached values you want to remove.", "param_name": ["forKey", "key"]}], "class_name": "NSURL", "method_declar": "func removeCachedResourceValue(forKey key: URLResourceKey)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Sets a temporary resource value on the URL object.", "method_name": "setTemporaryResourceValue", "params": [{"param_type": "Any", "param_description": "The value to store.", "param_name": ["value"]}, {"param_type": "URLResourceKey", "param_description": "The key where the value should be stored. This key must be unique and must not conflict with any system-defined keys. Reverse-domain-name notation is recommended.", "param_name": ["forKey", "key"]}], "class_name": "NSURL", "method_declar": "func setTemporaryResourceValue(_ value: Any?, forKey key: URLResourceKey)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new file reference URL that points to the same resource as the receiver.", "method_name": "fileReferenceURL", "params": [], "class_name": "NSURL", "method_declar": "func fileReferenceURL() -> URL?", "return_value": {"return_description": ["The new file reference URL."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Returns a new URL made by appending a path component to the original URL.", "method_name": "appendingPathComponent", "params": [{"param_type": "String", "param_description": "The path component to add to the URL, in its original form (not URL encoded).", "param_name": ["pathComponent"]}], "class_name": "NSURL", "method_declar": "func appendingPathComponent(_ pathComponent: String) -> URL?", "return_value": {"return_description": ["A new URL with pathComponent appended."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Returns a new URL made by appending a path component to the original URL, along with a trailing slash if the component is designated a directory.", "method_name": "appendingPathComponent", "params": [{"param_type": "String", "param_description": "The path component to add to the URL.", "param_name": ["pathComponent"]}, {"param_type": "Bool", "param_description": "If true, a trailing slash is appended after pathComponent.", "param_name": ["isDirectory"]}], "class_name": "NSURL", "method_declar": "func appendingPathComponent(_ pathComponent: String, isDirectory: Bool) -> URL?", "return_value": {"return_description": ["A new URL with pathComponent appended."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Returns a new URL made by appending a path extension to the original URL.", "method_name": "appendingPathExtension", "params": [{"param_type": "String", "param_description": "The path extension to add to the URL.", "param_name": ["pathExtension"]}], "class_name": "NSURL", "method_declar": "func appendingPathExtension(_ pathExtension: String) -> URL?", "return_value": {"return_description": ["A new URL with pathExtension appended."], "return_name": [""], "return_type": ["UR"]}, "is_static": false}, {"method_description": "Initializes and returns bookmark data derived from an alias file pointed to by a specified URL.", "method_name": "bookmarkData", "params": [{"param_type": "URL", "param_description": "The URL that points to a file containing bookmark data.", "param_name": ["withContentsOf", "bookmarkFileURL"]}], "class_name": "NSURL", "method_declar": "class func bookmarkData(withContentsOf bookmarkFileURL: URL) throws -> Data", "return_value": {"return_description": ["The bookmark data for the alias file."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a bookmark for the URL, created with specified options and resource values.", "method_name": "bookmarkData", "params": [{"param_type": "NSURL.BookmarkCreationOptions", "param_description": "Options taken into account when creating the bookmark for the URL. The possible flags (which can be combined with bitwise OR operations) are described in NSURL.BookmarkCreationOptions.To create a security-scoped bookmark to support App Sandbox, include the withSecurityScope flag. When you later resolve the bookmark, you can use the resulting security-scoped URL to obtain read/write access to the file-system resource pointed to by the URL.If you instead want to create a security-scoped bookmark that, when resolved, enables you to obtain read-only access to a file-system resource, bitwise OR this parameter\u2019s value with both the withSecurityScope option and the securityScopeAllowOnlyReadAccess option.", "param_name": ["options"]}, {"param_type": "[URLResourceKey]", "param_description": "An array of names of URL resource properties to store as part of the bookmark. You can later access these values (without resolving the bookmark) by calling the resourceValues(forKeys:fromBookmarkData:) method.The values of these properties must be of a type that the bookmark generation code can serialize. Specifically, the values can contain any of the following primitive types:NSString or CFStringNSData or CFDataNSDate or CFDateNSNumber or CFNumberCFBooleanNSURL or CFURLkCFNull or NSNullCFUUIDIn addition, the properties can contain the following collection classes:NSArray or CFArray containing only the above primitive typesNSDictionary or CFDictionary with NSString or CFString keys, in which all values contain only the above primitive types", "param_name": ["includingResourceValuesForKeys", "keys"]}, {"param_type": "URL", "param_description": "The URL that the bookmark data will be relative to.If you are creating a security-scoped bookmark to support App Sandbox, use this parameter as follows:To create an app-scoped bookmark, use a value of nil. To create a document-scoped bookmark, use the absolute path (despite this parameter\u2019s name) to the document file that is to own the new security-scoped bookmark.App Sandbox does not restrict which URL values may be passed to this parameter.", "param_name": ["relativeTo", "relativeURL"]}], "class_name": "NSURL", "method_declar": "func bookmarkData(options: NSURL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: [URLResourceKey]?, relativeTo relativeURL: URL?) throws -> Data", "return_value": {"return_description": ["A bookmark for the URL."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns the resource values for properties identified by a specified array of keys contained in specified bookmark data.", "method_name": "resourceValues", "params": [{"param_type": "[URLResourceKey]", "param_description": "An array of names of URL resource properties. In addition to the standard, system-defined resource properties, you can also request any custom properties that you provided when you created the bookmark. See the bookmarkData(options:includingResourceValuesForKeys:relativeTo:) method for details.", "param_name": ["forKeys", "keys"]}, {"param_type": "Data", "param_description": "The bookmark data from which you want to retrieve resource values.", "param_name": ["fromBookmarkData", "bookmarkData"]}], "class_name": "NSURL", "method_declar": "class func resourceValues(forKeys keys: [URLResourceKey], fromBookmarkData bookmarkData: Data) -> [URLResourceKey : Any]?", "return_value": {"return_description": ["A dictionary of the requested resource values contained in bookmarkData."], "return_name": [["[URLResourceKey"]], "return_type": ["Any"]}, "is_static": false}, {"method_description": "Creates an alias file on disk at a specified location with specified bookmark data.", "method_name": "writeBookmarkData", "params": [{"param_type": "Data", "param_description": "The bookmark data containing information for the alias file.", "param_name": ["bookmarkData"]}, {"param_type": "URL", "param_description": "The desired location of the alias file.", "param_name": ["to", "bookmarkFileURL"]}, {"param_type": "NSURL.BookmarkFileCreationOptions", "param_description": "Options taken into account when creating the alias file.", "param_name": ["options"]}], "class_name": "NSURL", "method_declar": "class func writeBookmarkData(_ bookmarkData: Data, to bookmarkFileURL: URL, options: NSURL.BookmarkFileCreationOptions) throws", "return_value": {"return_description": ["true if the alias file is successfully created; otherwise, false."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "In an app that has adopted App Sandbox, makes the resource pointed to by a security-scoped URL available to the app.", "method_name": "startAccessingSecurityScopedResource", "params": [], "class_name": "NSURL", "method_declar": "func startAccessingSecurityScopedResource() -> Bool", "return_value": {"return_description": ["true if the request to access the resource succeeded; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "In an app that adopts App Sandbox, revokes access to the resource pointed to by a security-scoped URL.", "method_name": "stopAccessingSecurityScopedResource", "params": [], "class_name": "NSURL", "method_declar": "func stopAccessingSecurityScopedResource()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns whether the promised item can be reached.", "method_name": "checkPromisedItemIsReachableAndReturnError", "params": [{"param_type": "NSErrorPointer", "param_description": "The error that occurred when the promised item could not be reached.", "param_name": ["error"]}], "class_name": "NSURL", "method_declar": "func checkPromisedItemIsReachableAndReturnError(_ error: NSErrorPointer) -> Bool", "return_value": {"return_description": ["true if the promised item is reachable; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns the value of the resource property for the specified key.", "method_name": "getPromisedItemResourceValue", "params": [{"param_type": "AutoreleasingUnsafeMutablePointer<AnyObject>", "param_description": "The location where the value for the resource property identified by key should be stored.", "param_name": ["value"]}, {"param_type": "URLResourceKey", "param_description": "The name of one of the URL\u2019s resource properties.", "param_name": ["forKey", "key"]}], "class_name": "NSURL", "method_declar": "func getPromisedItemResourceValue(_ value: AutoreleasingUnsafeMutablePointer<AnyObject?>, forKey key: URLResourceKey) throws", "return_value": {"return_description": ["true if value is successfully populated; otherwise, false."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the resource values for the properties identified by specified array of keys.", "method_name": "promisedItemResourceValues", "params": [{"param_type": "[URLResourceKey]", "param_description": "An array of names of URL resource properties.", "param_name": ["forKeys", "keys"]}], "class_name": "NSURL", "method_declar": "func promisedItemResourceValues(forKeys keys: [URLResourceKey]) throws -> [URLResourceKey : Any]", "return_value": {"return_description": ["A dictionary of resource values indexed by key."], "return_name": [["[URLResourceKey"]], "return_type": ["Any"]}, "is_static": false}, {"method_description": "Reads an NSURL object off of the specified pasteboard.", "method_name": "init", "params": [{"param_type": "NSPasteboard", "param_description": "The target pasteboard.", "param_name": ["from", "pasteBoard"]}], "class_name": "NSURL", "method_declar": "init?(from pasteBoard: NSPasteboard)", "return_value": {"return_description": ["a NSURL object, or nil if the pasteboard does not contain NSURLPboardType data."], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Writes the URL to the specified pasteboard.", "method_name": "write", "params": [{"param_type": "NSPasteboard", "param_description": "", "param_name": ["to", "pasteBoard"]}], "class_name": "NSURL", "method_declar": "func write(to pasteBoard: NSPasteboard)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes a newly created NSURL with a specified scheme, host, and path.", "method_name": "init", "params": [{"param_type": "String", "param_description": "The scheme for the NSURL object. For example, in the URL http://www.example.com/index.html, the scheme is http.", "param_name": ["scheme"]}, {"param_type": "String", "param_description": "The host for the NSURL object (for example, www.example.com). May be the empty string.", "param_name": ["host"]}, {"param_type": "String", "param_description": "The path for the NSURL object (for example, /index.html). If the path begins with a tilde, you must first expand it by calling expandingTildeInPath.", "param_name": ["path"]}], "class_name": "NSURL", "method_declar": "convenience init?(scheme: String, host: String?, path: String)", "return_value": {"return_description": ["The newly initialized NSURL object."], "return_name": [], "return_type": []}, "is_static": false}], "class_inherit_list": ["NSObject"], "class_name": "NSURL", "typealias": ["typealias BookmarkFileCreationOptions = Int"], "Vars": [{"var_description": "", "var_type": "Data", "is_static": false, "var_name": "dataRepresentation"}, {"var_description": "A boolean value that determines whether the receiver is a file URL.", "var_type": "Bool", "is_static": false, "var_name": "isFileURL"}, {"var_description": "The URL string for the receiver as an absolute URL. (read-only)", "var_type": "String", "is_static": false, "var_name": "absoluteString"}, {"var_description": "An absolute URL that refers to the same resource as the receiver. (read-only)", "var_type": "URL", "is_static": false, "var_name": "absoluteURL"}, {"var_description": "The base URL. (read-only)", "var_type": "URL", "is_static": false, "var_name": "baseURL"}, {"var_description": "A C string containing the URL\u2019s file system path. (read-only)", "var_type": "UnsafePointer<Int8>", "is_static": false, "var_name": "fileSystemRepresentation"}, {"var_description": "The fragment identifier, conforming to RFC 1808. (read-only)", "var_type": "String", "is_static": false, "var_name": "fragment"}, {"var_description": "The host, conforming to RFC 1808. (read-only)", "var_type": "String", "is_static": false, "var_name": "host"}, {"var_description": "The last path component. (read-only)", "var_type": "String", "is_static": false, "var_name": "lastPathComponent"}, {"var_description": "The parameter string conforming to RFC 1808. (read-only)", "var_type": "String", "is_static": false, "var_name": "parameterString"}, {"var_description": "The password conforming to RFC 1808. (read-only)", "var_type": "String", "is_static": false, "var_name": "password"}, {"var_description": "The path, conforming to RFC 1808. (read-only)", "var_type": "String", "is_static": false, "var_name": "path"}, {"var_description": "An array containing the  path components. (read-only)", "var_type": "[String]", "is_static": false, "var_name": "pathComponents"}, {"var_description": "The path extension. (read-only)", "var_type": "String", "is_static": false, "var_name": "pathExtension"}, {"var_description": "The port, conforming to RFC 1808.", "var_type": "NSNumber", "is_static": false, "var_name": "port"}, {"var_description": "The query string, conforming to RFC 1808.", "var_type": "String", "is_static": false, "var_name": "query"}, {"var_description": "The relative path, conforming to RFC 1808. (read-only)", "var_type": "String", "is_static": false, "var_name": "relativePath"}, {"var_description": "A string representation of the relative portion of the URL. (read-only)", "var_type": "String", "is_static": false, "var_name": "relativeString"}, {"var_description": "The resource specifier. (read-only)", "var_type": "String", "is_static": false, "var_name": "resourceSpecifier"}, {"var_description": "The scheme. (read-only)", "var_type": "String", "is_static": false, "var_name": "scheme"}, {"var_description": "A copy of the URL with any instances of \"..\" or \".\" removed from its path. (read-only)", "var_type": "URL", "is_static": false, "var_name": "standardized"}, {"var_description": "The user name, conforming to RFC 1808.", "var_type": "String", "is_static": false, "var_name": "user"}, {"var_description": "A file path URL that points to the same resource as the URL object. (read-only)", "var_type": "URL", "is_static": false, "var_name": "filePathURL"}, {"var_description": "A URL created by taking the receiver and removing the last path component. (read-only)", "var_type": "URL", "is_static": false, "var_name": "deletingLastPathComponent"}, {"var_description": "A URL created by taking the receiver and removing the path extension, if any. (read-only)", "var_type": "URL", "is_static": false, "var_name": "deletingPathExtension"}, {"var_description": "A URL that points to the same resource as the receiver and includes no symbolic links. (read-only)", "var_type": "URL", "is_static": false, "var_name": "resolvingSymlinksInPath"}, {"var_description": "A URL that points to the same resource as the original URL using an absolute path. (read-only)", "var_type": "URL", "is_static": false, "var_name": "standardizingPath"}, {"var_description": "", "var_type": "Bool", "is_static": false, "var_name": "hasDirectoryPath"}, {"var_description": "", "var_type": "PlaygroundQuickLook", "is_static": false, "var_name": "customPlaygroundQuickLook"}, {"var_description": "Identifies a URL that points to a file on a mounted volume.", "var_type": "String", "is_static": false, "var_name": "NSURLFileScheme"}, {"var_description": "Key for the resource properties that have not been set after the setResourceValues(_:) method returns an error, returned as an array of NSString objects.", "var_type": "URLResourceKey", "is_static": false, "var_name": "keysOfUnsetValuesKey"}], "class_type": "class", "interface_list": ["CustomPlaygroundQuickLookable", "CVarArg", "Equatable", "Hashable", "NSCopying", "NSItemProviderReading", "NSItemProviderWriting", "NSPasteboardReading", "NSPasteboardWriting", "NSSecureCoding", "NSURLHandleClient", "QLPreviewItem"], "package_name": "foundation", "subclass_list": []}