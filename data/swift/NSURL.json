{"class_description": "You can use URL objects to construct URLs and access their parts. For URLs that represent local files, you can also manipulate properties of those files directly, such as changing the file\u2019s last modification date. Finally, you can pass URL objects to other APIs to retrieve the contents of those URLs. For example, you can use the URLSession, NSURLConnection, and NSURLDownload classes to access the contents of remote resources, as described in URL Session Programming Guide.\nURL objects are the preferred way to refer to local files. Most objects that read data from or write data to a file have methods that accept an NSURL object instead of a pathname as the file reference. For example, you can get the contents of a local file URL as an NSString object using the init(contentsOf:encoding:) initializer, or as an NSData object using the init(contentsOf:options:) initializer.\nYou can also use URLs for interapplication communication. In macOS, the NSWorkspace class provides the open(_:) method to open a location specified by a URL. Similarly, in iOS, the UIApplication class provides the open(_:options:completionHandler:) method.\nAdditionally, you can use URLs when working with pasteboards, as described in NSURL Additions Reference (part of the AppKit framework).\nThe NSURL class is \u201ctoll-free bridged\u201d with its Core Foundation counterpart, CFURL. See Toll-Free Bridging for more information on toll-free bridging.\nImportant\nThe Swift overlay to the Foundation framework provides the URL structure, which bridges to the NSURL class. For more information about value types, see Classes and Structures in The Swift Programming Language (Swift 4.1) and Working with Cocoa Frameworks in Using Swift with Cocoa and Objective-C (Swift 4.1).\nAn NSURL object is composed of two parts\u2014a potentially nil base URL and a string that is resolved relative to the base URL. An NSURL object is considered absolute if its string part is fully resolved without a base; all other URLs are considered relative.\nFor example, when constructing an NSURL object, you might specify file:///path/to/user/ as the base URL and folder/file.html as the string part, as follows:\nWhen fully resolved, the absolute URL is file:///path/to/user/folder/file.html.\nA URL can be also be divided into pieces based on its structure. For example, the URL https://johnny:p4ssw0rd@www.example.com:443/script.ext;param=value?query=value#ref contains the following URL components:\nComponent\nValue\nscheme\nhttps\nuser\njohnny\npassword\np4ssw0rd\nhost\nwww.example.com\nport\n443\npath\n/script.ext\npathExtension\next\npathComponents\n[\"/\", \"script.ext\"]\nparameterString\nparam=value\nquery\nquery=value\nfragment\nref\nThe NSURL class provides properties that let you examine each of these components.\nNote\nThe URLs employed by the NSURL class are described in RFC 1808, RFC 1738, and RFC 2732.\nStarting with OS X v10.6 and iOS 4.0, the NSURL class provides a facility for creating and using bookmark objects. A bookmark provides a persistent reference to a file-system resource. When you resolve a bookmark, you obtain a URL to the resource\u2019s current location. A bookmark\u2019s association with a file-system resource (typically a file or folder) usually continues to work if the user moves or renames the resource, or if the user relaunches your app or restarts the system.\nFor a general introduction to using bookmarks, read Locating Files Using Bookmarks in File System Programming Guide.\nIn a macOS app that adopts App Sandbox, you can use security-scoped bookmarks to gain access to file-system resources outside your app\u2019s sandbox. These bookmarks preserve the user\u2019s intent to give your app access to a resource across app launches. For details on how this works, including information on the entitlements you need in your Xcode project, read Security-Scoped Bookmarks and Persistent Resource Access in App Sandbox Design Guide. The methods for using security-scoped bookmarks are described in this document in Working with Bookmark Data. \nWhen you resolve a security-scoped bookmark, you get a security-scoped URL.\nSecurity-scoped URLs provide access to resources outside an app\u2019s sandbox. In macOS, you get access to security-scoped URLs when you resolve a security-scoped bookmark. In iOS, apps that open or move documents using a UIDocumentPickerViewController also receive security-scoped URLs.\nTo gain access to a security-scoped URL, you must call the startAccessingSecurityScopedResource() method (or its Core Foundation equivalent, the CFURLStartAccessingSecurityScopedResource(_:) function). For iOS apps, if you use a UIDocument to access the URL, it automatically manages the security-scoped URL for you.\nIf startAccessingSecurityScopedResource (or CFUrLStartAccessingSecurityScopedResource) returns true, you must relinquish your access by calling the\u00a0stopAccessingSecurityScopedResource()\u00a0method (or its Core Foundation equivalent, the CFURLStopAccessingSecurityScopedResource(_:) function). You should relinquish your access as soon as you have finished using the file. After you call these methods, you immediately lose access to the resource in question.\nWarning\nIf you fail to relinquish your access when you no longer need a file-system resource, your app leaks kernel resources. If sufficient kernel resources are leaked, your app loses its ability to add file-system locations to its sandbox, using Powerbox, security-scoped bookmarks, or similar APIs, until relaunched.\nIn a macOS app, when you copy a security-scoped URL, the copy has the security scope of the original. You gain access to the file-system resource (that the URL points to) just as you would with the original URL: by calling the startAccessingSecurityScopedResource() method (or its Core Foundation equivalent).\nIf you need a security-scoped URL\u2019s path as a string value (as provided by the path method), such as to provide to an API that requires a string value, obtain the path from the URL as needed. Note, however, that a string-based path obtained from a security-scoped URL does not have security scope and you cannot use that string to obtain access to a security-scoped resource.\nWith OS X v10.10 and iOS 8.0, the NSURL class includes the ability to get and set document thumbnails as a resource property for iCloud documents. You can get a dictionary of NSImage objects in macOS or UIImage objects in iOS using the getResourceValue(_:forKey:) or getPromisedItemResourceValue(_:forKey:) methods.\nIn macOS, you can set a dictionary of thumbnails using the setResourceValue(_:forKey:) method. You can also get or set all the thumbnails as an NSImage object with multiple representations by using the thumbnailKey.\nNote\nDo not set the thumbnailDictionaryKey key directly. Modifying this key interferes with document tracking and can create duplicates of your document, as well as other possible problems. \nIn iOS, use a UIDocument subclass to manage your file. Set the thumbnail by overriding the document\u2019s fileAttributesToWrite(to:for:) method and returning a dictionary that contains the proper thumbnail keys (along with any other file attributes). \nIn macOS, follow the instructions for creating thumbnails given in Quick Look Programming Guide.\nNote\nAlthough the thumbnail API is designed to support multiple image resolutions, currently it only supports 1024 x 1024 pixel thumbnails.\n", "Methods": [], "class_inherit_list": ["NSObject"], "class_name": "NSURL", "typealias": [], "Vars": [{"var_description": "Key for the resource properties that have not been set after the setResourceValues(_:) method returns an error, returned as an array of NSString objects.", "var_type": "URLResourceKey", "is_static": false, "var_name": "keysOfUnsetValuesKey"}], "class_type": "class", "interface_list": ["CustomPlaygroundQuickLookable", "CVarArg", "Equatable", "Hashable", "NSCopying", "NSItemProviderReading", "NSItemProviderWriting", "NSPasteboardReading", "NSPasteboardWriting", "NSSecureCoding", "NSURLHandleClient", "QLPreviewItem"], "package_name": "foundation", "subclass_list": []}