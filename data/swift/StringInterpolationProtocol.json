{"Methods": [], "Vars": [], "class_name": "StringInterpolationProtocol", "interface_list": [], "class_description": "Each ExpressibleByStringInterpolation type has an associated StringInterpolation type which conforms to StringInterpolationProtocol. Swift converts an expression like \"The time is \\(time).\" as MyString into a series of statements similar to:\nThe StringInterpolation type is responsible for collecting the segments passed to its appendLiteral(_:) and appendInterpolation methods and assembling them into a whole, converting as necessary. Once all of the segments are appended, the interpolation is passed to an init(stringInterpolation:) initializer on the type being created, which must extract the accumulated data from the StringInterpolation.\nIn simple cases, you can use DefaultStringInterpolation as the interpolation type for types that conform to the ExpressibleByStringLiteral protocol. To use the default interpolation, conform a type to ExpressibleByStringInterpolation and implement init(stringLiteral: String). Values in interpolations are converted to strings, and then passed to that initializer just like any other string literal.\nWith a custom interpolation type, each interpolated segment is translated into a call to a special appendInterpolation method. The contents of the interpolation\u2019s parentheses are treated as the call\u2019s argument list. That argument list can include multiple arguments and argument labels.\nThe following examples show how string interpolations are translated into calls to appendInterpolation:\n\\(x) translates to appendInterpolation(x)\n\\(x, y) translates to appendInterpolation(x, y)\n\\(foo: x) translates to appendInterpolation(foo: x)\n\\(x, foo: y) translates to appendInterpolation(x, foo: y)\nThe appendInterpolation methods in your custom type must be mutating instance methods that return Void. This code shows a custom interpolation type\u2019s declaration of an appendInterpolation method that provides special validation for user input:\nTo use this interpolation method, create a string literal with an interpolation using the validating parameter label.\nappendInterpolation methods support virtually all features of methods: they can have any number of parameters, can specify labels for any or all of their parameters, can provide default values, can have variadic parameters, and can have parameters with generic types. Most importantly, they can be overloaded, so a type that conforms to StringInterpolationProtocol can provide several different appendInterpolation methods with different behaviors. An appendInterpolation method can also throw; when a user writes a literal with one of these interpolations, they must mark the string literal with try or one of its variants.\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "protocol", "typealias": []}