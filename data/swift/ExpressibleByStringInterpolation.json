{"Methods": [], "Vars": [], "class_name": "ExpressibleByStringInterpolation", "interface_list": [], "class_description": "Use string interpolation to include one or more expressions in a string literal, wrapped in a set of parentheses and prefixed by a backslash. For example:\nAdd new interpolation behavior to existing types by extending DefaultStringInterpolation, the type that implements interpolation for types like String and Substring, to add an overload of appendInterpolation(_:) with their new behavior.\nFor more information, see the DefaultStringInterpolation and StringInterpolationProtocol documentation.\nTo create a new type that supports string literals and interpolation, but that doesn\u2019t need any custom behavior, conform the type to ExpressibleByStringInterpolation and implement the init(stringLiteral: String) initializer declared by the ExpressibleByStringLiteral protocol. Swift will automatically use DefaultStringInterpolation as the interpolation type and provide an implementation for init(stringInterpolation:) that passes the interpolated literal\u2019s contents to init(stringLiteral:), so you don\u2019t need to implement anything specific to this protocol.\nIf you want a conforming type to differentiate between literal and interpolated segments, restrict the types that can be interpolated, support different interpolators from the ones on String, or avoid constructing a String containing the data, the type must specify a custom StringInterpolation associated type. This type must conform to StringInterpolationProtocol and have a matching StringLiteralType.\nFor more information, see the StringInterpolationProtocol documentation.\n", "class_inherit_list": ["ExpressibleByStringLiteral"], "package_name": "swift", "subclass_list": ["StringProtocol"], "class_type": "protocol", "typealias": []}