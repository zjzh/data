{"class_description": "The NSDictionary class declares the programmatic interface to objects that manage immutable associations of keys and values. For example, an interactive form could be represented as a dictionary, with the field names as keys, corresponding to user-entered values.\nUse this class or its subclass NSMutableDictionary when you need a convenient and efficient way to retrieve data associated with an arbitrary key. NSDictionary creates static dictionaries, and NSMutableDictionary creates dynamic dictionaries. (For convenience, the term dictionary refers to any instance of one of these classes without specifying its exact class membership.)\nA key-value pair within a dictionary is called an entry. Each entry consists of one object that represents the key and a second object that is that key\u2019s value. Within a dictionary, the keys are unique. That is, no two keys in a single dictionary are equal (as determined by isEqual(_:)). In general, a key can be any object (provided that it conforms to the NSCopying protocol\u2014see below), but note that when using key-value coding the key must be a string (see Accessing Object Properties). Neither a key nor a value can be nil; if you need to represent a null value in a dictionary, you should use NSNull.\nNSDictionary is \u201ctoll-free bridged\u201d with its Core Foundation counterpart, CFDictionary. See Toll-Free Bridging for more information on toll-free bridging.\nIn addition to the provided initializers, such as init(objects:forKeys:), you can create an NSDictionary object using a dictionary literal.\nIn Objective-C, the compiler generates code that makes an underlying call to the init(objects:forKeys:count:) method.\nUnlike dictionaryWithObjectsAndKeys: and other initializers, dictionary literals specify entries in key-value order. You should not terminate the list of objects with nil when using this literal syntax, and in fact nil is an invalid value. For more information about object literals in Objective-C, see Working with Objects in Programming with Objective-C.\nIn Swift, the NSDictionary class conforms to the DictionaryLiteralConvertible protocol, which allows it to be initialized with dictionary literals. For more information about object literals in Swift, see Literal Expression in The Swift Programming Language (Swift 4.1).\nIn addition to the provided instance methods, such as object(forKey:), you can access NSDictionary values by their keys using subscripting.\nIn addition to the provided instance methods, such as enumerateKeysAndObjects(_:), you can enumerate NSDictionary entries using for-in loops.\nIn Objective-C, NSDictionary conforms to the NSFastEnumeration protocol.\nIn Swift, NSDictionary conforms to the SequenceType protocol.\nYou generally shouldn\u2019t need to subclass NSDictionary. Custom behavior can usually be achieved through composition rather than subclassing.\nIf you do need to subclass NSDictionary, take into account that it is a Class cluster. Any subclass must override the following primitive methods:\ninit(objects:forKeys:count:)\ncount\nobject(forKey:)\nkeyEnumerator() \nThe other methods of NSDictionary operate by invoking one or more of these primitives. The non-primitive methods provide convenient ways of accessing multiple entries at once.\nBefore making a custom class of NSDictionary, investigate NSMapTable and the corresponding Core Foundation type, CFDictionary. Because NSDictionary and CFDictionary are \u201ctoll-free bridged,\u201d you can substitute a CFDictionary object for a NSDictionary object in your code (with appropriate casting). Although they are corresponding types, CFDictionary and NSDictionary do not have identical interfaces or implementations, and you can sometimes do things with CFDictionary that you cannot easily do with NSDictionary.\nIf the behavior you want to add supplements that of the existing class, you could write a category on NSDictionary. Keep in mind, however, that this category will be in effect for all instances of NSDictionary that you use, and this might have unintended consequences. Alternatively, you could use composition to achieve the desired behavior.\n", "Methods": [], "class_inherit_list": ["NSObject"], "class_name": "NSDictionary", "typealias": [], "Vars": [], "class_type": "class", "interface_list": ["CustomReflectable", "CVarArg", "Equatable", "ExpressibleByDictionaryLiteral", "Hashable", "NSCopying", "NSFastEnumeration", "NSFetchRequestResult", "NSMutableCopying", "NSSecureCoding", "Sequence"], "package_name": "foundation", "subclass_list": []}