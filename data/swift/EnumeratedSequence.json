{"Methods": [{"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "((offse", "param_name": ["predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "is_static": false, "method_name": "allSatisfy", "method_declar": "func allSatisfy(_ predicate: ((offset: Int, element: Base.Element)) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "((offse", "param_name": ["transform"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> ElementOfResult", "param_name": ["element"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "compactMap", "method_declar": "func compactMap<ElementOfResult>(_ transform: ((offset: Int, element: Base.Element)) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "((offse", "param_name": ["where", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "is_static": false, "method_name": "contains", "method_declar": "func contains(where predicate: ((offset: Int, element: Base.Element)) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "((offse", "param_name": ["by", "areEquivalent"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element), OtherSequence.Element) throws -> Bool", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: ((offset: Int, element: Base.Element), OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["EnumeratedSequence<EnumeratedSequence<Base>>"], "return_description": ["A sequence of pairs enumerating the sequence."]}, "class_name": "EnumeratedSequence", "params": [], "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "is_static": false, "method_name": "enumerated", "method_declar": "func enumerated() -> EnumeratedSequence<EnumeratedSequence<Base>>"}, {"return_value": {"return_name": [["[offset"], ["element"]], "return_type": ["Int", "Base.Element]"], "return_description": ["An array of the elements that isIncluded allowed."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_type": "((offse", "param_name": ["isIncluded"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool) rethrows -> [(offse", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["Base.Element))", "throws", "->", "Bool)", "rethrows", "->", "[(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "is_static": false, "method_name": "filter", "method_declar": "func filter(_ isIncluded: ((offset: Int, element: Base.Element)) throws -> Bool) rethrows -> [(offset: Int, element: Base.Element)]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "((offse", "param_name": ["where", "predicate"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool) rethrows -> (offse", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["Base.Element))", "throws", "->", "Bool)", "rethrows", "->", "(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "is_static": false, "method_name": "first", "method_declar": "func first(where predicate: ((offset: Int, element: Base.Element)) throws -> Bool) rethrows -> (offset: Int, element: Base.Element)?"}, {"return_value": {"return_name": [""], "return_type": ["[SegmentOfResult.Element]"], "return_description": ["The resulting flattened array."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns a sequence or collection.", "param_type": "((offse", "param_name": ["transform"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> SegmentOfResult", "param_name": ["element"]}], "method_description": "Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<SegmentOfResult>(_ transform: ((offset: Int, element: Base.Element)) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "((offse", "param_name": ["transform"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> ElementOfResult", "param_name": ["element"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<ElementOfResult>(_ transform: ((offset: Int, element: Base.Element)) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Void rethrows"], "return_description": []}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "((offse", "param_name": ["body"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Void", "param_name": ["element"]}], "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "is_static": false, "method_name": "forEach", "method_declar": "func forEach(_ body: ((offset: Int, element: Base.Element)) throws -> Void) rethrows"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((offse", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["(offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: ((offset: Int, element: Base.Element), (offset: Int, element: Base.Element)) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["[T]"], "return_description": ["An array containing the transformed elements of this sequence."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "((offse", "param_name": ["transform"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> T", "param_name": ["element"]}], "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "is_static": false, "method_name": "map", "method_declar": "func map<T>(_ transform: ((offset: Int, element: Base.Element)) throws -> T) rethrows -> [T]"}, {"return_value": {"return_name": [["offset"], ["element"]], "return_type": ["Int", "Base.Element"], "return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((offse", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["(offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool) rethrows -> (offse", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["Base.Element))", "throws", "->", "Bool)", "rethrows", "->", "(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: ((offset: Int, element: Base.Element), (offset: Int, element: Base.Element)) throws -> Bool) rethrows -> (offset: Int, element: Base.Element)?"}, {"return_value": {"return_name": [["offset"], ["element"]], "return_type": ["Int", "Base.Element"], "return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((offse", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["(offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool) rethrows -> (offse", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["Base.Element))", "throws", "->", "Bool)", "rethrows", "->", "(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: ((offset: Int, element: Base.Element), (offset: Int, element: Base.Element)) throws -> Bool) rethrows -> (offset: Int, element: Base.Element)?"}, {"return_value": {"return_name": [""], "return_type": ["Result"], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result", "param_name": ["nextPartialResult"]}, {"param_description": "", "param_type": "Int", "param_name": ["(offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Result", "param_name": ["element"]}], "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "is_static": false, "method_name": "reduce", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, (offset: Int, element: Base.Element)) throws -> Result) rethrows -> Result"}, {"return_value": {"return_name": [["[offset"], ["element"]], "return_type": ["Int", "Base.Element]"], "return_description": ["An array containing the elements of this sequence in reverse order."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "", "param_type": "Int", "param_name": [")", "->", "[(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns an array containing the elements of this sequence in reverse order.", "is_static": false, "method_name": "reversed", "method_declar": "func reversed() -> [(offset: Int, element: Base.Element)]"}, {"return_value": {"return_name": [["[offset"], ["element"]], "return_type": ["Int", "Base.Element]"], "return_description": ["A shuffled array of this sequence\u2019s elements."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "", "param_type": "Int", "param_name": [")", "->", "[(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns the elements of the sequence, shuffled.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled() -> [(offset: Int, element: Base.Element)]"}, {"return_value": {"return_name": [["[offset"], ["element"]], "return_type": ["Int", "Base.Element]"], "return_description": ["An array of this sequence\u2019s elements in a shuffled order."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout RandomNumberGenerator) -> [(offse", "param_name": ["using", "generator"]}, {"param_description": "", "param_type": "Int", "param_name": ["inout", "T)", "->", "[(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled<T>(using generator: inout T) -> [(offset: Int, element: Base.Element)] where T : RandomNumberGenerator"}, {"return_value": {"return_name": [["[offset"], ["element"]], "return_type": ["Int", "Base.Element]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((offse", "param_name": ["by", "areInIncreasingOrder"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element)", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["(offset"]}, {"param_description": "", "param_type": "Base.Element)) throws -> Bool) rethrows -> [(offse", "param_name": ["element"]}, {"param_description": "", "param_type": "Int", "param_name": ["Base.Element))", "throws", "->", "Bool)", "rethrows", "->", "[(offset"]}, {"param_description": "", "param_type": "Base.Element", "param_name": ["element"]}], "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted(by areInIncreasingOrder: ((offset: Int, element: Base.Element), (offset: Int, element: Base.Element)) throws -> Bool) rethrows -> [(offset: Int, element: Base.Element)]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "EnumeratedSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "((offse", "param_name": ["by", "areEquivalent"]}, {"param_description": "", "param_type": "Int", "param_name": ["((offset"]}, {"param_description": "", "param_type": "Base.Element), PossiblePrefix.Element) throws -> Bool", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: ((offset: Int, element: Base.Element), PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence"}], "Vars": [{"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "is_static": false, "var_name": "lazy", "var_type": "LazySequence<EnumeratedSequence<Base>>"}, {"var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "is_static": false, "var_name": "underestimatedCount", "var_type": "Int"}], "class_name": "EnumeratedSequence", "interface_list": ["Sequence"], "class_description": "EnumeratedSequence is a sequence of pairs (n, x), where ns are consecutive Int values starting at zero, and xs are the elements of a base sequence.\nTo create an instance of EnumeratedSequence, call enumerated() on a sequence or collection. The following example enumerates the elements of an array.\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}