{"class_description": "The Comparable protocol is used for types that have an inherent order, such as numbers and strings. Many types in the standard library already conform to the Comparable protocol. Add Comparable conformance to your own custom types when you want to be able to compare instances using relational operators or use standard library methods that are designed for Comparable types.\nThe most familiar use of relational operators is to compare numbers, as in the following example:\nYou can use special versions of some sequence and collection operations when working with a Comparable type. For example, if your array\u2019s elements conform to Comparable, you can call the sort() method without using arguments to sort the elements of your array in ascending order.\nTypes with Comparable conformance implement the less-than operator (<) and the equal-to operator (==). These two operations impose a strict total order on the values of a type, in which exactly one of the following must be true for any two values a and b:\na == b\na < b\nb < a\nIn addition, the following conditions must hold:\na < a is always false (Irreflexivity)\na < b implies !(b < a) (Asymmetry)\na < b and b < c implies a < c (Transitivity)\nTo add Comparable conformance to your custom types, define the < and == operators as static methods of your types. The == operator is a requirement of the Equatable protocol, which Comparable extends\u2014see that protocol\u2019s documentation for more information about equality in Swift. Because default implementations of the remainder of the relational operators are provided by the standard library, you\u2019ll be able to use !=, >, <=, and >= with instances of your type without any further code.\nAs an example, here\u2019s an implementation of a Date structure that stores the year, month, and day of a date:\nTo add Comparable conformance to Date, first declare conformance to Comparable and implement the < operator function.\nThis function uses the least specific nonmatching property of the date to determine the result of the comparison. For example, if the two year properties are equal but the two month properties are not, the date with the lesser value for month is the lesser of the two dates.\nNext, implement the == operator function, the requirement inherited from the Equatable protocol.\nTwo Date instances are equal if each of their corresponding properties is equal.\nNow that Date conforms to Comparable, you can compare instances of the type with any of the relational operators. The following example compares the date of the first moon landing with the release of David Bowie\u2019s song \u201cSpace Oddity\u201d:\nNote that the > operator provided by the standard library is used in this example, not the < operator implemented above.\nNote\nA conforming type may contain a subset of values which are treated as exceptional\u2014that is, values that are outside the domain of meaningful arguments for the purposes of the Comparable protocol. For example, the special \u201cnot a number\u201d value for floating-point types (FloatingPoint.nan) compares as neither less than, greater than, nor equal to any normal floating-point value. Exceptional values need not take part in the strict total order.\n", "Methods": [{"method_description": "Returns a closed range that contains both of its bounds.", "method_name": "...", "params": [{"param_type": "Self", "param_description": "The lower bound for the range.", "param_name": ["minimum"]}, {"param_type": "Self", "param_description": "The upper bound for the range.", "param_name": ["maximum"]}], "class_name": "Comparable", "method_declar": "static func ... (minimum: Self, maximum: Self) -> ClosedRange<Self>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ClosedRange<Self>"]}, "is_static": true}], "class_inherit_list": ["Equatable"], "class_name": "Comparable", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["Strideable", "StringProtocol"]}