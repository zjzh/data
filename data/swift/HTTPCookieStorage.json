{"subclass_list": [], "typealias": [], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_name": [""], "return_description": [], "return_type": ["HTTPCookieStorag"]}, "method_description": "Returns the cookie storage instance for the container associated with the specified app group identifier.", "is_static": false, "method_name": "sharedCookieStorage", "class_name": "HTTPCookieStorage", "method_declar": "class func sharedCookieStorage(forGroupContainerIdentifier identifier: String) -> HTTPCookieStorage", "params": [{"param_type": "String", "param_description": "The app group identifier.", "param_name": ["forGroupContainerIdentifier", "identifier"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Removes cookies that were stored after a given date.", "is_static": false, "method_name": "removeCookies", "class_name": "HTTPCookieStorage", "method_declar": "func removeCookies(since date: Date)", "params": [{"param_type": "Date", "param_description": "The date after which cookies should be removed.", "param_name": ["since", "date"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Deletes the specified cookie from the cookie storage.", "is_static": false, "method_name": "deleteCookie", "class_name": "HTTPCookieStorage", "method_declar": "func deleteCookie(_ cookie: HTTPCookie)", "params": [{"param_type": "HTTPCookie", "param_description": "", "param_name": ["cookie"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Stores a specified cookie in the cookie storage if the cookie accept policy permits.", "is_static": false, "method_name": "setCookie", "class_name": "HTTPCookieStorage", "method_declar": "func setCookie(_ cookie: HTTPCookie)", "params": [{"param_type": "HTTPCookie", "param_description": "", "param_name": ["cookie"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Adds an array of cookies to the cookie storage if the storage\u2019s cookie acceptance policy permits.", "is_static": false, "method_name": "setCookies", "class_name": "HTTPCookieStorage", "method_declar": "func setCookies(_ cookies: [HTTPCookie], for URL: URL?, mainDocumentURL: URL?)", "params": [{"param_type": "[HTTPCookie]", "param_description": "The cookies to add.", "param_name": ["cookies"]}, {"param_type": "URL", "param_description": "", "param_name": ["for", "URL"]}, {"param_type": "URL", "param_description": "The URL of the main HTML document for the top-level frame, if known. The value can be nil. This URL is used to determine whether the cookie should be accepted if the cookie accept policy is HTTPCookie.AcceptPolicy.onlyFromMainDocumentDomain.", "param_name": ["mainDocumentURL"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Stores an array of cookies in the cookie storage, on behalf of the provided task, if the cookie accept policy permits.", "is_static": false, "method_name": "storeCookies", "class_name": "HTTPCookieStorage", "method_declar": "func storeCookies(_ cookies: [HTTPCookie], for task: URLSessionTask)", "params": [{"param_type": "[HTTPCookie]", "param_description": "The cookies to add.", "param_name": ["cookies"]}, {"param_type": "URLSessionTask", "param_description": "The task that handles the response. Override this method and inspect this parameter if you need to alter your cookie storage strategy based on properties of the task.", "param_name": ["for", "task"]}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_description": "Fetches cookies relevant to the specified task and passes them to the completion handler.", "is_static": false, "method_name": "getCookiesFor", "class_name": "HTTPCookieStorage", "method_declar": "func getCookiesFor(_ task: URLSessionTask, completionHandler: @escaping ([HTTPCookie]?) -> Void)", "params": [{"param_type": "URLSessionTask", "param_description": "The task performing a request. The cookie storage can use the URL and other properties of this task\u2019s request to determine which cookies to fetch.", "param_name": ["task"]}, {"param_type": "@escaping ([HTTPCookie]) -> Void", "param_description": "A completion handler that receives an array of cookies as its argument.", "param_name": ["completionHandler"]}]}, {"return_value": {"return_name": [""], "return_description": ["An array of cookies whose URL matches the provided URL."], "return_type": ["[HTTPCookie"]}, "method_description": "Returns all the cookie storage\u2019s cookies that are sent to a specified URL.", "is_static": false, "method_name": "cookies", "class_name": "HTTPCookieStorage", "method_declar": "func cookies(for URL: URL) -> [HTTPCookie]?", "params": [{"param_type": "URL", "param_description": "", "param_name": ["for", "URL"]}]}, {"return_value": {"return_name": [""], "return_description": ["The cookie storage\u2019s cookies, sorted according to sortOrder, as an array of HTTPCookie objects."], "return_type": ["[HTTPCookie"]}, "method_description": "Returns all of the cookie storage\u2019s cookies, sorted according to a given set of sort descriptors.", "is_static": false, "method_name": "sortedCookies", "class_name": "HTTPCookieStorage", "method_declar": "func sortedCookies(using sortOrder: [NSSortDescriptor]) -> [HTTPCookie]", "params": [{"param_type": "[NSSortDescriptor]", "param_description": "The sort descriptors to use for sorting, as an array of NSSortDescriptor objects.", "param_name": ["using", "sortOrder"]}]}], "class_type": "class", "class_name": "HTTPCookieStorage", "Vars": [{"var_name": "shared", "var_type": "HTTPCookieStorage", "var_description": "The shared cookie storage instance.", "is_static": false}, {"var_name": "cookieAcceptPolicy", "var_type": "HTTPCookie.AcceptPolicy", "var_description": "The cookie storage\u2019s cookie accept policy.", "is_static": false}, {"var_name": "cookies", "var_type": "[HTTPCookie]", "var_description": "The cookie storage\u2019s cookies.", "is_static": false}, {"var_name": "NSHTTPCookieManagerCookiesChanged", "var_type": "NSNotification.Name", "var_description": "A notification posted when the cookies stored in the cookie storage have changed.", "is_static": false}, {"var_name": "NSHTTPCookieManagerAcceptPolicyChanged", "var_type": "NSNotification.Name", "var_description": "A notification posted when the acceptance policy of the cookie storage has changed.", "is_static": false}], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_description": "Each stored cookie is represented by an instance of the HTTPCookie class.\nThe persistent cookie storage returned by shared may be available to app extensions or other apps, subject to the following guidelines:\niOS \u2014 Each app and app extension has a unique data container, meaning that they have separate cookie stores. You can obtain a common cookie storage by using the sharedCookieStorage(forGroupContainerIdentifier:) method.\nmacOS (non-sandboxed) \u2014\u00a0As of macOS 10.11, each app has its own cookie storage. Prior to macOS 10.11, a common cookie store is shared among the user's apps.\nmacOS (sandboxed) \u2014 Same as iOS.\nUIWebView \u2014 UIWebView instances within an app inherit the parent app's shared cookie storage.\nWKWebView \u2014 Each\u00a0WKWebView instance has its own cookie storage. See the WKHTTPCookieStore class for more information.\nSession cookies (where the cookie object\u2019s isSessionOnly property is true) are local to a single process and are not shared.\nNote\nIn cases where a cookie storage is shared between processes, changes made to the cookie accept policy affect all currently running apps using the cookie storage. \n\nThe HTTPCookieStorage class is usable as-is, but you can subclass it. For example, you can override the storage methods like storeCookies(_:for:), getCookiesFor(_:completionHandler:) to screen which cookies are stored, or reimplement the storage mechanism for security or other reasons.\nWhen overriding methods of this class, be aware that methods that take a task parameter are preferred by the system to equivalent methods that do not. Therefore, you should override the task-based methods when subclassing, as follows:\nRetrieving cookies \u2014 Override getCookiesFor(_:completionHandler:), instead of or in addition to cookies(for:).\nAdding cookies \u2014\u00a0Override storeCookies(_:for:), instead of or in addition to setCookies(_:for:mainDocumentURL:).\n\n", "package_name": "foundation"}