{"subclass_list": [], "typealias": [], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_name": [""], "return_description": ["true if a preflight operation determines that a connection with request can be created and the associated I/O can be started, false otherwise."], "return_type": ["Boo"]}, "method_description": "Returns whether a request can be handled based on a preflight evaluation.", "is_static": false, "method_name": "canHandle", "class_name": "NSURLConnection", "method_declar": "class func canHandle(_ request: URLRequest) -> Bool", "params": [{"param_type": "URLRequest", "param_description": "The request to evaluate. The connection deep-copies the request on creation.", "param_name": ["request"]}]}, {"return_value": {"return_name": [""], "return_description": ["The downloaded data for the URL request. Returns nil if a connection could not be created or if the download fails."], "return_type": ["Dat"]}, "method_description": "Performs a synchronous load of the specified URL request.", "is_static": false, "method_name": "sendSynchronousRequest", "class_name": "NSURLConnection", "method_declar": "class func sendSynchronousRequest(_ request: URLRequest, returning response: AutoreleasingUnsafeMutablePointer<URLResponse?>?) throws -> Data", "params": [{"param_type": "URLRequest", "param_description": "The URL request to load. The request object is deep-copied as part of the initialization process. Changes made to request after this method returns do not affect the request that is used for the loading process.", "param_name": ["request"]}, {"param_type": "AutoreleasingUnsafeMutablePointer<URLResponse>", "param_description": "Out parameter for the URL response returned by the server.", "param_name": ["returning", "response"]}]}, {"return_value": {"return_name": [], "return_description": ["The URL connection for the URL request. Returns nil if a connection can't be initialized."], "return_type": []}, "method_description": "Returns an initialized URL connection and begins to load the data for the URL request.", "is_static": false, "method_name": "init", "class_name": "NSURLConnection", "method_declar": "init?(request: URLRequest, delegate: Any?)", "params": [{"param_type": "URLRequest", "param_description": "The URL request to load. The request object is deep-copied as part of the initialization process. Changes made to request after this method returns do not affect the request that is used for the loading process.", "param_name": ["request"]}, {"param_type": "Any", "param_description": "The delegate object for the connection. The connection calls methods on this delegate as the load progresses. Delegate methods are called on the same thread that called this method. By default, for the connection to work correctly, the calling thread\u2019s run loop must be operating in the default run loop mode. See schedule(in:forMode:) to change the run loop and mode.", "param_name": ["delegate"]}]}, {"return_value": {"return_name": [], "return_description": ["The URL connection for the URL request. Returns nil if a connection can't be initialized."], "return_type": []}, "method_description": "Returns an initialized URL connection and begins to load the data for the URL request, if specified.", "is_static": false, "method_name": "init", "class_name": "NSURLConnection", "method_declar": "init?(request: URLRequest, delegate: Any?, startImmediately: Bool)", "params": [{"param_type": "URLRequest", "param_description": "The URL request to load. The request object is deep-copied as part of the initialization process. Changes made to request after this method returns do not affect the request that is used for the loading process.", "param_name": ["request"]}, {"param_type": "Any", "param_description": "The delegate object for the connection. The connection calls methods on this delegate as the load progresses.", "param_name": ["delegate"]}, {"param_type": "Bool", "param_description": "true if the connection should begin loading data immediately, otherwise false. If you pass false, the connection is not scheduled with a run loop. You can then schedule the connection in the run loop and mode of your choice by calling schedule(in:forMode:).", "param_name": ["startImmediately"]}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_description": "Loads the data for a URL request and executes a handler block on an operation queue when the request completes or fails.", "is_static": false, "method_name": "sendAsynchronousRequest", "class_name": "NSURLConnection", "method_declar": "class func sendAsynchronousRequest(_ request: URLRequest, queue: OperationQueue, completionHandler handler: @escaping (URLResponse?, Data?, Error?) -> Void)", "params": [{"param_type": "URLRequest", "param_description": "The URL request to load. The request object is deep-copied as part of the initialization process. Changes made to request after this method returns do not affect the request that is used for the loading process.", "param_name": ["request"]}, {"param_type": "OperationQueue", "param_description": "The operation queue to which the handler block is dispatched when the request completes or failed.", "param_name": ["queue"]}, {"param_type": "@escaping (URLResponse, Data, Error) -> Void", "param_description": "The handler block to execute.", "param_name": ["completionHandler", "handler"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Causes the connection to begin loading data, if it has not already.", "is_static": false, "method_name": "start", "class_name": "NSURLConnection", "method_declar": "func start()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Cancels an asynchronous load of a request.", "is_static": false, "method_name": "cancel", "class_name": "NSURLConnection", "method_declar": "func cancel()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Determines the run loop and mode that the connection uses to call methods on its delegate.", "is_static": false, "method_name": "schedule", "class_name": "NSURLConnection", "method_declar": "func schedule(in aRunLoop: RunLoop, forMode mode: RunLoop.Mode)", "params": [{"param_type": "RunLoop", "param_description": "The RunLoop instance to use when calling delegate methods.", "param_name": ["in", "aRunLoop"]}, {"param_type": "RunLoop.Mode", "param_description": "The mode in which to call delegate methods.", "param_name": ["forMode", "mode"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Determines the operation queue that is used to call methods on the connection\u2019s delegate.", "is_static": false, "method_name": "setDelegateQueue", "class_name": "NSURLConnection", "method_declar": "func setDelegateQueue(_ queue: OperationQueue?)", "params": [{"param_type": "OperationQueue", "param_description": "The operation queue to use when calling delegate methods.", "param_name": ["queue"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Causes the connection to stop calling delegate methods in the specified run loop and mode.", "is_static": false, "method_name": "unschedule", "class_name": "NSURLConnection", "method_declar": "func unschedule(from aRunLoop: RunLoop, forMode mode: RunLoop.Mode)", "params": [{"param_type": "RunLoop", "param_description": "The run loop instance to unschedule.", "param_name": ["from", "aRunLoop"]}, {"param_type": "RunLoop.Mode", "param_description": "The mode to unschedule.", "param_name": ["forMode", "mode"]}]}], "class_type": "class", "class_name": "NSURLConnection", "Vars": [{"var_name": "originalRequest", "var_type": "URLRequest", "var_description": "A deep copy of the original connection request.", "is_static": false}, {"var_name": "currentRequest", "var_type": "URLRequest", "var_description": "The current connection request.", "is_static": false}, {"var_name": "newsstandAssetDownload", "var_type": "NKAssetDownload", "var_description": "The Newsstand download object associated with the URL connection.", "is_static": false}], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_description": "An NSURLConnection object lets you load the contents of a URL by providing a URL request object. The interface for NSURLConnection is sparse, providing only the controls to start and cancel asynchronous loads of a URL request. You perform most of your configuration on the URL request object itself.\nNote\nAlthough instances of this class are commonly called \u201cconnections\u201d, there is not a 1:1 correlation between these objects and the underlying network connections.\nThe NSURLConnection class provides convenience class methods to load URL requests both asynchronously using a callback block and synchronously.\nFor greater control, you can create a URL connection object with a delegate object that conforms to the NSURLConnectionDelegate and NSURLConnectionDataDelegate protocols. The connection calls methods on that delegate to provide you with progress and status as the URL request is loaded asynchronously. The connection also calls delegate methods to let you override the connection\u2019s default behavior (for example, specifying how a particular redirect should be handled). These delegate methods are called on the thread that initiated the asynchronous load operation.\nNote\nDuring a request, the connection maintains a strong reference to its delegate. It releases that strong reference when the connection finishes loading, fails, or is canceled.\nFor more information about errors, see the NSURLError.h header, Foundation Constants, and URL Loading System Error Codes in Error Handling Programming Guide.\nThe NSURLConnection class works in tandem with three formal protocols: NSURLConnectionDelegate, NSURLConnectionDataDelegate, and NSURLConnectionDownloadDelegate. To use these protocols, you write a class that conforms to them and implement any methods that are appropriate, then provide an instance of that class as the delegate when you create a connection object.\nThe NSURLConnectionDelegate protocol is primarily used for credential handling, but also handles connection completion. Because it handles connection failure during data transfers, all connection delegates must typically implement this protocol.\nIn addition, unless you\u2019re using Newsstand Kit, your delegate must also conform to the NSURLConnectionDataDelegate protocol, because this protocol provides methods that the NSURLConnection class calls with progress information during an upload, with fragments of the response data during a download, and to provide a new upload body stream if the server\u2019s response necessitates a second connection attempt\u2014for example, if NSURLConnection must retry the request with different credentials.\nFinally, if you\u2019re using Newsstand Kit, your delegate can conform to the NSURLConnectionDownloadDelegate protocol. This protocol provides support for continuing interrupted file downloads and receiving a notification whenever a download finishes. This protocol is solely for use with NSURLConnection objects created using Newsstand Kit\u2019s download(with:) method.\nNote\nSome methods in these protocols were previously part of other formal protocols or were previously part of an informal protocol on NSObject.\n", "package_name": "foundation"}