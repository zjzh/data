{"Methods": [], "Vars": [], "class_name": "PartialRangeFrom", "interface_list": ["RangeExpression", "Sequence"], "class_description": "You create PartialRangeFrom instances by using the postfix range operator (postfix ...).\nYou can use a partial range to quickly check if a value is contained in a particular range of values. For example:\nYou can use a partial range of a collection\u2019s indices to represent the range from the partial range\u2019s lower bound up to the end of the collection.\nWhen a partial range uses integers as its lower and upper bounds, or any other type that conforms to the Strideable protocol with an integer stride, you can use that range in a for-in loop or with any sequence method that doesn\u2019t require that the sequence is finite. The elements of a partial range are the consecutive values from its lower bound continuing upward indefinitely.\nBecause a PartialRangeFrom sequence counts upward indefinitely, do not use one with methods that read the entire sequence before returning, such as map(_:), filter(_:), or suffix(_:). It is safe to use operations that put an upper limit on the number of elements they access, such as prefix(_:) or dropFirst(_:), and operations that you can guarantee will terminate, such as passing a closure you know will eventually return true to first(where:).\nIn the following example, the asciiTable sequence is made by zipping together the characters in the alphabet string with a partial range starting at 65, the ASCII value of the capital letter A. Iterating over two zipped sequences continues only as long as the shorter of the two sequences, so the iteration stops at the end of alphabet.\nThe behavior of incrementing indefinitely is determined by the type of Bound. For example, iterating over an instance of PartialRangeFrom<Int> traps when the sequence\u2019s next value would be above Int.max.\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}