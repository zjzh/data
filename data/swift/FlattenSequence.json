{"Methods": [{"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "(Base.Element.Element) throws -> Bool", "param_name": ["predicate"]}], "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "is_static": false, "method_name": "allSatisfy", "method_declar": "func allSatisfy(_ predicate: (Base.Element.Element) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "(Base.Element.Element) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "compactMap", "method_declar": "func compactMap<ElementOfResult>(_ transform: (Base.Element.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the element was found in the sequence; otherwise, false."]}, "class_name": "FlattenSequence", "params": [{"param_description": "The element to find in the sequence.", "param_type": "Base.Element.Element", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "is_static": false, "method_name": "contains", "method_declar": "func contains(_ element: Base.Element.Element) -> Bool"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(Base.Element.Element) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "is_static": false, "method_name": "contains", "method_declar": "func contains(where predicate: (Base.Element.Element) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain the same elements in the same order."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(Base.Element.Element, OtherSequence.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Base.Element.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["EnumeratedSequence<FlattenSequence<Base>>"], "return_description": ["A sequence of pairs enumerating the sequence."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "is_static": false, "method_name": "enumerated", "method_declar": "func enumerated() -> EnumeratedSequence<FlattenSequence<Base>>"}, {"return_value": {"return_name": [""], "return_type": ["[Base.Element.Element]"], "return_description": ["An array of the elements that isIncluded allowed."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_type": "(Base.Element.Element) throws -> Bool", "param_name": ["isIncluded"]}], "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "is_static": false, "method_name": "filter", "method_declar": "func filter(_ isIncluded: (Base.Element.Element) throws -> Bool) rethrows -> [Base.Element.Element]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "(Base.Element.Element) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "is_static": false, "method_name": "first", "method_declar": "func first(where predicate: (Base.Element.Element) throws -> Bool) rethrows -> Base.Element.Element?"}, {"return_value": {"return_name": [""], "return_type": ["[SegmentOfResult.Element]"], "return_description": ["The resulting flattened array."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns a sequence or collection.", "param_type": "(Base.Element.Element) throws -> SegmentOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<SegmentOfResult>(_ transform: (Base.Element.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "(Base.Element.Element) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<ElementOfResult>(_ transform: (Base.Element.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Void rethrows"], "return_description": []}, "class_name": "FlattenSequence", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "(Base.Element.Element) throws -> Void", "param_name": ["body"]}], "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "is_static": false, "method_name": "forEach", "method_declar": "func forEach(_ body: (Base.Element.Element) throws -> Void) rethrows"}, {"return_value": {"return_name": [""], "return_type": ["FlattenSequence<FlattenSequence<Base>>"], "return_description": ["A flattened view of the elements of this sequence of sequences."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns the elements of this sequence of sequences, concatenated.", "is_static": false, "method_name": "joined", "method_declar": "func joined() -> FlattenSequence<FlattenSequence<Base>>"}, {"return_value": {"return_name": [""], "return_type": ["String"], "return_description": ["A single, concatenated string."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_type": "String = \"\"", "param_name": ["separator"]}], "method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "is_static": false, "method_name": "joined", "method_declar": "func joined(separator: String = \"\") -> String"}, {"return_value": {"return_name": [""], "return_type": ["JoinedSequence<FlattenSequence<Base>>"], "return_description": ["The joined sequence of elements."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to insert between each of this sequence\u2019s elements.", "param_type": "Sequence", "param_name": ["separator"]}], "method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "is_static": false, "method_name": "joined", "method_declar": "func joined<Separator>(separator: Separator) -> JoinedSequence<FlattenSequence<Base>> where Separator : Sequence, Separator.Element == Self.Element.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Base.Element.Element, Base.Element.Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Base.Element.Element, Base.Element.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["FlattenSequence<Base>.Iterator"], "return_description": []}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns an iterator over the elements of this sequence.", "is_static": false, "method_name": "makeIterator", "method_declar": "func makeIterator() -> FlattenSequence<Base>.Iterator"}, {"return_value": {"return_name": [""], "return_type": ["[T]"], "return_description": ["An array containing the transformed elements of this sequence."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(Base.Element.Element) throws -> T", "param_name": ["transform"]}], "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "is_static": false, "method_name": "map", "method_declar": "func map<T>(_ transform: (Base.Element.Element) throws -> T) rethrows -> [T]"}, {"return_value": {"return_name": [""], "return_type": ["Base.Element.Element"], "return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns the maximum element in the sequence.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max() -> Base.Element.Element?"}, {"return_value": {"return_name": [""], "return_type": ["Base.Element.Element"], "return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Base.Element.Element, Base.Element.Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (Base.Element.Element, Base.Element.Element) throws -> Bool) rethrows -> Base.Element.Element?"}, {"return_value": {"return_name": [""], "return_type": ["Base.Element.Element"], "return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns the minimum element in the sequence.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min() -> Base.Element.Element?"}, {"return_value": {"return_name": [""], "return_type": ["Base.Element.Element"], "return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Base.Element.Element, Base.Element.Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (Base.Element.Element, Base.Element.Element) throws -> Bool) rethrows -> Base.Element.Element?"}, {"return_value": {"return_name": [""], "return_type": ["Result"], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."]}, "class_name": "FlattenSequence", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result, Base.Element.Element) throws -> Result", "param_name": ["nextPartialResult"]}], "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "is_static": false, "method_name": "reduce", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Base.Element.Element) throws -> Result) rethrows -> Result"}, {"return_value": {"return_name": [""], "return_type": ["[Base.Element.Element]"], "return_description": ["An array containing the elements of this sequence in reverse order."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns an array containing the elements of this sequence in reverse order.", "is_static": false, "method_name": "reversed", "method_declar": "func reversed() -> [Base.Element.Element]"}, {"return_value": {"return_name": [""], "return_type": ["[Base.Element.Element]"], "return_description": ["A shuffled array of this sequence\u2019s elements."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns the elements of the sequence, shuffled.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled() -> [Base.Element.Element]"}, {"return_value": {"return_name": [""], "return_type": ["[Base.Element.Element]"], "return_description": ["An array of this sequence\u2019s elements in a shuffled order."]}, "class_name": "FlattenSequence", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout T", "param_name": ["using", "generator"]}], "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled<T>(using generator: inout T) -> [Base.Element.Element] where T : RandomNumberGenerator"}, {"return_value": {"return_name": [""], "return_type": ["[Base.Element.Element]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "FlattenSequence", "params": [], "method_description": "Returns the elements of the sequence, sorted.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted() -> [Base.Element.Element]"}, {"return_value": {"return_name": [""], "return_type": ["[Base.Element.Element]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Base.Element.Element, Base.Element.Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted(by areInIncreasingOrder: (Base.Element.Element, Base.Element.Element) throws -> Bool) rethrows -> [Base.Element.Element]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "FlattenSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(Base.Element.Element, PossiblePrefix.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Base.Element.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence"}], "Vars": [{"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "is_static": false, "var_name": "lazy", "var_type": "LazySequence<FlattenSequence<Base>>"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "is_static": false, "var_name": "underestimatedCount", "var_type": "Int"}], "class_name": "FlattenSequence", "interface_list": ["Sequence"], "class_description": "The elements of this view are a concatenation of the elements of each sequence in the base.\nThe joined method is always lazy, but does not implicitly confer laziness on algorithms applied to its result.  In other words, for ordinary sequences s:\ns.joined() does not create new storage\ns.joined().map(f) maps eagerly and returns a new array\ns.lazy.joined().map(f) maps lazily and returns a LazyMapSequence\nSee also: FlattenCollection\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}