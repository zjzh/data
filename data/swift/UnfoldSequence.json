{"Methods": [{"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "(Element) throws -> Bool", "param_name": ["predicate"]}], "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "is_static": false, "method_name": "allSatisfy", "method_declar": "func allSatisfy(_ predicate: (Element) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "(Element) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "compactMap", "method_declar": "func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the element was found in the sequence; otherwise, false."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "The element to find in the sequence.", "param_type": "Element", "param_name": ["element"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "is_static": false, "method_name": "contains", "method_declar": "func contains(_ element: Element) -> Bool"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "(Element) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "is_static": false, "method_name": "contains", "method_declar": "func contains(where predicate: (Element) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain the same elements in the same order."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(Element, OtherSequence.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence"}, {"return_value": {"return_name": ["", ""], "return_type": ["EnumeratedSequence<UnfoldSequence<Element", "State>>"], "return_description": ["A sequence of pairs enumerating the sequence."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "is_static": false, "method_name": "enumerated", "method_declar": "func enumerated() -> EnumeratedSequence<UnfoldSequence<Element, State>>"}, {"return_value": {"return_name": [""], "return_type": ["[Element]"], "return_description": ["An array of the elements that isIncluded allowed."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_type": "(Element) throws -> Bool", "param_name": ["isIncluded"]}], "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "is_static": false, "method_name": "filter", "method_declar": "func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "(Element) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "is_static": false, "method_name": "first", "method_declar": "func first(where predicate: (Element) throws -> Bool) rethrows -> Element?"}, {"return_value": {"return_name": [""], "return_type": ["[SegmentOfResult.Element]"], "return_description": ["The resulting flattened array."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns a sequence or collection.", "param_type": "(Element) throws -> SegmentOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<SegmentOfResult>(_ transform: (Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "(Element) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Void rethrows"], "return_description": []}, "class_name": "UnfoldSequence", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "(Element) throws -> Void", "param_name": ["body"]}], "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "is_static": false, "method_name": "forEach", "method_declar": "func forEach(_ body: (Element) throws -> Void) rethrows"}, {"return_value": {"return_name": ["", ""], "return_type": ["FlattenSequence<UnfoldSequence<Element", "State>>"], "return_description": ["A flattened view of the elements of this sequence of sequences."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns the elements of this sequence of sequences, concatenated.", "is_static": false, "method_name": "joined", "method_declar": "func joined() -> FlattenSequence<UnfoldSequence<Element, State>>"}, {"return_value": {"return_name": ["", ""], "return_type": ["JoinedSequence<UnfoldSequence<Element", "State>>"], "return_description": ["The joined sequence of elements."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to insert between each of this sequence\u2019s elements.", "param_type": "Sequence", "param_name": ["separator"]}], "method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "is_static": false, "method_name": "joined", "method_declar": "func joined<Separator>(separator: Separator) -> JoinedSequence<UnfoldSequence<Element, State>> where Separator : Sequence, Separator.Element == Self.Element.Element"}, {"return_value": {"return_name": [""], "return_type": ["String"], "return_description": ["A single, concatenated string."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_type": "String = \"\"", "param_name": ["separator"]}], "method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "is_static": false, "method_name": "joined", "method_declar": "func joined(separator: String = \"\") -> String"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element, Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": ["", ""], "return_type": ["UnfoldSequence<Element", "State>"], "return_description": []}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns an iterator over the elements of this sequence.", "is_static": false, "method_name": "makeIterator", "method_declar": "func makeIterator() -> UnfoldSequence<Element, State>"}, {"return_value": {"return_name": [""], "return_type": ["[T]"], "return_description": ["An array containing the transformed elements of this sequence."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "(Element) throws -> T", "param_name": ["transform"]}], "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "is_static": false, "method_name": "map", "method_declar": "func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]"}, {"return_value": {"return_name": [""], "return_type": ["Element"], "return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns the maximum element in the sequence.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max() -> Element?"}, {"return_value": {"return_name": [""], "return_type": ["Element"], "return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element, Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?"}, {"return_value": {"return_name": [""], "return_type": ["Element"], "return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns the minimum element in the sequence.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min() -> Element?"}, {"return_value": {"return_name": [""], "return_type": ["Element"], "return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element, Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?"}, {"return_value": {"return_name": [""], "return_type": ["Element"], "return_description": []}, "class_name": "UnfoldSequence", "params": [], "method_description": "", "is_static": false, "method_name": "next", "method_declar": "mutating func next() -> Element?"}, {"return_value": {"return_name": [""], "return_type": ["Result"], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result, Element) throws -> Result", "param_name": ["nextPartialResult"]}], "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "is_static": false, "method_name": "reduce", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result"}, {"return_value": {"return_name": [""], "return_type": ["[Element]"], "return_description": ["An array containing the elements of this sequence in reverse order."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns an array containing the elements of this sequence in reverse order.", "is_static": false, "method_name": "reversed", "method_declar": "func reversed() -> [Element]"}, {"return_value": {"return_name": [""], "return_type": ["[Element]"], "return_description": ["A shuffled array of this sequence\u2019s elements."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns the elements of the sequence, shuffled.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled() -> [Element]"}, {"return_value": {"return_name": [""], "return_type": ["[Element]"], "return_description": ["An array of this sequence\u2019s elements in a shuffled order."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout T", "param_name": ["using", "generator"]}], "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled<T>(using generator: inout T) -> [Element] where T : RandomNumberGenerator"}, {"return_value": {"return_name": [""], "return_type": ["[Element]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "UnfoldSequence", "params": [], "method_description": "Returns the elements of the sequence, sorted.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted() -> [Element]"}, {"return_value": {"return_name": [""], "return_type": ["[Element]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "(Element, Element) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "UnfoldSequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "(Element, PossiblePrefix.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence"}], "Vars": [{"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "is_static": false, "var_name": "lazy", "var_type": "LazySequence<UnfoldSequence<Element,"}, {"var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "is_static": false, "var_name": "underestimatedCount", "var_type": "Int"}], "class_name": "UnfoldSequence", "interface_list": ["IteratorProtocol", "Sequence"], "class_description": "The elements of the sequence are computed lazily and the sequence may potentially be infinite in length.\nInstances of UnfoldSequence are created with the functions sequence(first:next:) and sequence(state:next:).\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}