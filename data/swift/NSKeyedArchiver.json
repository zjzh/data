{"class_description": "NSKeyedArchiver, a concrete subclass of NSCoder, provides a way to encode objects (and scalar values) into an architecture-independent format that can be stored in a file. When you archive a set of objects, the class information and instance variables for each object are written to the archive. The companion class NSKeyedUnarchiver decodes the data in an archive and creates a set of objects equivalent to the original set.\nA keyed archive differs from a non-keyed archive in that all the objects and values encoded into the archive are given names, or keys. When decoding a non-keyed archive, values have to be decoded in the same order in which they were encoded. When decoding a keyed archive, because values are requested by name, values can be decoded out of sequence or not at all. Keyed archives, therefore, provide better support for forward and backward compatibility.\nThe keys given to encoded values must be unique only within the scope of the current object being encoded. A keyed archive is hierarchical, so the keys used by object A to encode its instance variables do not conflict with the keys used by object B, even if A and B are instances of the same class. Within a single object, however, the keys used by a subclass can conflict with keys used in its superclasses.\nAn NSArchiver object can write the archive data to a file or to a mutable-data object (an instance of NSMutableData) that you provide.\n", "Methods": [], "class_inherit_list": ["NSCoder"], "class_name": "NSKeyedArchiver", "typealias": [], "Vars": [{"var_description": "The name of the exception raised by NSKeyedArchiver if there is a problem creating an archive.", "var_type": "NSExceptionName", "is_static": false, "var_name": "invalidArchiveOperationException"}], "class_type": "class", "interface_list": ["CVarArg", "Equatable", "Hashable"], "package_name": "foundation", "subclass_list": []}