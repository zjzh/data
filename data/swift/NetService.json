{"subclass_list": [], "typealias": [], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_name": [], "return_description": ["The receiver, initialized as a network service named name of type type in the domain domain."], "return_type": []}, "method_description": "Returns the receiver, initialized as a network service of a given type and sets the initial host information.", "is_static": false, "method_name": "init", "class_name": "NetService", "method_declar": "convenience init(domain: String, type: String, name: String)", "params": [{"param_type": "String", "param_description": "The domain for the service. To resolve in the default domains, pass in an empty string (@\"\"). To limit resolution to the local domain, use @\"local.\".If you are creating this object to resolve a service whose information your app stored previously, you should set this to the domain in which the service was originally discovered.You can also use a NSNetServiceBrowser object to obtain a list of possible domains in which you can discover and resolve services.", "param_name": ["domain"]}, {"param_type": "String", "param_description": "The network service type.type must contain both the service type and transport layer information. To ensure that the mDNS responder searches for services, as opposed to hosts, prefix both the service name and transport layer name with an underscore character (\u201c_\u201d). For example, to search for an HTTP service on TCP, you would use the type string \"_http._tcp.\". Note that the period character at the end of the string, which indicates that the domain name is an absolute name, is required.", "param_name": ["type"]}, {"param_type": "String", "param_description": "The name of the service to resolve. ", "param_name": ["name"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Initializes the receiver for publishing a network service of type type at the socket location specified by domain, name, and port.", "is_static": false, "method_name": "init", "class_name": "NetService", "method_declar": "init(domain: String, type: String, name: String, port: Int32)", "params": [{"param_type": "String", "param_description": "The domain for the service. To use the default registration domains, pass in an empty string (@\"\"). To limit registration to the local domain, use @\"local.\".You can also use a NSNetServiceBrowser object to obtain a list of possible domains in which you can publish your service.", "param_name": ["domain"]}, {"param_type": "String", "param_description": "The network service type.type must contain both the service type and transport layer information. To ensure that the mDNS responder searches for services, as opposed to hosts, prefix both the service name and transport layer name with an underscore character (\u201c_\u201d). For example, to search for an HTTP service on TCP, you would use the type string \"_http._tcp.\". Note that the period character at the end of the string, which indicates that the domain name is an absolute name, is required.", "param_name": ["type"]}, {"param_type": "String", "param_description": "The name by which the service is identified to the network. The name must be unique. If you pass the empty string (@\"\"), the system automatically advertises your service using the computer name as the service name.", "param_name": ["name"]}, {"param_type": "Int32", "param_description": "The port on which the service is published.If you specify the NSNetServiceListenForConnections flag, you may pass zero (0), in which case the service automatically allocates an arbitrary (ephemeral) port for your service. When the delegate\u2019s netServiceDidPublish(_:) is called, you can determine the actual port chosen by calling the service object\u2019s NetService method or accessing the corresponding property. If your app is listening for connections on its own, the value of port must be a port number acquired by your application for the service.", "param_name": ["port"]}]}, {"return_value": {"return_name": [""], "return_description": ["An NSData object representing TXT data formed from txtDictionary. Fails an assertion if txtDictionary cannot be represented as an NSData object."], "return_type": ["Dat"]}, "method_description": "Returns an NSData object representing a TXT record formed from a given dictionary.", "is_static": false, "method_name": "data", "class_name": "NetService", "method_declar": "class func data(fromTXTRecord txtDictionary: [String : Data]) -> Data", "params": [{"param_type": "[String", "param_description": "A dictionary containing a TXT record.", "param_name": ["fromTXTRecord", "txtDictionary"]}, {"param_type": "Data]", "param_description": "", "param_name": ["[String"]}]}, {"return_value": {"return_name": [["[String"]], "return_description": ["A dictionary representing txtData. The dictionary\u2019s keys are NSString objects using UTF8 encoding. The values associated with all the dictionary\u2019s keys are NSData objects that encapsulate strings or data."], "return_type": ["Data"]}, "method_description": "Returns a dictionary representing a TXT record given as an NSData object.", "is_static": false, "method_name": "dictionary", "class_name": "NetService", "method_declar": "class func dictionary(fromTXTRecord txtData: Data) -> [String : Data]", "params": [{"param_type": "Data", "param_description": "A data object encoding a TXT record.", "param_name": ["fromTXTRecord", "txtData"]}]}, {"return_value": {"return_name": [""], "return_description": ["true if the streams are created successfully, otherwise false."], "return_type": ["Boo"]}, "method_description": "Creates a pair of input and output streams for the receiver and returns a Boolean value that indicates whether they were retrieved successfully.", "is_static": false, "method_name": "getInputStream", "class_name": "NetService", "method_declar": "func getInputStream(_ inputStream: UnsafeMutablePointer<InputStream?>?, outputStream: UnsafeMutablePointer<OutputStream?>?) -> Bool", "params": [{"param_type": "UnsafeMutablePointer<InputStream>", "param_description": "Upon return, the input stream for the receiver. Pass NULL if you do not need this stream.", "param_name": ["inputStream"]}, {"param_type": "UnsafeMutablePointer<OutputStream>", "param_description": "Upon return, the output stream for the receiver. Pass NULL if you do not need this stream.", "param_name": ["outputStream"]}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Dat"]}, "method_description": "Returns the TXT record for the receiver.", "is_static": false, "method_name": "txtRecordData", "class_name": "NetService", "method_declar": "func txtRecordData() -> Data?", "params": []}, {"return_value": {"return_name": [""], "return_description": ["true if recordData is successfully set as the TXT record, otherwise false."], "return_type": ["Boo"]}, "method_description": "Sets the TXT record for the receiver, and returns a Boolean value that indicates whether the operation was successful.", "is_static": false, "method_name": "setTXTRecord", "class_name": "NetService", "method_declar": "func setTXTRecord(_ recordData: Data?) -> Bool", "params": [{"param_type": "Data", "param_description": "The TXT record for the receiver.", "param_name": ["recordData"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Adds the service to the specified run loop.", "is_static": false, "method_name": "schedule", "class_name": "NetService", "method_declar": "func schedule(in aRunLoop: RunLoop, forMode mode: RunLoop.Mode)", "params": [{"param_type": "RunLoop", "param_description": "The run loop to which to add the receiver.", "param_name": ["in", "aRunLoop"]}, {"param_type": "RunLoop.Mode", "param_description": "The run loop mode to which to add the receiver. Possible values for mode are discussed in the \"Constants\" section of RunLoop.", "param_name": ["forMode", "mode"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Removes the service from the given run loop for a given mode.", "is_static": false, "method_name": "remove", "class_name": "NetService", "method_declar": "func remove(from aRunLoop: RunLoop, forMode mode: RunLoop.Mode)", "params": [{"param_type": "RunLoop", "param_description": "The run loop from which to remove the receiver.", "param_name": ["from", "aRunLoop"]}, {"param_type": "RunLoop.Mode", "param_description": "The run loop mode from which to remove the receiver. Possible values for mode are discussed in the \"Constants\" section of RunLoop.", "param_name": ["forMode", "mode"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Attempts to advertise the receiver\u2019s on the network.", "is_static": false, "method_name": "publish", "class_name": "NetService", "method_declar": "func publish()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Attempts to advertise the receiver on the network, with the given options.", "is_static": false, "method_name": "publish", "class_name": "NetService", "method_declar": "func publish(options: NetService.Options = [])", "params": [{"param_type": "NetService.Options = []", "param_description": "", "param_name": ["options"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Starts a resolve process for the service.DeprecatedUse resolve(withTimeout:) instead.", "is_static": false, "method_name": "resolve", "class_name": "NetService", "method_declar": "func resolve()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Starts a resolve process of a finite duration for the service.", "is_static": false, "method_name": "resolve", "class_name": "NetService", "method_declar": "func resolve(withTimeout timeout: TimeInterval)", "params": [{"param_type": "TimeInterval", "param_description": "The maximum number of seconds to attempt a resolve. A value of 0.0 indicates no timeout and a resolve process of indefinite duration.", "param_name": ["withTimeout", "timeout"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Starts the monitoring of TXT-record updates for the receiver.", "is_static": false, "method_name": "startMonitoring", "class_name": "NetService", "method_declar": "func startMonitoring()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Halts a currently running attempt to publish or resolve a service.", "is_static": false, "method_name": "stop", "class_name": "NetService", "method_declar": "func stop()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Stops the monitoring of TXT-record updates for the receiver.", "is_static": false, "method_name": "stopMonitoring", "class_name": "NetService", "method_declar": "func stopMonitoring()", "params": []}], "class_type": "class", "class_name": "NetService", "Vars": [{"var_name": "addresses", "var_type": "[Data]", "var_description": "A read-only array containing NSData objects, each of which contains a socket address for the service.", "is_static": false}, {"var_name": "domain", "var_type": "String", "var_description": "A string containing the domain for this service.", "is_static": false}, {"var_name": "includesPeerToPeer", "var_type": "Bool", "var_description": "Specifies whether to also publish, resolve, or monitor this service over peer-to-peer Bluetooth and Wi-Fi, if available. false by default.", "is_static": false}, {"var_name": "name", "var_type": "String", "var_description": "A string containing the name of this service.", "is_static": false}, {"var_name": "type", "var_type": "String", "var_description": "The type of the published service.", "is_static": false}, {"var_name": "delegate", "var_type": "NetServiceDelegate", "var_description": "The delegate for the receiver.", "is_static": false}, {"var_name": "port", "var_type": "Int", "var_description": "The port on which the service is listening for connections.", "is_static": false}, {"var_name": "hostName", "var_type": "String", "var_description": "A string containing the DNS hostname for this service.", "is_static": false}, {"var_name": "errorCode", "var_type": "String", "var_description": "This key identifies the error that occurred during the most recent operation. ", "is_static": false}, {"var_name": "errorDomain", "var_type": "String", "var_description": "This key identifies the originator of the error, which is either the NSNetService object or the mach network layer. For most errors, you should not need the value provided by this key.", "is_static": false}], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_description": "The NetService class represents a network service, either one your application publishes or is a client of. This class and the NetServiceBrowser class use multicast DNS to convey information about network services to and from your application. The API of NetService provides a convenient way to publish the services offered by your application and to resolve the socket address for a service.\nThe types of services you access using NetService are the same types that you access directly using BSD sockets. HTTP and FTP are two services commonly provided by systems. (For a list of common services and the ports used by those services, see the file /etc/services.) Applications can also define their own custom services to provide specific data to clients.\nYou can use the NetService class as either a publisher of a service or a client of a service. If your application publishes a service, your code must acquire a port and prepare a socket to communicate with clients. Once your socket is ready, you use the NetService class to notify clients that your service is ready. If your application is the client of a network service, you can either create an NetService object directly (if you know the exact host and port information) or use an NetServiceBrowser object to browse for services.\nTo publish a service, initialize your NetService object with the service name, domain, type, and port information. All of this information must be valid for the socket created by your application. Once initialized, call the publish() method to broadcast your service information to the network.\nWhen connecting to a service, use the NetServiceBrowser class to locate the service on the network and obtain the corresponding NetService object. Once you have the object, call the resolve(withTimeout:) method to verify that the service is available and ready for your application. If it is, the addresses property provides the socket information you can use to connect to the service.\nThe methods of NetService operate asynchronously so your application is not impacted by the speed of the network. All information about a service is returned to your application through the NetService object\u2019s delegate. You must provide a delegate object to respond to messages and to handle errors appropriately.\n", "package_name": "foundation"}