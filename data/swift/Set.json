{"class_description": "You use a set instead of an array when you need to test efficiently for membership and you aren\u2019t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.\nYou can create a set with any element type that conforms to the Hashable protocol. By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves.\nSwift makes it as easy to create a new set as to create a new array. Simply assign an array literal to a variable or constant with the Set type specified.\nSets provide a suite of mathematical set operations. For example, you can efficiently test a set for membership of an element or check its intersection with another set:\nUse the contains(_:) method to test whether a set contains a specific element.\nUse the \u201cequal to\u201d operator (==) to test whether two sets contain the same elements.\nUse the isSubset(of:) method to test whether a set contains all the elements of another set or sequence.\nUse the isSuperset(of:) method to test whether all elements of a set are contained in another set or sequence.\nUse the isStrictSubset(of:) and isStrictSuperset(of:) methods to test whether a set is a subset or superset of, but not equal to, another set.\nUse the isDisjoint(with:) method to test whether a set has any elements in common with another set.\nYou can also combine, exclude, or subtract the elements of two sets:\nUse the union(_:) method to create a new set with the elements of a set and another set or sequence.\nUse the intersection(_:) method to create a new set with only the elements common to a set and another set or sequence.\nUse the symmetricDifference(_:) method to create a new set with the elements that are in either a set or another set or sequence, but not in both.\nUse the subtracting(_:) method to create a new set with the elements of a set that are not also in another set or sequence.\nYou can modify a set in place by using these methods\u2019 mutating counterparts: formUnion(_:), formIntersection(_:), formSymmetricDifference(_:), and subtract(_:).\nSet operations are not limited to use with other sets. Instead, you can perform set operations with another set, an array, or any other sequence type.\nIn addition to the Set type\u2019s set operations, you can use any nonmutating sequence or collection methods with a set.\nYou can iterate through a set\u2019s unordered elements with a for-in loop.\nMany sequence and collection operations return an array or a type-erasing collection wrapper instead of a set. To restore efficient set operations, create a new set from the result.\nYou can bridge between Set and NSSet using the as operator. For bridging to be possible, the Element type of a set must be a class, an @objc protocol (a protocol imported from Objective-C or marked with the @objc attribute), or a type that bridges to a Foundation type.\nBridging from Set to NSSet always takes O(1) time and space. When the set\u2019s Element type is neither a class nor an @objc protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O(n).\nBridging from NSSet to Set first calls the copy(with:) method (- copyWithZone: in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of NSSet that are already immutable, copy(with:) returns the same set in constant time; otherwise, the copying performance is unspecified. The instances of NSSet and Set share buffer using the same copy-on-write optimization that is used when two instances of Set share buffer.\n", "Methods": [{"method_description": "Creates an empty set.", "method_name": "init", "params": [], "class_name": "Set", "method_declar": "init()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an empty set with preallocated space for at least the specified number of elements.", "method_name": "init", "params": [{"param_type": "Int", "param_description": "The minimum number of elements that the newly created set should be able to store without reallocating its storage buffer.", "param_name": ["minimumCapacity"]}], "class_name": "Set", "method_declar": "init(minimumCapacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the given element exists in the set.", "method_name": "contains", "params": [{"param_type": "Element", "param_description": "An element to look for in the set.", "param_name": ["member"]}], "class_name": "Set", "method_declar": "func contains(_ member: Element) -> Bool", "return_value": {"return_description": ["true if member exists in the set; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Reserves enough space to store the specified number of elements.", "method_name": "reserveCapacity", "params": [{"param_type": "Int", "param_description": "The requested number of elements to store.", "param_name": ["minimumCapacity"]}], "class_name": "Set", "method_declar": "mutating func reserveCapacity(_ minimumCapacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new set containing the elements of the set that satisfy the given predicate.", "method_name": "filter", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value indicating whether the element should be included in the returned set.", "param_name": ["isIncluded"]}], "class_name": "Set", "method_declar": "func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> Set<Element>", "return_value": {"return_description": ["A set of the elements that isIncluded allows."], "return_name": [""], "return_type": ["Set<Element"]}, "is_static": false}, {"method_description": "Removes the specified element from the set.", "method_name": "remove", "params": [{"param_type": "Element", "param_description": "The element to remove from the set.", "param_name": ["member"]}], "class_name": "Set", "method_declar": "@discardableResult mutating func remove(_ member: Element) -> Element?", "return_value": {"return_description": ["The value of the member parameter if it was a member of the set; otherwise, nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "", "method_name": "remove", "params": [{"param_type": "Hashable", "param_description": "", "param_name": ["member"]}], "class_name": "Set", "method_declar": "@discardableResult mutating func remove<ConcreteElement>(_ member: ConcreteElement) -> ConcreteElement? where ConcreteElement : Hashable", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ConcreteElement"]}, "is_static": false}, {"method_description": "Removes the first element of the set.", "method_name": "removeFirst", "params": [], "class_name": "Set", "method_declar": "@discardableResult mutating func removeFirst() -> Element", "return_value": {"return_description": ["A member of the set."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Removes the element at the given index of the set.", "method_name": "remove", "params": [{"param_type": "Set<Element>.Index", "param_description": "The index of the member to remove. position must be a valid index of the set, and must not be equal to the set\u2019s end index.", "param_name": ["at", "position"]}], "class_name": "Set", "method_declar": "@discardableResult mutating func remove(at position: Set<Element>.Index) -> Element", "return_value": {"return_description": ["The element that was removed from the set."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Removes all members from the set.", "method_name": "removeAll", "params": [{"param_type": "Bool = false", "param_description": "If true, the set\u2019s buffer capacity is preserved; if false, the underlying buffer is released. The default is false.", "param_name": ["keepingCapacity", "keepCapacity"]}], "class_name": "Set", "method_declar": "mutating func removeAll(keepingCapacity keepCapacity: Bool = false)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new set with the elements that are common to both this set and the given sequence.", "method_name": "intersection", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "func intersection(_ other: Set<Element>) -> Set<Element>", "return_value": {"return_description": ["A new set."], "return_name": [""], "return_type": ["Set<Element"]}, "is_static": false}, {"method_description": "Returns a new set with the elements that are common to both this set and the given sequence.", "method_name": "intersection", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. other must be finite.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "func intersection<S>(_ other: S) -> Set<Element> where Element == S.Element, S : Sequence", "return_value": {"return_description": ["A new set."], "return_name": [""], "return_type": ["Set<Element>"]}, "is_static": false}, {"method_description": "Removes the elements of the set that aren\u2019t also in the given sequence.", "method_name": "formIntersection", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. other must be finite.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Sequence", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements of the given set from this set.", "method_name": "subtract", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "mutating func subtract(_ other: Set<Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements of the given set from this set.", "method_name": "subtract", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "mutating func subtract(_ other: Set<Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements of the given sequence from the set.", "method_name": "subtract", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. other must be finite.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "mutating func subtract<S>(_ other: S) where Element == S.Element, S : Sequence", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new set containing the elements of this set that do not occur in the given set.", "method_name": "subtracting", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "func subtracting(_ other: Set<Element>) -> Set<Element>", "return_value": {"return_description": ["A new set."], "return_name": [""], "return_type": ["Set<Element"]}, "is_static": false}, {"method_description": "Returns a new set containing the elements of this set that do not occur in the given sequence.", "method_name": "subtracting", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. other must be finite.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "func subtracting<S>(_ other: S) -> Set<Element> where Element == S.Element, S : Sequence", "return_value": {"return_description": ["A new set."], "return_name": [""], "return_type": ["Set<Element>"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether two sets have equal elements.", "method_name": "==", "params": [{"param_type": "Set<Element>", "param_description": "A set.", "param_name": ["lhs"]}, {"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["rhs"]}], "class_name": "Set", "method_declar": "static func == (lhs: Set<Element>, rhs: Set<Element>) -> Bool", "return_value": {"return_description": ["true if the lhs and rhs have the same elements; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": true}, {"method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "params": [{"param_type": "Set<Element>", "param_description": "A value to compare.", "param_name": ["lhs"]}, {"param_type": "Set<Element>", "param_description": "Another value to compare.", "param_name": ["rhs"]}], "class_name": "Set", "method_declar": "static func != (lhs: Set<Element>, rhs: Set<Element>) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": true}, {"method_description": "Returns a Boolean value that indicates whether this set is a subset of the given set.", "method_name": "isSubset", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["of", "other"]}], "class_name": "Set", "method_declar": "func isSubset(of other: Set<Element>) -> Bool", "return_value": {"return_description": ["true if the set is a subset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a subset of the given sequence.", "method_name": "isSubset", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. possibleSuperset must be finite.", "param_name": ["of", "possibleSuperset"]}], "class_name": "Set", "method_declar": "func isSubset<S>(of possibleSuperset: S) -> Bool where Element == S.Element, S : Sequence", "return_value": {"return_description": ["true if the set is a subset of possibleSuperset; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a strict subset of the given sequence.", "method_name": "isStrictSubset", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["of", "other"]}], "class_name": "Set", "method_declar": "func isStrictSubset(of other: Set<Element>) -> Bool", "return_value": {"return_description": ["true if the set is a strict subset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a strict subset of the given sequence.", "method_name": "isStrictSubset", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. possibleStrictSuperset must be finite.", "param_name": ["of", "possibleStrictSuperset"]}], "class_name": "Set", "method_declar": "func isStrictSubset<S>(of possibleStrictSuperset: S) -> Bool where Element == S.Element, S : Sequence", "return_value": {"return_description": ["true is the set is strict subset of possibleStrictSuperset; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether this set is a superset of the given set.", "method_name": "isSuperset", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["of", "other"]}], "class_name": "Set", "method_declar": "func isSuperset(of other: Set<Element>) -> Bool", "return_value": {"return_description": ["true if the set is a superset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a strict superset of the given sequence.", "method_name": "isStrictSuperset", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["of", "other"]}], "class_name": "Set", "method_declar": "func isStrictSuperset(of other: Set<Element>) -> Bool", "return_value": {"return_description": ["true if the set is a strict superset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a strict superset of the given sequence.", "method_name": "isStrictSuperset", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. possibleStrictSubset must be finite.", "param_name": ["of", "possibleStrictSubset"]}], "class_name": "Set", "method_declar": "func isStrictSuperset<S>(of possibleStrictSubset: S) -> Bool where Element == S.Element, S : Sequence", "return_value": {"return_description": ["true if the set is a strict superset of possibleStrictSubset; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether this set has no members in common with the given set.", "method_name": "isDisjoint", "params": [{"param_type": "Set<Element>", "param_description": "Another set.", "param_name": ["with", "other"]}], "class_name": "Set", "method_declar": "func isDisjoint(with other: Set<Element>) -> Bool", "return_value": {"return_description": ["true if the set has no elements in common with other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set has no members in common with the given sequence.", "method_name": "isDisjoint", "params": [{"param_type": "Sequence", "param_description": "A sequence of elements. other must be finite.", "param_name": ["with", "other"]}], "class_name": "Set", "method_declar": "func isDisjoint<S>(with other: S) -> Bool where Element == S.Element, S : Sequence", "return_value": {"return_description": ["true if the set has no elements in common with other; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a random element of the collection.", "method_name": "randomElement", "params": [], "class_name": "Set", "method_declar": "func randomElement() -> Element?", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when choosing a random element.", "param_name": ["using", "generator"]}], "class_name": "Set", "method_declar": "func randomElement<T>(using generator: inout T) -> Element? where T : RandomNumberGenerator", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Set", "method_declar": "func contains(where predicate: (Element) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_name": ["predicate"]}], "class_name": "Set", "method_declar": "func allSatisfy(_ predicate: (Element) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "Set", "method_declar": "func first(where predicate: (Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the index of the given element in the set, or nil if the element is not a member of the set.", "method_name": "firstIndex", "params": [{"param_type": "Element", "param_description": "An element to search for in the set.", "param_name": ["of", "member"]}], "class_name": "Set", "method_declar": "func firstIndex(of member: Element) -> Set<Element>.Index?", "return_value": {"return_description": ["The index of member if it exists in the set; otherwise, nil."], "return_name": [""], "return_type": ["Set<Element>.Inde"]}, "is_static": false}, {"method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Set", "method_declar": "func firstIndex(where predicate: (Element) throws -> Bool) rethrows -> Set<Element>.Index?", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence.", "method_name": "min", "params": [], "class_name": "Set", "method_declar": "@warn_unqualified_access func min() -> Element?", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Set", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence.", "method_name": "max", "params": [], "class_name": "Set", "method_declar": "@warn_unqualified_access func max() -> Element?", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Set", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(Element) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Set", "method_declar": "func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(Element) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Set", "method_declar": "func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T"]}, "is_static": false}, {"method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "params": [{"param_type": "(Element) throws -> ElementOfResult", "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_name": ["transform"]}], "class_name": "Set", "method_declar": "func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["[ElementOfResult"]}, "is_static": false}, {"method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_name": ["initialResult"]}, {"param_type": "(Result, Element) throws -> Result", "param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_name": ["nextPartialResult"]}], "class_name": "Set", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Resul"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted.", "method_name": "sorted", "params": [], "class_name": "Set", "method_declar": "func sorted() -> [Element]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Set", "method_declar": "func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "params": [], "class_name": "Set", "method_declar": "func shuffled() -> [Element]", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when shuffling the sequence.", "param_name": ["using", "generator"]}], "class_name": "Set", "method_declar": "func shuffled<T>(using generator: inout T) -> [Element] where T : RandomNumberGenerator", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Element]"]}, "is_static": false}, {"method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "params": [], "class_name": "Set", "method_declar": "func enumerated() -> EnumeratedSequence<Set<Element>>", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<Set<Element>"]}, "is_static": false}, {"method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "params": [{"param_type": "(Element) throws -> Void", "param_description": "A closure that takes an element of the sequence as a parameter.", "param_name": ["body"]}], "class_name": "Set", "method_declar": "func forEach(_ body: (Element) throws -> Void) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrow"]}, "is_static": false}, {"method_description": "", "method_name": "index", "params": [{"param_type": "Set<Element>.Index", "param_description": "", "param_name": ["after", "i"]}], "class_name": "Set", "method_declar": "func index(after i: Set<Element>.Index) -> Set<Element>.Index", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Set<Element>.Inde"]}, "is_static": false}, {"method_description": "Replaces the given index with its successor.", "method_name": "formIndex", "params": [{"param_type": "inout Set<Element>.Index", "param_description": "A valid index of the collection. i must be less than endIndex.", "param_name": ["after", "i"]}], "class_name": "Set", "method_declar": "func formIndex(after i: inout Set<Element>.Index)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "params": [{"param_type": "Set<Element>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "Set", "method_declar": "func index(_ i: Set<Element>.Index, offsetBy distance: Int) -> Set<Element>.Index", "return_value": {"return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_name": [""], "return_type": ["Set<Element>.Inde"]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "params": [{"param_type": "inout Set<Element>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "Set", "method_declar": "func formIndex(_ i: inout Set<Element>.Index, offsetBy distance: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "params": [{"param_type": "Set<Element>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Set<Element>.Index", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Set", "method_declar": "func index(_ i: Set<Element>.Index, offsetBy distance: Int, limitedBy limit: Set<Element>.Index) -> Set<Element>.Index?", "return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["Set<Element>.Inde"]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "params": [{"param_type": "inout Set<Element>.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Set<Element>.Index", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Set", "method_declar": "func formIndex(_ i: inout Set<Element>.Index, offsetBy distance: Int, limitedBy limit: Set<Element>.Index) -> Bool", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns the distance between two indices.", "method_name": "distance", "params": [{"param_type": "Set<Element>.Index", "param_description": "A valid index of the collection.", "param_name": ["from", "start"]}, {"param_type": "Set<Element>.Index", "param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_name": ["to", "end"]}], "class_name": "Set", "method_declar": "func distance(from start: Set<Element>.Index, to end: Set<Element>.Index) -> Int", "return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(Element, OtherSequence.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "Set", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "Set", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Set", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}], "class_name": "Set", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}, {"param_type": "(Element, PossiblePrefix.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "Set", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Set", "method_declar": "func prefix(_ maxLength: Int) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "params": [{"param_type": "Set<Element>.Index", "param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_name": ["upTo", "end"]}], "class_name": "Set", "method_declar": "func prefix(upTo end: Set<Element>.Index) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "params": [{"param_type": "Set<Element>.Index", "param_description": "", "param_name": ["through", "position"]}], "class_name": "Set", "method_declar": "func prefix(through position: Set<Element>.Index) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "Set", "method_declar": "func prefix(while predicate: (Element) throws -> Bool) rethrows -> Slice<Set<Element>>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. The value of maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Set", "method_declar": "func suffix(_ maxLength: Int) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "params": [{"param_type": "Set<Element>.Index", "param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_name": ["from", "start"]}], "class_name": "Set", "method_declar": "func suffix(from start: Set<Element>.Index) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "Set", "method_declar": "func drop(while predicate: (Element) throws -> Bool) rethrows -> Slice<Set<Element>>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Set", "method_declar": "func dropFirst(_ k: Int = 1) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Set", "method_declar": "func dropLast(_ k: Int = 1) -> Slice<Set<Element>>", "return_value": {"return_description": ["A subsequence that leaves off the specified number of elements at the end."], "return_name": [""], "return_type": ["Slice<Set<Element>"]}, "is_static": false}, {"method_description": "Removes and returns the first element of the set.", "method_name": "popFirst", "params": [], "class_name": "Set", "method_declar": "mutating func popFirst() -> Element?", "return_value": {"return_description": ["A member of the set. If the set is empty, returns nil."], "return_name": [""], "return_type": ["Elemen"]}, "is_static": false}, {"method_description": "Returns an array containing the elements of this sequence in reverse order.", "method_name": "reversed", "params": [], "class_name": "Set", "method_declar": "func reversed() -> [Element]", "return_value": {"return_description": ["An array containing the elements of this sequence in reverse order."], "return_name": [""], "return_type": ["[Element"]}, "is_static": false}, {"method_description": "Returns the elements of this sequence of sequences, concatenated.", "method_name": "joined", "params": [], "class_name": "Set", "method_declar": "func joined() -> FlattenSequence<Set<Element>>", "return_value": {"return_description": ["A flattened view of the elements of this sequence of sequences."], "return_name": [""], "return_type": ["FlattenSequence<Set<Element>"]}, "is_static": false}, {"method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "method_name": "joined", "params": [{"param_type": "Sequence", "param_description": "A sequence to insert between each of this sequence\u2019s elements.", "param_name": ["separator"]}], "class_name": "Set", "method_declar": "func joined<Separator>(separator: Separator) -> JoinedSequence<Set<Element>> where Separator : Sequence, Separator.Element == Self.Element.Element", "return_value": {"return_description": ["The joined sequence of elements."], "return_name": [""], "return_type": ["JoinedSequence<Set<Element>>"]}, "is_static": false}, {"method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "method_name": "joined", "params": [{"param_type": "String = \"\"", "param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_name": ["separator"]}], "class_name": "Set", "method_declar": "func joined(separator: String = \"\") -> String", "return_value": {"return_description": ["A single, concatenated string."], "return_name": [""], "return_type": ["Strin"]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "method_name": "split", "params": [{"param_type": "Element", "param_description": "The element that should be split upon.", "param_name": ["separator"]}, {"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool = true", "param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.", "param_name": ["omittingEmptySubsequences"]}], "class_name": "Set", "method_declar": "func split(separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Slice<Set<Element>>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[Slice<Set<Element>>"]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "params": [{"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool", "param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_name": ["omittingEmptySubsequences"]}, {"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_name": ["whereSeparator", "isSeparator"]}], "class_name": "Set", "method_declar": "func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [Slice<Set<Element>>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Encodes the elements of this set into the given encoder in an unkeyed container.", "method_name": "encode", "params": [{"param_type": "Encoder", "param_description": "The encoder to write data to.", "param_name": ["to", "encoder"]}], "class_name": "Set", "method_declar": "func encode(to encoder: Encoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new set by decoding from the given decoder.", "method_name": "init", "params": [{"param_type": "Decoder", "param_description": "The decoder to read data from.", "param_name": ["from", "decoder"]}], "class_name": "Set", "method_declar": "init(from decoder: Decoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "params": [{"param_type": "inout Hasher", "param_description": "The hasher to use when combining the components of this instance.", "param_name": ["into", "hasher"]}], "class_name": "Set", "method_declar": "func hash(into hasher: inout Hasher)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a set containing the elements of the given array literal.", "method_name": "init", "params": [{"param_type": "Element...", "param_description": "A variadic list of elements of the new set.", "param_name": ["arrayLiteral", "elements"]}], "class_name": "Set", "method_declar": "init(arrayLiteral elements: Element...)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a set containing the elements of the given array literal.", "method_name": "init", "params": [{"param_type": "Element...", "param_description": "A variadic list of elements of the new set.", "param_name": ["arrayLiteral", "elements"]}], "class_name": "Set", "method_declar": "init(arrayLiteral elements: Element...)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}], "class_inherit_list": [], "class_name": "Set", "typealias": [], "Vars": [{"var_description": "A Boolean value that indicates whether the set is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "A Boolean value that indicates whether the set is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "A Boolean value that indicates whether the set is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "The number of elements in the set.", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The number of elements in the set.", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The total number of elements that the set can contain without allocating new storage.", "var_type": "Int", "is_static": false, "var_name": "capacity"}, {"var_description": "The first element of the collection.", "var_type": "Element", "is_static": false, "var_name": "first"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<Set<Element>>", "is_static": false, "var_name": "lazy"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "The starting position for iterating members of the set.", "var_type": "Set<Element>.Index", "is_static": false, "var_name": "startIndex"}, {"var_description": "The \u201cpast the end\u201d position for the set\u2014that is, the position one greater than the last valid subscript argument.", "var_type": "Set<Element>.Index", "is_static": false, "var_name": "endIndex"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<Set<Element>>", "is_static": false, "var_name": "indices"}, {"var_description": "A string that represents the contents of the set.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A string that represents the contents of the set, suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the set.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}], "class_type": "struct", "interface_list": ["Collection", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "CVarArg", "Decodable", "Encodable", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "Sequence", "SetAlgebra"], "package_name": "foundation", "subclass_list": []}