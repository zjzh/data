{"class_description": "You use a set instead of an array when you need to test efficiently for membership and you aren\u2019t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.\nYou can create a set with any element type that conforms to the Hashable protocol. By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves.\nSwift makes it as easy to create a new set as to create a new array. Simply assign an array literal to a variable or constant with the Set type specified.\nSets provide a suite of mathematical set operations. For example, you can efficiently test a set for membership of an element or check its intersection with another set:\nUse the contains(_:) method to test whether a set contains a specific element.\nUse the \u201cequal to\u201d operator (==) to test whether two sets contain the same elements.\nUse the isSubset(of:) method to test whether a set contains all the elements of another set or sequence.\nUse the isSuperset(of:) method to test whether all elements of a set are contained in another set or sequence.\nUse the isStrictSubset(of:) and isStrictSuperset(of:) methods to test whether a set is a subset or superset of, but not equal to, another set.\nUse the isDisjoint(with:) method to test whether a set has any elements in common with another set.\nYou can also combine, exclude, or subtract the elements of two sets:\nUse the union(_:) method to create a new set with the elements of a set and another set or sequence.\nUse the intersection(_:) method to create a new set with only the elements common to a set and another set or sequence.\nUse the symmetricDifference(_:) method to create a new set with the elements that are in either a set or another set or sequence, but not in both.\nUse the subtracting(_:) method to create a new set with the elements of a set that are not also in another set or sequence.\nYou can modify a set in place by using these methods\u2019 mutating counterparts: formUnion(_:), formIntersection(_:), formSymmetricDifference(_:), and subtract(_:).\nSet operations are not limited to use with other sets. Instead, you can perform set operations with another set, an array, or any other sequence type.\nIn addition to the Set type\u2019s set operations, you can use any nonmutating sequence or collection methods with a set.\nYou can iterate through a set\u2019s unordered elements with a for-in loop.\nMany sequence and collection operations return an array or a type-erasing collection wrapper instead of a set. To restore efficient set operations, create a new set from the result.\nYou can bridge between Set and NSSet using the as operator. For bridging to be possible, the Element type of a set must be a class, an @objc protocol (a protocol imported from Objective-C or marked with the @objc attribute), or a type that bridges to a Foundation type.\nBridging from Set to NSSet always takes O(1) time and space. When the set\u2019s Element type is neither a class nor an @objc protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O(n).\nBridging from NSSet to Set first calls the copy(with:) method (- copyWithZone: in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of NSSet that are already immutable, copy(with:) returns the same set in constant time; otherwise, the copying performance is unspecified. The instances of NSSet and Set share buffer using the same copy-on-write optimization that is used when two instances of Set share buffer.\n", "Methods": [], "class_inherit_list": [], "class_name": "Set", "typealias": [], "Vars": [], "class_type": "struct", "interface_list": ["Collection", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "CVarArg", "Decodable", "Encodable", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "Sequence", "SetAlgebra"], "package_name": "foundation", "subclass_list": []}