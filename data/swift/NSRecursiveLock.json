{"subclass_list": [], "typealias": [], "class_inherit_list": ["NSObject"], "Methods": [{"return_value": {"return_name": [""], "return_description": ["true if the lock is acquired before limit, otherwise false."], "return_type": ["Boo"]}, "method_description": "Attempts to acquire a lock before a given date.", "is_static": false, "method_name": "lock", "class_name": "NSRecursiveLock", "method_declar": "func lock(before limit: Date) -> Bool", "params": [{"param_type": "Date", "param_description": "The time before which the lock should be acquired.", "param_name": ["before", "limit"]}]}, {"return_value": {"return_name": [""], "return_description": ["true if successful, otherwise false."], "return_type": ["Boo"]}, "method_description": "Attempts to acquire a lock, and immediately returns a Boolean value that indicates whether the attempt was successful.", "is_static": false, "method_name": "`try`", "class_name": "NSRecursiveLock", "method_declar": "func `try`() -> Bool", "params": []}], "class_type": "class", "class_name": "NSRecursiveLock", "Vars": [{"var_name": "name", "var_type": "String", "var_description": "The name associated with the receiver. ", "is_static": false}], "interface_list": ["CVarArg", "Equatable", "Hashable", "NSLocking"], "class_description": "NSRecursiveLock defines a lock that may be acquired multiple times by the same thread without causing a deadlock, a situation where a thread is permanently blocked waiting for itself to relinquish a lock. While the locking thread has one or more locks, all other threads are prevented from accessing the code protected by the lock.\n", "package_name": "foundation"}