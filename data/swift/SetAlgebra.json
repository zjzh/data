{"class_description": "You use types that conform to the SetAlgebra protocol when you need efficient membership tests or mathematical set operations such as intersection, union, and subtraction. In the standard library, you can use the Set type with elements of any hashable type, or you can easily create bit masks with SetAlgebra conformance using the OptionSet protocol. See those types for more information.\nNote\nUnlike ordinary set types, the Element type of an OptionSet is identical to the OptionSet type itself. The SetAlgebra protocol is specifically designed to accommodate both kinds of set.\nWhen implementing a custom type that conforms to the SetAlgebra protocol, you must implement the required initializers and methods. For the inherited methods to work properly, conforming types must meet the following axioms. Assume that S is a custom type that conforms to the SetAlgebra protocol, x and y are instances of S, and e is of type S.Element\u2014the type that the set holds.\nS() == []\nx.intersection(x) == x\nx.intersection([]) == []\nx.union(x) == x\nx.union([]) == x\nx.contains(e) implies x.union(y).contains(e)\nx.union(y).contains(e) implies x.contains(e) || y.contains(e)\nx.contains(e) && y.contains(e) if and only if x.intersection(y).contains(e)\nx.isSubset(of: y) implies x.union(y) == y\nx.isSuperset(of: y) implies x.union(y) == x\nx.isSubset(of: y) if and only if y.isSuperset(of: x)\nx.isStrictSuperset(of: y) if and only if x.isSuperset(of: y) && x != y\nx.isStrictSubset(of: y) if and only if x.isSubset(of: y) && x != y\n", "Methods": [], "class_inherit_list": ["Equatable", "ExpressibleByArrayLiteral"], "class_name": "SetAlgebra", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["OptionSet"]}