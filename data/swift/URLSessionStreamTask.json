{"subclass_list": [], "typealias": [], "class_inherit_list": ["URLSessionTask"], "Methods": [{"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_description": "Asynchronously reads a number of bytes from the stream, and calls a handler upon completion.", "is_static": false, "method_name": "readData", "class_name": "URLSessionStreamTask", "method_declar": "func readData(ofMinLength minBytes: Int, maxLength maxBytes: Int, timeout: TimeInterval, completionHandler: @escaping (Data?, Bool, Error?) -> Void)", "params": [{"param_type": "Int", "param_description": "The minimum number of bytes to read.", "param_name": ["ofMinLength", "minBytes"]}, {"param_type": "Int", "param_description": "The maximum number of bytes to read.", "param_name": ["maxLength", "maxBytes"]}, {"param_type": "TimeInterval", "param_description": "A timeout for reading bytes. If the read is not completed within the specified interval, the read is canceled and the completionHandler is called with an error. Pass 0 to prevent a read from timing out.", "param_name": ["timeout"]}, {"param_type": "@escaping (Data, Bool, Error) -> Void", "param_description": "The completion handler to call when all bytes are read, or an error occurs. This handler is executed on the delegate queue.This completion handler takes the following parameters:dataThe data read from the stream.atEOFWhether or not the stream reached end-of-file (EOF), such that no more data can be read.errorAn error object that indicates why the read failed, or nil if the read was successful.", "param_name": ["completionHandler"]}]}, {"return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_description": "Asynchronously writes the specified data to the stream, and calls a handler upon completion.", "is_static": false, "method_name": "write", "class_name": "URLSessionStreamTask", "method_declar": "func write(_ data: Data, timeout: TimeInterval, completionHandler: @escaping (Error?) -> Void)", "params": [{"param_type": "Data", "param_description": "The data to be written.", "param_name": ["data"]}, {"param_type": "TimeInterval", "param_description": "A timeout for writing bytes. If the write is not completed within the specified interval, the write is canceled and the completionHandler is called with an error. Pass 0 to prevent a write from timing out.", "param_name": ["timeout"]}, {"param_type": "@escaping (Error) -> Void", "param_description": "The completion handler to call when all bytes are written, or an error occurs. This handler is executed on the delegate queue.This completion handler takes the following parameter:errorAn error object that indicates why the write failed, or nil if the write was successful.", "param_name": ["completionHandler"]}]}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Completes any already enqueued reads and writes, and then invokes the urlSession(_:streamTask:didBecome:outputStream:) delegate message.", "is_static": false, "method_name": "captureStreams", "class_name": "URLSessionStreamTask", "method_declar": "func captureStreams()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Completes any enqueued reads and writes, and then closes the read side of the underlying socket.", "is_static": false, "method_name": "closeRead", "class_name": "URLSessionStreamTask", "method_declar": "func closeRead()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Completes any enqueued reads and writes, and then closes the write side of the underlying socket.", "is_static": false, "method_name": "closeWrite", "class_name": "URLSessionStreamTask", "method_declar": "func closeWrite()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Completes any enqueued reads and writes, and establishes a secure connection.", "is_static": false, "method_name": "startSecureConnection", "class_name": "URLSessionStreamTask", "method_declar": "func startSecureConnection()", "params": []}, {"return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_description": "Completes any enqueued reads and writes, and closes the secure connection.", "is_static": false, "method_name": "stopSecureConnection", "class_name": "URLSessionStreamTask", "method_declar": "func stopSecureConnection()", "params": []}], "class_type": "class", "class_name": "URLSessionStreamTask", "Vars": [], "interface_list": ["CVarArg", "Equatable", "Hashable"], "class_description": "URLSessionStreamTask is a concrete subclass of URLSessionTask. Many of the methods in the URLSessionStreamTask class are documented in URLSessionTask.\nThe URLSessionStreamTask class provides an interface a TCP/IP connection created via URLSession. Tasks may be created from an URLSession using the streamTask(withHostName:port:) and streamTask(with:) methods. They may also created as a result of an URLSessionDataTask being upgraded via the HTTP Upgrade: response header and appropriate use of the httpShouldUsePipelining option of URLSessionConfiguration.\nNote\nSee RFC 2817 and RFC 6455 for information about the Upgrade: header.\nA URLSessionStreamTask object performs asynchronous reads and writes, which are enqueued and executed serially, calling a handler upon completion being on the session delegate queue. If the task is canceled, all enqueued reads and writes will call their completion handlers with an appropriate error.\nWhen working with APIs that accept Stream objects, you can create InputStream and OutputStream objects from an URLSessionStreamTask object by calling the captureStreams() method.\n", "package_name": "foundation"}