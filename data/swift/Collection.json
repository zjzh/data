{"class_description": "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the Collection protocol declares and implements. In addition to the operations that collections inherit from the Sequence protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.\nFor example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.\nThe firstSpace constant is an index into the text string\u2014the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, firstSpace is used to extract the prefix that contains elements up to that index.\nYou can access an element of a collection through its subscript by using any valid index except the collection\u2019s endIndex property. This property is a \u201cpast the end\u201d index that does not correspond with any element of the collection.\nHere\u2019s an example of accessing the first character in a string through its subscript:\nThe Collection protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of text using the first property, which has the value of the first element of the collection, or nil if the collection is empty.\nYou can pass only valid indices to collection operations. You can find a complete set of a collection\u2019s valid indices by starting with the collection\u2019s startIndex property and finding every successor up to, and including, the endIndex property. All other values of the Index type, such as the startIndex property of a different collection, are invalid indices for this collection.\nSaved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the MutableCollection and RangeReplaceableCollection protocols, as well as for the specific type you\u2019re using.\nYou can access a slice of a collection through its ranged subscript or by calling methods like prefix(while:) or suffix(_:). A slice of a collection can contain zero or more of the original collection\u2019s elements and shares the original collection\u2019s semantics.\nThe following example creates a firstWord constant by using the prefix(while:) method to get a slice of the text string.\nYou can retrieve the same slice using the string\u2019s ranged subscript, which takes a range expression.\nThe retrieved slice of text is equivalent in each of these cases.\nA collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.\nFor example, suppose you have an array holding the number of absences from each class during a session.\nYou\u2019re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:\nCreate a slice of the absences array that holds the second half of the days.\nUse the max(by:) method to determine the index of the day with the most absences.\nPrint the result using the index found in step 2 on the original absences array.\nHere\u2019s an implementation of those steps:\nA slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.\nFor example, if you update the last element of the absences array from 0 to 2, the secondHalf slice is unchanged.\nAlthough a sequence can be consumed as it is traversed, a collection is guaranteed to be multipass: Any element can be repeatedly accessed by saving its index. Moreover, a collection\u2019s indices form a finite range of the positions of the collection\u2019s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the contains(_:) method to test whether a collection includes an element.\nIterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the characters view of a string returns the same characters in the same order whether the view\u2019s indices or the view itself is being iterated.\nIf you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:\nThe startIndex and endIndex properties\nA subscript that provides at least read-only access to your type\u2019s elements\nThe index(after:) method for advancing an index into your collection\nTypes that conform to Collection are expected to provide the startIndex and endIndex properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.\nThe performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its count property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its count property is an O(n) operation.\n", "Methods": [], "class_inherit_list": ["Sequence"], "class_name": "Collection", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["BidirectionalCollection", "LazyCollectionProtocol", "MutableCollection", "RangeReplaceableCollection"]}