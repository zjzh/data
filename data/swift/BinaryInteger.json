{"class_description": "The BinaryInteger protocol is the basis for all the integer types provided by the standard library. All of the standard library\u2019s integer types, such as Int and UInt32, conform to BinaryInteger.\nYou can create new instances of a type that conforms to the BinaryInteger protocol from a floating-point number or another binary integer of any type. The BinaryInteger protocol provides initializers for four different kinds of conversion.\nYou use the default init(_:) initializer to create a new instance when you\u2019re sure that the value passed is representable in the new type. For example, an instance of Int16 can represent the value 500, so the first conversion in the code sample below succeeds. That same value is too large to represent as an Int8 instance, so the second conversion fails, triggering a runtime error.\nWhen you create a binary integer from a floating-point value using the default initializer, the value is rounded toward zero before the range is checked. In the following example, the value 127.75 is rounded to 127, which is representable by the Int8 type.  128.25 is rounded to 128, which is not representable as an Int8 instance, triggering a runtime error.\nUse the init?(exactly:) initializer to create a new instance after checking whether the passed value is representable. Instead of trapping on out-of-range values, using the failable exact initializer results in nil.\nWhen converting floating-point values, the init?(exact:) initializer checks both that the passed value has no fractional part and that the value is representable in the resulting type.\nUse the init(clamping:) initializer to create a new instance of a binary integer type where out-of-range values are clamped to the representable range of the type. For a type T, the resulting value is in the range T.min...T.max.\nUse the init(truncatingIfNeeded:) initializer to create a new instance with the same bit pattern as the passed value, extending or truncating the value\u2019s representation as necessary. Note that the value may not be preserved, particularly when converting between signed to unsigned integer types or when the destination type has a smaller bit width than the source type. The following example shows how extending and truncating work for nonnegative integers:\nAny padding is performed by sign-extending the passed value. When nonnegative integers are extended, the result is padded with zeroes. When negative integers are extended, the result is padded with ones. This example shows several extending conversions of a negative value\u2014note that negative values are sign-extended even when converting to an unsigned type.\nYou can use relational operators, such as the less-than and equal-to operators (< and ==), to compare instances of different binary integer types. The following example compares instances of the Int, UInt, and UInt8 types:\n", "Methods": [], "class_inherit_list": ["CustomStringConvertible", "Hashable", "Numeric", "Strideable"], "class_name": "BinaryInteger", "typealias": [], "Vars": [], "class_type": "protocol", "interface_list": [], "package_name": "swift", "subclass_list": ["FixedWidthInteger", "SignedInteger", "UnsignedInteger"]}