{"Methods": [{"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> Bool", "param_name": ["predicate"]}], "method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "is_static": false, "method_name": "allSatisfy", "method_declar": "func allSatisfy(_ predicate: ((Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "compactMap", "method_declar": "func compactMap<ElementOfResult>(_ transform: ((Sequence1.Element, Sequence2.Element)) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> Bool", "param_name": ["where", "predicate"]}], "method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "is_static": false, "method_name": "contains", "method_declar": "func contains(where predicate: ((Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> Bool"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "((Sequence1.Element, Sequence2.Element), OtherSequence.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "is_static": false, "method_name": "elementsEqual", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: ((Sequence1.Element, Sequence2.Element), OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence"}, {"return_value": {"return_name": ["", ""], "return_type": ["EnumeratedSequence<Zip2Sequence<Sequence1", "Sequence2>>"], "return_description": ["A sequence of pairs enumerating the sequence."]}, "class_name": "Zip2Sequence", "params": [], "method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "is_static": false, "method_name": "enumerated", "method_declar": "func enumerated() -> EnumeratedSequence<Zip2Sequence<Sequence1, Sequence2>>"}, {"return_value": {"return_name": ["", ""], "return_type": ["[Sequence1.Element", "Sequence2.Element]"], "return_description": ["An array of the elements that isIncluded allowed."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> [(Sequence1.Element, Sequence2.Element", "param_name": ["isIncluded"]}], "method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "is_static": false, "method_name": "filter", "method_declar": "func filter(_ isIncluded: ((Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> [(Sequence1.Element, Sequence2.Element)]"}, {"return_value": {"return_name": [""], "return_type": [""], "return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> (Sequence1.Element, Sequence2.Element", "param_name": ["where", "predicate"]}], "method_description": "Returns the first element of the sequence that satisfies the given predicate.", "is_static": false, "method_name": "first", "method_declar": "func first(where predicate: ((Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> (Sequence1.Element, Sequence2.Element)?"}, {"return_value": {"return_name": [""], "return_type": ["[SegmentOfResult.Element]"], "return_description": ["The resulting flattened array."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns a sequence or collection.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> SegmentOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<SegmentOfResult>(_ transform: ((Sequence1.Element, Sequence2.Element)) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence"}, {"return_value": {"return_name": [""], "return_type": ["[ElementOfResult]"], "return_description": ["An array of the non-nil results of calling transform with each element of the sequence."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> ElementOfResult", "param_name": ["transform"]}], "method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "is_static": false, "method_name": "flatMap", "method_declar": "func flatMap<ElementOfResult>(_ transform: ((Sequence1.Element, Sequence2.Element)) throws -> ElementOfResult?) rethrows -> [ElementOfResult]"}, {"return_value": {"return_name": [""], "return_type": ["Void rethrows"], "return_description": []}, "class_name": "Zip2Sequence", "params": [{"param_description": "A closure that takes an element of the sequence as a parameter.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> Void", "param_name": ["body"]}], "method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "is_static": false, "method_name": "forEach", "method_declar": "func forEach(_ body: ((Sequence1.Element, Sequence2.Element)) throws -> Void) rethrows"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["other"]}, {"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "is_static": false, "method_name": "lexicographicallyPrecedes", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: ((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element"}, {"return_value": {"return_name": ["", ""], "return_type": ["Zip2Sequence<Sequence1", "Sequence2>.Iterator"], "return_description": []}, "class_name": "Zip2Sequence", "params": [], "method_description": "Returns an iterator over the elements of this sequence.", "is_static": false, "method_name": "makeIterator", "method_declar": "func makeIterator() -> Zip2Sequence<Sequence1, Sequence2>.Iterator"}, {"return_value": {"return_name": [""], "return_type": ["[T]"], "return_description": ["An array containing the transformed elements of this sequence."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_type": "((Sequence1.Element, Sequence2.Element)) throws -> T", "param_name": ["transform"]}], "method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "is_static": false, "method_name": "map", "method_declar": "func map<T>(_ transform: ((Sequence1.Element, Sequence2.Element)) throws -> T) rethrows -> [T]"}, {"return_value": {"return_name": ["", ""], "return_type": ["Sequence1.Element", "Sequence2.Element"], "return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> (Sequence1.Element, Sequence2.Element", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "max", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: ((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> (Sequence1.Element, Sequence2.Element)?"}, {"return_value": {"return_name": ["", ""], "return_type": ["Sequence1.Element", "Sequence2.Element"], "return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> (Sequence1.Element, Sequence2.Element", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "is_static": false, "method_name": "min", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: ((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> (Sequence1.Element, Sequence2.Element)?"}, {"return_value": {"return_name": [""], "return_type": ["Result"], "return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_type": "Result", "param_name": ["initialResult"]}, {"param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_type": "(Result, (Sequence1.Element, Sequence2.Element)) throws -> Result", "param_name": ["nextPartialResult"]}], "method_description": "Returns the result of combining the elements of the sequence using the given closure.", "is_static": false, "method_name": "reduce", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, (Sequence1.Element, Sequence2.Element)) throws -> Result) rethrows -> Result"}, {"return_value": {"return_name": ["", ""], "return_type": ["[Sequence1.Element", "Sequence2.Element]"], "return_description": ["An array containing the elements of this sequence in reverse order."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "", "param_type": ") -> [(Sequence1.Element, Sequence2.Element", "param_name": [")", "->", "[(Sequence1.Element,", "Sequence2.Element"]}], "method_description": "Returns an array containing the elements of this sequence in reverse order.", "is_static": false, "method_name": "reversed", "method_declar": "func reversed() -> [(Sequence1.Element, Sequence2.Element)]"}, {"return_value": {"return_name": ["", ""], "return_type": ["[Sequence1.Element", "Sequence2.Element]"], "return_description": ["A shuffled array of this sequence\u2019s elements."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "", "param_type": ") -> [(Sequence1.Element, Sequence2.Element", "param_name": [")", "->", "[(Sequence1.Element,", "Sequence2.Element"]}], "method_description": "Returns the elements of the sequence, shuffled.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled() -> [(Sequence1.Element, Sequence2.Element)]"}, {"return_value": {"return_name": ["", ""], "return_type": ["[Sequence1.Element", "Sequence2.Element]"], "return_description": ["An array of this sequence\u2019s elements in a shuffled order."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "The random number generator to use when shuffling the sequence.", "param_type": "inout T) -> [(Sequence1.Element, Sequence2.Element", "param_name": ["using", "generator"]}], "method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "is_static": false, "method_name": "shuffled", "method_declar": "func shuffled<T>(using generator: inout T) -> [(Sequence1.Element, Sequence2.Element)] where T : RandomNumberGenerator"}, {"return_value": {"return_name": ["", ""], "return_type": ["[Sequence1.Element", "Sequence2.Element]"], "return_description": ["A sorted array of the sequence\u2019s elements."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_type": "((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> [(Sequence1.Element, Sequence2.Element", "param_name": ["by", "areInIncreasingOrder"]}], "method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "is_static": false, "method_name": "sorted", "method_declar": "func sorted(by areInIncreasingOrder: ((Sequence1.Element, Sequence2.Element), (Sequence1.Element, Sequence2.Element)) throws -> Bool) rethrows -> [(Sequence1.Element, Sequence2.Element)]"}, {"return_value": {"return_name": [""], "return_type": ["Bool"], "return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."]}, "class_name": "Zip2Sequence", "params": [{"param_description": "A sequence to compare to this sequence.", "param_type": "Sequence", "param_name": ["with", "possiblePrefix"]}, {"param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_type": "((Sequence1.Element, Sequence2.Element), PossiblePrefix.Element) throws -> Bool", "param_name": ["by", "areEquivalent"]}], "method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "is_static": false, "method_name": "starts", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: ((Sequence1.Element, Sequence2.Element), PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence"}], "Vars": [{"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "is_static": false, "var_name": "lazy", "var_type": "LazySequence<Zip2Sequence<Sequence1,"}, {"var_description": "A value less than or equal to the number of elements in the sequence, calculated nondestructively.", "is_static": false, "var_name": "underestimatedCount", "var_type": "Int"}], "class_name": "Zip2Sequence", "interface_list": ["Sequence"], "class_description": "In a Zip2Sequence instance, the elements of the ith pair are the ith elements of each underlying sequence. To create a Zip2Sequence instance, use the zip(_:_:) function.\nThe following example uses the zip(_:_:) function to iterate over an array of strings and a countable range at the same time:\n", "class_inherit_list": [], "package_name": "swift", "subclass_list": [], "class_type": "struct", "typealias": []}