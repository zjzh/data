{"class_description": "NSNumber is a subclass of NSValue that offers a value as any C scalar (numeric) type. It defines a set of methods specifically for setting and accessing the value as a signed or unsigned char, short int, int, long int, long long int, float, or double or as a BOOL. (Note that number objects do not necessarily preserve the type they are created with.) It also defines a compare(_:) method to determine the ordering of two NSNumber objects.\nNSNumber is \u201ctoll-free bridged\u201d with its Core Foundation counterparts: CFNumber for integer and floating point values, and CFBoolean for Boolean values. See Toll-Free Bridging for more information on toll-free bridging.\nNSNumber provides readonly properties that return the object\u2019s stored value converted to a particular Boolean, integer, unsigned integer, or floating point C scalar type. Because numeric types have different storage capabilities, attempting to initialize with a value of one type and access the value of another type may produce an erroneous result\u2014for example, initializing with a double value exceeding FLT_MAX and accessing its floatValue, or initializing with an negative integer value and accessing its uintValue. In some cases, attempting to initialize with a value of a type and access the value of another type may result in loss of precision\u2014for example, initializing with a double value with many significant digits and accessing its floatValue, or initializing with a large integer value and accessing its int8Value.\nAn NSNumber object initialized with a value of a particular type accessing the converted value of a different kind of type, such as unsigned int and float, will convert its stored value to that converted type in the following ways:\nNSNumber from Boolean Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\nfalse\nfalse\n0\n0\n0.0\ntrue\ntrue\n1\n1\n1.0\nNSNumber from Integer Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\n0\nfalse\n0\n0\n0.0\n1\ntrue\n1\n1\n1.0\n-1\ntrue\n-1\ninvalid, erroneous result\n-1.0\nNSNumber from Unsigned Integer Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\n0\nfalse\n0\n0\n0.0\n1\ntrue\n1\n1\n1.0\nNSNumber from Floating Point Value Conversions\nValue\nboolValue\nintValue\nuintValue\nfloatValue\n0.0\nfalse\n0\n0\n0.0\n1.0\ntrue\n1\n1\n1.0\n-1.0\ntrue\n-1\ninvalid, erroneous result\n-1.0\nAs with any class cluster, subclasses of NSNumber must override the primitive methods of its superclass, NSValue. In addition, there are two requirements around the data type your subclass represents:\nYour implementation of objCType must return one of \u201cc\u201d, \u201cC\u201d, \u201cs\u201d, \u201cS\u201d, \u201ci\u201d, \u201cI\u201d, \u201cl\u201d, \u201cL\u201d, \u201cq\u201d, \u201cQ\u201d, \u201cf\u201d, and \u201cd\u201d. This is required for the other methods of NSNumber to behave correctly.\nYour subclass must override the accessor method that corresponds to the declared type\u2014for example, if your implementation of objCType returns  \u201ci\u201d, you must override int32Value.\n", "Methods": [], "class_inherit_list": ["NSValue"], "class_name": "NSNumber", "typealias": [], "Vars": [], "class_type": "class", "interface_list": ["CKRecordValueProtocol", "CVarArg", "Equatable", "ExpressibleByBooleanLiteral", "ExpressibleByFloatLiteral", "ExpressibleByIntegerLiteral", "Hashable", "NSFetchRequestResult"], "package_name": "foundation", "subclass_list": []}