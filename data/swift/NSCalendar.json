{"class_description": "NSCalendar objects encapsulate information about systems of reckoning time in which the beginning, length, and divisions of a year are defined. They provide information about the calendar and support for calendrical computations such as determining the range of a given calendrical unit and adding units to a given absolute time.\nNSCalendar is toll-free bridged with its Core Foundation counterpart, CFCalendar. See Toll-Free Bridging for more information on toll-free bridging.\nImportant\nThe Swift overlay to the Foundation framework provides the Calendar structure, which bridges to the NSCalendar class. For more information about value types, see Working with Cocoa Frameworks in Using Swift with Cocoa and Objective-C (Swift 4.1).\nMost locales use the most widely used civil calendar, called the Gregorian calendar (gregorian), but there remain exceptions to this trend. For example:\nIn Saudi Arabia, some locales use primarily the Islamic Umm al-Qura calendar (islamicUmmAlQura).\nIn Ethiopia, some locales use primarily the Ethiopian calendar (ethiopicAmeteMihret or ethiopicAmeteAlem).\nIn Iran and Afghanistan, some locales use primarily the Persian calendar (persian).\nIn Thailand, some locales use primarily the Buddhist calendar (buddhist).\nOther locales use another calendar alongside the Gregorian calendar. For example:\nIndia also uses the Indian national calendar (indian).\nIsrael also uses the Hebrew calendar (hebrew).\nChina and other regions also use the Chinese calendar (chinese), primarily to calculate astronomical date and Chinese traditional holidays.\nJapan also uses the Japanese calendar (japanese), primarily to add year names.\nIndependent of any particular locale, certain calendars are used primarily to calculate dates for religious observances. Among these are the Buddhist (buddhist), Coptic (coptic), Hebrew (hebrew), and Islamic (islamic) calendars.\nThe Gregorian calendar was first introduced in 1582, as a replacement for the Julian Calendar. According to the Julian calendar, a leap day is added to February for any year with a number divisible by 4, which results in an annual disparity of 11 minutes, or 1 day every 128 years. The Gregorian calendar revised the rules for leap day calculation, by skipping the leap day for any year with a number divisible by 100, unless that year number is also divisible by 400, resulting in an annual disparity of only 26 seconds, or 1 day every 3323 years.\nTo transition from the Julian calendar to the Gregorian calendar, 10 days were dropped from the Gregorian calendar (October 5\u201314).\nAfter the Gregorian calendar was introduced, many countries continued to use the Julian calendar, with Turkey being the last country to adopt the Gregorian calendar, in 1926. As a result of the staggered adoption, the transition period for countries at the time of adoption have different start dates and a different number of skipped days to account for the additional disparity from leap day calculations.\nNSCalendar models the behavior of a proleptic Gregorian calendar (as defined by ISO 8601:2004), which extends the Gregorian calendar backward in time from the date of its introduction. This behavior should be taken into account when working with dates created before the transition period of the affected locales.\nTo do calendar arithmetic, you use NSDate objects in conjunction with a calendar. For example, to convert between a decomposed date in one calendar and another calendar, you must first convert the decomposed elements into a date using the first calendar, then decompose it using the second. NSDate provides the absolute scale and epoch (reference point) for dates and times, which can then be rendered into a particular calendar, for calendrical computations or user display.\nTwo NSCalendar methods that return a date object, date(from:), date(byAdding:to:options:), take as a parameter an NSDateComponents object that describes the calendrical components required for the computation. You can provide as many components as you need (or choose to). When there is incomplete information to compute an absolute time, default values similar to 0 and 1 are usually chosen by a calendar, but this is a calendar-specific choice. If you provide inconsistent information, calendar-specific disambiguation is performed (which may involve ignoring one or more of the parameters). Related methods (components(_:from:) and components(_:from:to:options:)) take a bit mask parameter that specifies which components to calculate when returning an NSDateComponents object. The bit mask is composed of NSCalendar.Unit constants (see Constants).\nIn a calendar, day, week, weekday, month, and year numbers are generally 1-based, but there may be calendar-specific exceptions. Ordinal numbers, where they occur, are 1-based. Some calendars represented by this API may have to map their basic unit concepts into year/month/week/day/\u2026 nomenclature. For example, a calendar composed of 4 quarters in a year instead of 12 months uses the month unit to represent quarters. The particular values of the unit are defined by each calendar, and are not necessarily consistent with values for that unit in another calendar.\n", "Methods": [], "class_inherit_list": ["NSObject"], "class_name": "NSCalendar", "typealias": [], "Vars": [{"var_description": "Specifies that the components specified for an NSDateComponents object should be incremented and wrap around to zero/one on overflow, but should not cause higher units to be incremented.DeprecatedUse wrapComponents instead.", "var_type": "Int", "is_static": false, "var_name": "NSWrapCalendarComponents"}, {"var_description": "A notification that is posted whenever the calendar day of the system changes, as determined by the system calendar, locale, and time zone.", "var_type": "NSNotification.Name", "is_static": false, "var_name": "NSCalendarDayChanged"}], "class_type": "class", "interface_list": ["CVarArg", "Equatable", "Hashable", "NSCopying", "NSSecureCoding"], "package_name": "foundation", "subclass_list": []}