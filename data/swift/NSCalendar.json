{"package_name": "foundation", "subclass_list": [], "class_description": "NSCalendar objects encapsulate information about systems of reckoning time in which the beginning, length, and divisions of a year are defined. They provide information about the calendar and support for calendrical computations such as determining the range of a given calendrical unit and adding units to a given absolute time.\nNSCalendar is toll-free bridged with its Core Foundation counterpart, CFCalendar. See Toll-Free Bridging for more information on toll-free bridging.\nImportant\nThe Swift overlay to the Foundation framework provides the Calendar structure, which bridges to the NSCalendar class. For more information about value types, see Working with Cocoa Frameworks in Using Swift with Cocoa and Objective-C (Swift 4.1).\nMost locales use the most widely used civil calendar, called the Gregorian calendar (gregorian), but there remain exceptions to this trend. For example:\nIn Saudi Arabia, some locales use primarily the Islamic Umm al-Qura calendar (islamicUmmAlQura).\nIn Ethiopia, some locales use primarily the Ethiopian calendar (ethiopicAmeteMihret or ethiopicAmeteAlem).\nIn Iran and Afghanistan, some locales use primarily the Persian calendar (persian).\nIn Thailand, some locales use primarily the Buddhist calendar (buddhist).\nOther locales use another calendar alongside the Gregorian calendar. For example:\nIndia also uses the Indian national calendar (indian).\nIsrael also uses the Hebrew calendar (hebrew).\nChina and other regions also use the Chinese calendar (chinese), primarily to calculate astronomical date and Chinese traditional holidays.\nJapan also uses the Japanese calendar (japanese), primarily to add year names.\nIndependent of any particular locale, certain calendars are used primarily to calculate dates for religious observances. Among these are the Buddhist (buddhist), Coptic (coptic), Hebrew (hebrew), and Islamic (islamic) calendars.\nThe Gregorian calendar was first introduced in 1582, as a replacement for the Julian Calendar. According to the Julian calendar, a leap day is added to February for any year with a number divisible by 4, which results in an annual disparity of 11 minutes, or 1 day every 128 years. The Gregorian calendar revised the rules for leap day calculation, by skipping the leap day for any year with a number divisible by 100, unless that year number is also divisible by 400, resulting in an annual disparity of only 26 seconds, or 1 day every 3323 years.\nTo transition from the Julian calendar to the Gregorian calendar, 10 days were dropped from the Gregorian calendar (October 5\u201314).\nAfter the Gregorian calendar was introduced, many countries continued to use the Julian calendar, with Turkey being the last country to adopt the Gregorian calendar, in 1926. As a result of the staggered adoption, the transition period for countries at the time of adoption have different start dates and a different number of skipped days to account for the additional disparity from leap day calculations.\nNSCalendar models the behavior of a proleptic Gregorian calendar (as defined by ISO 8601:2004), which extends the Gregorian calendar backward in time from the date of its introduction. This behavior should be taken into account when working with dates created before the transition period of the affected locales.\nTo do calendar arithmetic, you use NSDate objects in conjunction with a calendar. For example, to convert between a decomposed date in one calendar and another calendar, you must first convert the decomposed elements into a date using the first calendar, then decompose it using the second. NSDate provides the absolute scale and epoch (reference point) for dates and times, which can then be rendered into a particular calendar, for calendrical computations or user display.\nTwo NSCalendar methods that return a date object, date(from:), date(byAdding:to:options:), take as a parameter an NSDateComponents object that describes the calendrical components required for the computation. You can provide as many components as you need (or choose to). When there is incomplete information to compute an absolute time, default values similar to 0 and 1 are usually chosen by a calendar, but this is a calendar-specific choice. If you provide inconsistent information, calendar-specific disambiguation is performed (which may involve ignoring one or more of the parameters). Related methods (components(_:from:) and components(_:from:to:options:)) take a bit mask parameter that specifies which components to calculate when returning an NSDateComponents object. The bit mask is composed of NSCalendar.Unit constants (see Constants).\nIn a calendar, day, week, weekday, month, and year numbers are generally 1-based, but there may be calendar-specific exceptions. Ordinal numbers, where they occur, are 1-based. Some calendars represented by this API may have to map their basic unit concepts into year/month/week/day/\u2026 nomenclature. For example, a calendar composed of 4 quarters in a year instead of 12 months uses the month unit to represent quarters. The particular values of the unit are defined by each calendar, and are not necessarily consistent with values for that unit in another calendar.\n", "class_type": "class", "typealias": [], "interface_list": ["CVarArg", "Equatable", "Hashable", "NSCopying", "NSSecureCoding"], "class_inherit_list": ["NSObject"], "Methods": [{"params": [{"param_name": ["identifier", "calendarIdentifierConstant"], "param_type": "NSCalendar.Identifier", "param_description": "The identifier for the new calendar. For valid identifiers, see Calendar Identifiers."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [], "return_description": ["The initialized calendar, or nil if the identifier is unknown (if, for example, it is either an unrecognized string or the calendar is not supported by the current version of the operating system)."], "return_type": []}, "method_name": "init", "method_description": "Creates a new calendar specified by a given identifier.", "method_declar": "init?(identifier calendarIdentifierConstant: NSCalendar.Identifier)"}, {"params": [{"param_name": ["calendarIdentifier", "ident"], "param_type": "NSCalendar.Identifier", "param_description": ""}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [], "return_description": ["The initialized calendar, or nil if the identifier is unknown (if, for example, it is either an unrecognized string or the calendar is not supported by the current version of the operating system)."], "return_type": []}, "method_name": "init", "method_description": "Initializes a calendar according to a given identifier.", "method_declar": "init?(calendarIdentifier ident: NSCalendar.Identifier)"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}, {"param_name": ["matchesComponents", "components"], "param_type": "DateComponents", "param_description": ""}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date matches the given components, otherwise false."], "return_type": ["Boo"]}, "method_name": "date", "method_description": "Returns whether a given date matches all of the given date components.", "method_declar": "func date(_ date: Date, matchesComponents components: DateComponents) -> Bool"}, {"params": [{"param_name": ["unit"], "param_type": "NSCalendar.Unit", "param_description": "The component to return. For possible values, see NSCalendar.Unit."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSInteger value for the requested component."], "return_type": ["In"]}, "method_name": "component", "method_description": "Returns the specified date component from a given date.", "method_declar": "func component(_ unit: NSCalendar.Unit, from date: Date) -> Int"}, {"params": [{"param_name": ["unitFlags"], "param_type": "NSCalendar.Unit", "param_description": "The components into which to decompose date."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSDateComponents object containing date decomposed into the components specified by unitFlags. Returns nil if date falls outside of the defined range of the receiver or if the computation cannot be performed."], "return_type": ["DateComponent"]}, "method_name": "components", "method_description": "Returns the date components representing a given date.", "method_declar": "func components(_ unitFlags: NSCalendar.Unit, from date: Date) -> DateComponents"}, {"params": [{"param_name": ["unitFlags"], "param_type": "NSCalendar.Unit", "param_description": "Specifies the components for the returned NSDateComponents object."}, {"param_name": ["from", "startingDate"], "param_type": "Date", "param_description": "The start date for the calculation."}, {"param_name": ["to", "resultDate"], "param_type": "Date", "param_description": "The end date for the calculation."}, {"param_name": ["options", "opts"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation.  For possible values, see NSCalendar.Options.If you specify a \u201cwrap\u201d option (wrapComponents), the specified components are incremented and wrap around to zero/one on overflow, but do not cause higher units to be incremented. When the wrap option is not specified, overflow in a unit carries into the higher units, as in typical addition."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSDateComponents object whose components are specified by unitFlags and calculated from the difference between the resultDate and startDate using the options specified by options. Returns nil if either date falls outside the defined range of the receiver or if the computation cannot be performed."], "return_type": ["DateComponent"]}, "method_name": "components", "method_description": "Returns the difference between two supplied dates as date components.", "method_declar": "func components(_ unitFlags: NSCalendar.Unit, from startingDate: Date, to resultDate: Date, options opts: NSCalendar.Options = []) -> DateComponents"}, {"params": [{"param_name": ["unitFlags"], "param_type": "NSCalendar.Unit", "param_description": "Specifies the components for the returned NSDateComponents object."}, {"param_name": ["from", "startingDateComp"], "param_type": "DateComponents", "param_description": "The start date for the calculation as an NSDateComponents object."}, {"param_name": ["to", "resultDateComp"], "param_type": "DateComponents", "param_description": "The end date for the calculation as an NSDateComponents object."}, {"param_name": ["options"], "param_type": "NSCalendar.Options = []", "param_description": "The options parameter is currently unused."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSDateComponents object whose components are specified by unitFlags and calculated from the difference between the startingDateComp and resultDateComp using the options specified by options. Returns nil if either date falls outside the defined range of the receiver or if the computation cannot be performed."], "return_type": ["DateComponent"]}, "method_name": "components", "method_description": "Returns the difference between start and end dates given as date components.", "method_declar": "func components(_ unitFlags: NSCalendar.Unit, from startingDateComp: DateComponents, to resultDateComp: DateComponents, options: NSCalendar.Options = []) -> DateComponents"}, {"params": [{"param_name": ["in", "timezone"], "param_type": "TimeZone", "param_description": "The time zone to use when returning the components. This value overrides the time zone of the receiving NSCalendar."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSDateComponents object containing all the components from the given date, calculated using the given time zone."], "return_type": ["DateComponent"]}, "method_name": "components", "method_description": "Returns all the date components of a date, as if in a given time zone (instead of the receiving calendar\u2019s time zone).", "method_declar": "func components(in timezone: TimeZone, from date: Date) -> DateComponents"}, {"params": [{"param_name": ["eraValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the era of the given date."}, {"param_name": ["year", "yearValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the year of the given date."}, {"param_name": ["month", "monthValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the month of the given date."}, {"param_name": ["day", "dayValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the day of the given date."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "getEra", "method_description": "Returns by reference the era, year, week of year, and weekday component values for a given date.", "method_declar": "func getEra(_ eraValuePointer: UnsafeMutablePointer<Int>?, year yearValuePointer: UnsafeMutablePointer<Int>?, month monthValuePointer: UnsafeMutablePointer<Int>?, day dayValuePointer: UnsafeMutablePointer<Int>?, from date: Date)"}, {"params": [{"param_name": ["eraValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the era of the given date."}, {"param_name": ["yearForWeekOfYear", "yearValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the year of the given date."}, {"param_name": ["weekOfYear", "weekValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the week of the given date."}, {"param_name": ["weekday", "weekdayValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the weekday of the given date."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "getEra", "method_description": "Returns by reference the era, year, week of year, and weekday component values for a given date.", "method_declar": "func getEra(_ eraValuePointer: UnsafeMutablePointer<Int>?, yearForWeekOfYear yearValuePointer: UnsafeMutablePointer<Int>?, weekOfYear weekValuePointer: UnsafeMutablePointer<Int>?, weekday weekdayValuePointer: UnsafeMutablePointer<Int>?, from date: Date)"}, {"params": [{"param_name": ["hourValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the hour of the given date."}, {"param_name": ["minute", "minuteValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the minute of the given date."}, {"param_name": ["second", "secondValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the second of the given date."}, {"param_name": ["nanosecond", "nanosecondValuePointer"], "param_type": "UnsafeMutablePointer<Int>", "param_description": "Upon return, contains the nanosecond of the given date."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "getHour", "method_description": "Returns by reference the hour, minute, second, and nanosecond component values for a given date.", "method_declar": "func getHour(_ hourValuePointer: UnsafeMutablePointer<Int>?, minute minuteValuePointer: UnsafeMutablePointer<Int>?, second secondValuePointer: UnsafeMutablePointer<Int>?, nanosecond nanosecondValuePointer: UnsafeMutablePointer<Int>?, from date: Date)"}, {"params": [{"param_name": ["of", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The unit for which the maximum range is returned."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The maximum range limits of the values that the unit specified by unit can take on in the receiver."], "return_type": ["NSRang"]}, "method_name": "maximumRange", "method_description": "Returns the maximum range limits of the values that a given unit can take on.", "method_declar": "func maximumRange(of unit: NSCalendar.Unit) -> NSRange"}, {"params": [{"param_name": ["of", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The unit for which the maximum range is returned."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The minimum range limits of the values that the unit specified by unit can take on in the receiver."], "return_type": ["NSRang"]}, "method_name": "minimumRange", "method_description": "Returns the minimum range limits of the values that a given unit can take on.", "method_declar": "func minimumRange(of unit: NSCalendar.Unit) -> NSRange"}, {"params": [{"param_name": ["of", "smaller"], "param_type": "NSCalendar.Unit", "param_description": "The smaller calendar unit "}, {"param_name": ["in", "larger"], "param_type": "NSCalendar.Unit", "param_description": "The larger calendar unit "}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "The absolute time for which the calculation is performed"}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The ordinal number of smaller within larger at the time specified by date. Returns NSNotFound if larger is not logically bigger than smaller in the calendar, or the given combination of units does not make sense (or is a computation which is undefined)."], "return_type": ["In"]}, "method_name": "ordinality", "method_description": "Returns, for a given absolute time, the ordinal number of a smaller calendar unit (such as a day) within a specified larger calendar unit (such as a week).", "method_declar": "func ordinality(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -> Int"}, {"params": [{"param_name": ["of", "smaller"], "param_type": "NSCalendar.Unit", "param_description": "The smaller calendar unit."}, {"param_name": ["in", "larger"], "param_type": "NSCalendar.Unit", "param_description": "The larger calendar unit."}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "The absolute time for which the calculation is performed."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The range of absolute time values smaller can take on in larger at the time specified by date. Returns {NSNotFound, NSNotFound} if larger is not logically bigger than smaller in the calendar, or the given combination of units does not make sense (or is a computation which is undefined)."], "return_type": ["NSRang"]}, "method_name": "range", "method_description": "Returns the range of absolute time values that a smaller calendar unit (such as a day) can take on in a larger calendar unit (such as a month) that includes a specified absolute time.", "method_declar": "func range(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -> NSRange"}, {"params": [{"param_name": ["of", "unit"], "param_type": "NSCalendar.Unit", "param_description": "A calendar unit (see NSCalendar.Unit for possible values)."}, {"param_name": ["start", "datep"], "param_type": "AutoreleasingUnsafeMutablePointer<NSDate>", "param_description": "Upon return, contains the starting time of the calendar unit unit that contains the date date"}, {"param_name": ["interval", "tip"], "param_type": "UnsafeMutablePointer<TimeInterval>", "param_description": "Upon return, contains the duration of the calendar unit unit that contains the date date"}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "A date."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the starting time and duration of a unit could be calculated, otherwise false."], "return_type": ["Boo"]}, "method_name": "range", "method_description": "Returns by reference the starting time and duration of a given calendar unit that contains a given date.", "method_declar": "func range(of unit: NSCalendar.Unit, start datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, for date: Date) -> Bool"}, {"params": [{"param_name": ["ofWeekendStart", "datep"], "param_type": "AutoreleasingUnsafeMutablePointer<NSDate>", "param_description": "Upon return, contains the starting date of the next weekend period."}, {"param_name": ["interval", "tip"], "param_type": "UnsafeMutablePointer<TimeInterval>", "param_description": "Upon return, contains the time interval of the next weekend period."}, {"param_name": ["containing", "date"], "param_type": "Date", "param_description": "The date to use to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date falls within a weekend period, otherwise false."], "return_type": ["Boo"]}, "method_name": "range", "method_description": "Returns whether a given date falls within a weekend period, and if so, returns by reference the start date and time interval of the weekend range.", "method_declar": "func range(ofWeekendStart datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, containing date: Date) -> Bool"}, {"params": [{"param_name": ["for", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["An NSDate instance representing the first moment date of the given date."], "return_type": ["Dat"]}, "method_name": "startOfDay", "method_description": "Returns the first moment of a given date as a date instance.", "method_declar": "func startOfDay(for date: Date) -> Date"}, {"params": [{"param_name": ["startingAfter", "start"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}, {"param_name": ["matching", "comps"], "param_type": "DateComponents", "param_description": "The date components to match. If no components are specified, the enumeration will not be executed. If the nanoseconds component is set to a nonzero value, the resulting dates will have floating point seconds values that most closely match the specified nanoseconds value. Otherwise, the resulting dates will have an integer seconds value."}, {"param_name": ["options", "opts"], "param_type": "NSCalendar.Options", "param_description": "Options for the enumeration. For possible values, see NSCalendar.Options. For usage, see Discussion below."}, {"param_name": ["using", "block"], "param_type": "(Date, Bool, UnsafeMutablePointer<ObjCBool>) -> Void", "param_description": "The block to apply to each enumerated date. The block takes three arguments:dateThe enumerated date.idxWhether date exactly matches the specified date components.stopA reference to a Boolean value. The block can set the value to true to stop further processing of the array. The stop argument is an out-only argument. You should only ever set this Boolean to true within the Block."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "enumerateDates", "method_description": "Computes the dates that match (or most closely match) a given set of components, and calls the block once for each of them, until the enumeration is stopped.", "method_declar": "func enumerateDates(startingAfter start: Date, matching comps: DateComponents, options opts: NSCalendar.Options = [], using block: (Date?, Bool, UnsafeMutablePointer<ObjCBool>) -> Void)"}, {"params": [{"param_name": ["after", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}, {"param_name": ["matching", "comps"], "param_type": "DateComponents", "param_description": "The date components to match."}, {"param_name": ["options"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. For possible values, see NSCalendar.Options."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate object."], "return_type": ["Dat"]}, "method_name": "nextDate", "method_description": "Returns the next date after a given date matching the given components.", "method_declar": "func nextDate(after date: Date, matching comps: DateComponents, options: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["after", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}, {"param_name": ["matchingHour", "hourValue"], "param_type": "Int", "param_description": "The value for the hour component."}, {"param_name": ["minute", "minuteValue"], "param_type": "Int", "param_description": "The value for the minute component."}, {"param_name": ["second", "secondValue"], "param_type": "Int", "param_description": "The value for the second component."}, {"param_name": ["options"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. For possible values, see NSCalendar.Options."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate object."], "return_type": ["Dat"]}, "method_name": "nextDate", "method_description": "Returns the next date after a given date that matches the given hour, minute, and second, component values.", "method_declar": "func nextDate(after date: Date, matchingHour hourValue: Int, minute minuteValue: Int, second secondValue: Int, options: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["after", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}, {"param_name": ["matching", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The component to use. For possible values, see NSCalendar.Unit."}, {"param_name": ["value"], "param_type": "Int", "param_description": "The value for the given component."}, {"param_name": ["options"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. For possible values, see NSCalendar.Options."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate object."], "return_type": ["Dat"]}, "method_name": "nextDate", "method_description": "Returns the next date after a given date matching the given calendar unit value.", "method_declar": "func nextDate(after date: Date, matching unit: NSCalendar.Unit, value: Int, options: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["from", "comps"], "param_type": "DateComponents", "param_description": "The components from which to calculate the returned date."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate object representing the absolute time calculated from comps. Returns nil if the receiver cannot convert the components given in comps into an NSDate object."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a date representing the absolute time calculated from given components.", "method_declar": "func date(from comps: DateComponents) -> Date?"}, {"params": [{"param_name": ["byAdding", "comps"], "param_type": "DateComponents", "param_description": "The components to add to date."}, {"param_name": ["to", "date"], "param_type": "Date", "param_description": "The date to which comps are added."}, {"param_name": ["options", "opts"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. See NSCalendar.Options for possible values.If you specify no options, overflow in a unit carries into the higher units (as in typical addition)."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate object representing the absolute time calculated by adding to date the calendrical components specified by comps using the options specified by opts. Returns nil if date falls outside the defined range of the receiver or if the computation cannot be performed."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a date representing the absolute time calculated by adding given components to a given date.", "method_declar": "func date(byAdding comps: DateComponents, to date: Date, options opts: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["byAdding", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The unit to use for the calculation. For possible values, see NSCalendar.Unit."}, {"param_name": ["value"], "param_type": "Int", "param_description": "The value for the given unit."}, {"param_name": ["to", "date"], "param_type": "Date", "param_description": "The date to use to perform the calculation."}, {"param_name": ["options"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. See NSCalendar.Options for possible values. If you specify a \u201cwrap\u201d option (wrapComponents), the specified components are incremented and wrap around to zero/one on overflow, but do not cause higher units to be incremented. When the wrap option is false, overflow in a unit carries into the higher units, as in typical addition."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate object representing the absolute time calculated by adding to date the value of the given calendrical unit using the options specified by options. Returns nil if date falls outside the defined range of the receiver or if the computation cannot be performed."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a date representing the absolute time calculated by adding the value of a given component to a given date.", "method_declar": "func date(byAdding unit: NSCalendar.Unit, value: Int, to date: Date, options: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["bySettingHour", "h"], "param_type": "Int", "param_description": "The hour value."}, {"param_name": ["minute", "m"], "param_type": "Int", "param_description": "The minute value."}, {"param_name": ["second", "s"], "param_type": "Int", "param_description": "The second value."}, {"param_name": ["of", "date"], "param_type": "Date", "param_description": "The date to use to perform the calculation."}, {"param_name": ["options", "opts"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. For possible values, see NSCalendar.Options."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate instance representing the date calculated by setting the given hour, minute, and second, to a given time. If no such time exists for the specified components, the next available date is returned, which may be on a different calendar day."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Creates a new date calculated with the given time.", "method_declar": "func date(bySettingHour h: Int, minute m: Int, second s: Int, of date: Date, options opts: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["bySettingUnit", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The unit to set with the given value. For possible values, see NSCalendar.Unit."}, {"param_name": ["value", "v"], "param_type": "Int", "param_description": "The value to set for the given calendar unit."}, {"param_name": ["of", "date"], "param_type": "Date", "param_description": "The date to use to perform the calculation."}, {"param_name": ["options", "opts"], "param_type": "NSCalendar.Options = []", "param_description": "Options for the calculation. For possible values, see NSCalendar.Options."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate instance representing the date calculated by setting a specific component of a given date to a given value. If the unit already has that value, this may result in a date which is the same as the given date. If no such time exists for the specified components, the next available date is returned, which may be on a different calendar day."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a new date representing the date calculated by setting a specific component of a given date to a given value, while trying to keep lower components the same.", "method_declar": "func date(bySettingUnit unit: NSCalendar.Unit, value v: Int, of date: Date, options opts: NSCalendar.Options = []) -> Date?"}, {"params": [{"param_name": ["era", "eraValue"], "param_type": "Int", "param_description": "The value to set for the era."}, {"param_name": ["year", "yearValue"], "param_type": "Int", "param_description": "The value to set for the year."}, {"param_name": ["month", "monthValue"], "param_type": "Int", "param_description": "The value to set for the month."}, {"param_name": ["day", "dayValue"], "param_type": "Int", "param_description": "The value to set for the day."}, {"param_name": ["hour", "hourValue"], "param_type": "Int", "param_description": "The value to set for the hour."}, {"param_name": ["minute", "minuteValue"], "param_type": "Int", "param_description": "The value to set for the minute."}, {"param_name": ["second", "secondValue"], "param_type": "Int", "param_description": "The value to set for the second."}, {"param_name": ["nanosecond", "nanosecondValue"], "param_type": "Int", "param_description": "The value to set for the nanosecond."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate instance created with the given components, or nil if the components do not correspond to a valid date."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a date created with the given components.", "method_declar": "func date(era eraValue: Int, year yearValue: Int, month monthValue: Int, day dayValue: Int, hour hourValue: Int, minute minuteValue: Int, second secondValue: Int, nanosecond nanosecondValue: Int) -> Date?"}, {"params": [{"param_name": ["era", "eraValue"], "param_type": "Int", "param_description": "The value for the era component."}, {"param_name": ["yearForWeekOfYear", "yearValue"], "param_type": "Int", "param_description": "The value for the year component."}, {"param_name": ["weekOfYear", "weekValue"], "param_type": "Int", "param_description": "The value for the week-of-year component."}, {"param_name": ["weekday", "weekdayValue"], "param_type": "Int", "param_description": "The value to use as the weekday."}, {"param_name": ["hour", "hourValue"], "param_type": "Int", "param_description": "The value for the hour component."}, {"param_name": ["minute", "minuteValue"], "param_type": "Int", "param_description": "The value for the minute component."}, {"param_name": ["second", "secondValue"], "param_type": "Int", "param_description": "The value for the second component."}, {"param_name": ["nanosecond", "nanosecondValue"], "param_type": "Int", "param_description": "The value for the nanosecond component."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new NSDate instance created with the given components based on a week-of-year calculation, or nil if the components do not correspond to a valid date."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a new date created with the given components base on a week-of-year value.", "method_declar": "func date(era eraValue: Int, yearForWeekOfYear yearValue: Int, weekOfYear weekValue: Int, weekday weekdayValue: Int, hour hourValue: Int, minute minuteValue: Int, second secondValue: Int, nanosecond nanosecondValue: Int) -> Date?"}, {"params": [{"param_name": ["datep"], "param_type": "AutoreleasingUnsafeMutablePointer<NSDate>", "param_description": "Upon return, contains the starting date of the next weekend period."}, {"param_name": ["interval", "tip"], "param_type": "UnsafeMutablePointer<TimeInterval>", "param_description": "Upon return, contains the time interval of the next weekend period."}, {"param_name": ["options"], "param_type": "NSCalendar.Options", "param_description": "Options for the calculation. If you specify a backward search option (searchBackwards), the starting date and time interval range of the preceding weekend period will be returned by reference instead."}, {"param_name": ["after", "date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["false if the calendar and locale do not have the concept of a weekend, otherwise true."], "return_type": ["Boo"]}, "method_name": "nextWeekendStart", "method_description": "Returns by reference the starting date and time interval range of the next weekend period after a given date.", "method_declar": "func nextWeekendStart(_ datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, options: NSCalendar.Options = [], after date: Date) -> Bool"}, {"params": [{"param_name": ["date1"], "param_type": "Date", "param_description": "The first date to compare."}, {"param_name": ["to", "date2"], "param_type": "Date", "param_description": "The second date to compare."}, {"param_name": ["toUnitGranularity", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The smallest unit that must, along with all larger units, be equal for the given dates to be considered the same. For possible values, see NSCalendar.Unit."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["NSOrderedSame if the dates are the same down to the given granularity, otherwise NSOrderedAscending or NSOrderedDescending."], "return_type": ["ComparisonResul"]}, "method_name": "compare", "method_description": "Indicates the ordering of two given dates based on their components down to a given unit granularity.", "method_declar": "func compare(_ date1: Date, to date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> ComparisonResult"}, {"params": [{"param_name": ["date1"], "param_type": "Date", "param_description": "The first date to compare."}, {"param_name": ["equalTo", "date2"], "param_type": "Date", "param_description": "The second date to compare."}, {"param_name": ["toUnitGranularity", "unit"], "param_type": "NSCalendar.Unit", "param_description": "The smallest unit that must, along with all larger units, be equal in the given dates. For possible values, see NSCalendar.Unit."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if both dates have equal date component for all units greater than or equal to the given unit, otherwise false."], "return_type": ["Boo"]}, "method_name": "isDate", "method_description": "Indicates whether two dates are equal to a given unit of granularity.", "method_declar": "func isDate(_ date1: Date, equalTo date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> Bool"}, {"params": [{"param_name": ["date1"], "param_type": "Date", "param_description": "The first date to compare."}, {"param_name": ["inSameDayAs", "date2"], "param_type": "Date", "param_description": "The second date to compare."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if both dates are within the same day, otherwise false."], "return_type": ["Boo"]}, "method_name": "isDate", "method_description": "Indicates whether two dates are in the same day.", "method_declar": "func isDate(_ date1: Date, inSameDayAs date2: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is in \u201ctoday,\u201d otherwise false."], "return_type": ["Boo"]}, "method_name": "isDateInToday", "method_description": "Indicates whether the given date is in \u201ctoday.\u201d", "method_declar": "func isDateInToday(_ date: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is in \u201ctomorrow,\u201d otherwise false."], "return_type": ["Boo"]}, "method_name": "isDateInTomorrow", "method_description": "Indicates whether the given date is in \u201ctomorrow.\u201d", "method_declar": "func isDateInTomorrow(_ date: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is within a weekend period, otherwise false."], "return_type": ["Boo"]}, "method_name": "isDateInWeekend", "method_description": "Indicates whether a given date falls within a weekend period, as defined by the calendar and the calendar's locale.", "method_declar": "func isDateInWeekend(_ date: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The date for which to perform the calculation."}], "class_name": "NSCalendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is in \u201cyesterday,\u201d otherwise false."], "return_type": ["Boo"]}, "method_name": "isDateInYesterday", "method_description": "Indicates whether the given date is in \u201cyesterday.\u201d", "method_declar": "func isDateInYesterday(_ date: Date) -> Bool"}], "class_name": "NSCalendar", "Vars": [{"var_description": "The user\u2019s current calendar.", "var_type": "Calendar", "is_static": false, "var_name": "current"}, {"var_description": "A calendar that tracks changes to user\u2019s preferred calendar.", "var_type": "Calendar", "is_static": false, "var_name": "autoupdatingCurrent"}, {"var_description": "An identifier for the calendar.", "var_type": "NSCalendar.Identifier", "is_static": false, "var_name": "calendarIdentifier"}, {"var_description": "The index of the first weekday of the receiver.", "var_type": "Int", "is_static": false, "var_name": "firstWeekday"}, {"var_description": "The locale of the receiver.", "var_type": "Locale", "is_static": false, "var_name": "locale"}, {"var_description": "The time zone for the calendar.", "var_type": "TimeZone", "is_static": false, "var_name": "timeZone"}, {"var_description": "The minimum number of days in the first week of the receiver.", "var_type": "Int", "is_static": false, "var_name": "minimumDaysInFirstWeek"}, {"var_description": "Specifies that the components specified for an NSDateComponents object should be incremented and wrap around to zero/one on overflow, but should not cause higher units to be incremented.DeprecatedUse wrapComponents instead.", "var_type": "Int", "is_static": false, "var_name": "NSWrapCalendarComponents"}, {"var_description": "The symbol used to represent \u201cAM\u201d for this calendar.", "var_type": "String", "is_static": false, "var_name": "amSymbol"}, {"var_description": "The symbol used to represent \u201cPM\u201d for this calendar.", "var_type": "String", "is_static": false, "var_name": "pmSymbol"}, {"var_description": "A list of weekdays in this calendar.", "var_type": "[String]", "is_static": false, "var_name": "weekdaySymbols"}, {"var_description": "A list of shorter-named weekdays in this calendar.", "var_type": "[String]", "is_static": false, "var_name": "shortWeekdaySymbols"}, {"var_description": "A list of very-shortly-named weekdays in this calendar.", "var_type": "[String]", "is_static": false, "var_name": "veryShortWeekdaySymbols"}, {"var_description": "A list of standalone weekday symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "standaloneWeekdaySymbols"}, {"var_description": "A list of short standalone weekday symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneWeekdaySymbols"}, {"var_description": "A list of very short standalone weekday symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "veryShortStandaloneWeekdaySymbols"}, {"var_description": "A list of month symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "monthSymbols"}, {"var_description": "A list of short month symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "shortMonthSymbols"}, {"var_description": "A list of very short month symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "veryShortMonthSymbols"}, {"var_description": "A list of standalone month symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "standaloneMonthSymbols"}, {"var_description": "A list of short standalone month symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneMonthSymbols"}, {"var_description": "A list of very short month symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "veryShortStandaloneMonthSymbols"}, {"var_description": "A list of quarter symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "quarterSymbols"}, {"var_description": "A list of short quarter symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "shortQuarterSymbols"}, {"var_description": "A list of standalone quarter symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "standaloneQuarterSymbols"}, {"var_description": "A list of short standalone quarter symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneQuarterSymbols"}, {"var_description": "A list of era symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "eraSymbols"}, {"var_description": "A list of long era symbols for this calendar.", "var_type": "[String]", "is_static": false, "var_name": "longEraSymbols"}, {"var_description": "A notification that is posted whenever the calendar day of the system changes, as determined by the system calendar, locale, and time zone.", "var_type": "NSNotification.Name", "is_static": false, "var_name": "NSCalendarDayChanged"}]}