{"class_description": "The range of valid integer values is 0..<INT_MAX-1. Anything outside this range is an error.\n", "Methods": [{"method_description": "Initializes an empty index set.", "method_name": "init", "params": [], "class_name": "IndexSet", "method_declar": "init()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a set containing the elements of the given array literal.", "method_name": "init", "params": [{"param_type": "Int...", "param_description": "A list of elements of the new set.", "param_name": ["arrayLiteral"]}], "class_name": "IndexSet", "method_declar": "init(arrayLiteral: Int...)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes an index set with a single integer.", "method_name": "init", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "init(integer: IndexSet.Element)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Initializes an index set with a range of integers.", "method_name": "init", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "init(integersIn range: Range<IndexSet.Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the count of integers in self that intersect range.", "method_name": "count", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "", "param_name": ["in", "range"]}], "class_name": "IndexSet", "method_declar": "func count(in range: Range<IndexSet.Element>) -> Int", "return_value": {"return_description": [], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Intersects the IndexSet with other.", "method_name": "formIntersection", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "mutating func formIntersection(_ other: IndexSet)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Exclusive or the IndexSet with other.", "method_name": "formSymmetricDifference", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "mutating func formSymmetricDifference(_ other: IndexSet)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Union the IndexSet with other.", "method_name": "formUnion", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "mutating func formUnion(_ other: IndexSet)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Intersects the IndexSet with other.", "method_name": "intersection", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "func intersection(_ other: IndexSet) -> IndexSet", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Exclusive or the IndexSet with other.", "method_name": "symmetricDifference", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "func symmetricDifference(_ other: IndexSet) -> IndexSet", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Union the IndexSet with other.", "method_name": "union", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "func union(_ other: IndexSet) -> IndexSet", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Insert an integer into the IndexSet.", "method_name": "insert", "params": [{"param_type": "IndexSet.Element) -> (inserte", "param_description": "", "param_name": ["integer"]}, {"param_type": "Bool", "param_description": "", "param_name": ["IndexSet.Element)", "->", "(inserted"]}, {"param_type": "IndexSet.Element", "param_description": "", "param_name": ["memberAfterInsert"]}], "class_name": "IndexSet", "method_declar": "@discardableResult mutating func insert(_ integer: IndexSet.Element) -> (inserted: Bool, memberAfterInsert: IndexSet.Element)", "return_value": {"return_description": [], "return_name": [["inserted"], ["memberAfterInsert"]], "return_type": ["Bool", "IndexSet.Element"]}, "is_static": false}, {"method_description": "Insert a range of integers into the IndexSet.", "method_name": "insert", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "mutating func insert(integersIn range: Range<IndexSet.Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Insert an integer into the IndexSet.", "method_name": "update", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["with", "integer"]}], "class_name": "IndexSet", "method_declar": "@discardableResult mutating func update(with integer: IndexSet.Element) -> IndexSet.Element?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Elemen"]}, "is_static": false}, {"method_description": "Remove an integer from the IndexSet.", "method_name": "remove", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "@discardableResult mutating func remove(_ integer: IndexSet.Element) -> IndexSet.Element?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Elemen"]}, "is_static": false}, {"method_description": "Remove a range of integers from the IndexSet.", "method_name": "remove", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "mutating func remove(integersIn range: Range<IndexSet.Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Remove a range of integers from the IndexSet.", "method_name": "remove", "params": [{"param_type": "ClosedRange<IndexSet.Element>", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "mutating func remove(integersIn range: ClosedRange<IndexSet.Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Remove all values from the IndexSet.", "method_name": "removeAll", "params": [], "class_name": "IndexSet", "method_declar": "mutating func removeAll()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements of the given set from this set.", "method_name": "subtract", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "mutating func subtract(_ other: IndexSet)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a new set containing the elements of this set that do not occur in the given set.", "method_name": "subtracting", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "func subtracting(_ other: IndexSet) -> IndexSet", "return_value": {"return_description": ["A new set."], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Returns true if self contains integer.", "method_name": "contains", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "func contains(_ integer: IndexSet.Element) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns true if self contains all of the integers in indexSet.", "method_name": "contains", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["integersIn", "indexSet"]}], "class_name": "IndexSet", "method_declar": "func contains(integersIn indexSet: IndexSet) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns true if self contains all of the integers in range.", "method_name": "contains", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "func contains(integersIn range: Range<IndexSet.Element>) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "IndexSet", "method_declar": "func contains(where predicate: (Int) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns true if self intersects any of the integers in range.", "method_name": "intersects", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "func intersects(integersIn range: Range<IndexSet.Element>) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}], "class_name": "IndexSet", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set has no members in common with the given set.", "method_name": "isDisjoint", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["with", "other"]}], "class_name": "IndexSet", "method_declar": "func isDisjoint(with other: IndexSet) -> Bool", "return_value": {"return_description": ["true if the set has no elements in common with other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether this set is a strict subset of the given set.", "method_name": "isStrictSubset", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["of", "other"]}], "class_name": "IndexSet", "method_declar": "func isStrictSubset(of other: IndexSet) -> Bool", "return_value": {"return_description": ["true if the set is a strict subset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether this set is a strict superset of the given set.", "method_name": "isStrictSuperset", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["of", "other"]}], "class_name": "IndexSet", "method_declar": "func isStrictSuperset(of other: IndexSet) -> Bool", "return_value": {"return_description": ["true if the set is a strict superset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a subset of another set.", "method_name": "isSubset", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["of", "other"]}], "class_name": "IndexSet", "method_declar": "func isSubset(of other: IndexSet) -> Bool", "return_value": {"return_description": ["true if the set is a subset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value that indicates whether the set is a superset of the given set.", "method_name": "isSuperset", "params": [{"param_type": "IndexSet", "param_description": "A set of the same type as the current set.", "param_name": ["of", "other"]}], "class_name": "IndexSet", "method_declar": "func isSuperset(of other: IndexSet) -> Bool", "return_value": {"return_description": ["true if the set is a superset of other; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns the index that follows the given index in the set.", "method_name": "index", "params": [{"param_type": "IndexSet.Index", "param_description": "", "param_name": ["after", "i"]}], "class_name": "IndexSet", "method_declar": "func index(after i: IndexSet.Index) -> IndexSet.Index", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Inde"]}, "is_static": false}, {"method_description": "Returns the index that precedes the given index in the set.", "method_name": "index", "params": [{"param_type": "IndexSet.Index", "param_description": "", "param_name": ["before", "i"]}], "class_name": "IndexSet", "method_declar": "func index(before i: IndexSet.Index) -> IndexSet.Index", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Inde"]}, "is_static": false}, {"method_description": "Modifies the given index to refer to the item after the one it currently refers to.", "method_name": "formIndex", "params": [{"param_type": "inout IndexSet.Index", "param_description": "", "param_name": ["after", "i"]}], "class_name": "IndexSet", "method_declar": "func formIndex(after i: inout IndexSet.Index)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Modifies the given index to refer to the item before the one it currently refers to.", "method_name": "formIndex", "params": [{"param_type": "inout IndexSet.Index", "param_description": "", "param_name": ["before", "i"]}], "class_name": "IndexSet", "method_declar": "func formIndex(before i: inout IndexSet.Index)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Return a Range<IndexSet.Index> which can be used to subscript the index set.", "method_name": "indexRange", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "The range of integers to include.", "param_name": ["in", "range"]}], "class_name": "IndexSet", "method_declar": "func indexRange(in range: Range<IndexSet.Element>) -> Range<IndexSet.Index>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<IndexSet.Index"]}, "is_static": false}, {"method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "IndexSet", "method_declar": "func first(where predicate: (Int) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence.", "method_name": "max", "params": [], "class_name": "IndexSet", "method_declar": "@warn_unqualified_access func max() -> Int?", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "params": [{"param_type": "(Int, Int) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "IndexSet", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (Int, Int) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence.", "method_name": "min", "params": [], "class_name": "IndexSet", "method_declar": "@warn_unqualified_access func min() -> Int?", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "params": [{"param_type": "(Int, Int) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "IndexSet", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (Int, Int) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns an integer contained in self which is less than or equal to integer, or nil if a result could not be found.", "method_name": "integerLessThanOrEqualTo", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "func integerLessThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Elemen"]}, "is_static": false}, {"method_description": "Returns an integer contained in self which is greater than integer, or nil if a result could not be found.", "method_name": "integerGreaterThan", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "func integerGreaterThan(_ integer: IndexSet.Element) -> IndexSet.Element?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Elemen"]}, "is_static": false}, {"method_description": "Returns an integer contained in self which is greater than or equal to integer, or nil if a result could not be found.", "method_name": "integerGreaterThanOrEqualTo", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "func integerGreaterThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Elemen"]}, "is_static": false}, {"method_description": "Returns an integer contained in self which is less than integer, or nil if a result could not be found.", "method_name": "integerLessThan", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["integer"]}], "class_name": "IndexSet", "method_declar": "func integerLessThan(_ integer: IndexSet.Element) -> IndexSet.Element?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.Elemen"]}, "is_static": false}, {"method_description": "Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.", "method_name": "filter", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.", "param_name": ["isIncluded"]}], "class_name": "IndexSet", "method_declar": "func filter(_ isIncluded: (Int) throws -> Bool) rethrows -> [Int]", "return_value": {"return_description": ["An array of the elements that isIncluded allowed."], "return_name": [""], "return_type": ["[Int"]}, "is_static": false}, {"method_description": "Returns an IndexSet filtered according to the result of includeInteger.", "method_name": "filteredIndexSet", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "A range of integers. For each integer in the range that intersects the integers in the IndexSet, then the includeInteger predicate will be invoked.", "param_name": ["in", "range"]}, {"param_type": "(IndexSet.Element) throws -> Bool", "param_description": "The predicate which decides if an integer will be included in the result or not.", "param_name": ["includeInteger"]}], "class_name": "IndexSet", "method_declar": "func filteredIndexSet(in range: Range<IndexSet.Element>, includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Returns an IndexSet filtered according to the result of includeInteger.", "method_name": "filteredIndexSet", "params": [{"param_type": "ClosedRange<IndexSet.Element>", "param_description": "A range of integers. For each integer in the range that intersects the integers in the IndexSet, then the includeInteger predicate will be invoked.", "param_name": ["in", "range"]}, {"param_type": "(IndexSet.Element) throws -> Bool", "param_description": "The predicate which decides if an integer will be included in the result or not.", "param_name": ["includeInteger"]}], "class_name": "IndexSet", "method_declar": "func filteredIndexSet(in range: ClosedRange<IndexSet.Element>, includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Returns an IndexSet filtered according to the result of includeInteger.", "method_name": "filteredIndexSet", "params": [{"param_type": "(IndexSet.Element) throws -> Bool", "param_description": "The predicate which decides if an integer will be included in the result or not.", "param_name": ["includeInteger"]}], "class_name": "IndexSet", "method_declar": "func filteredIndexSet(includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSe"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "IndexSet", "method_declar": "func prefix(_ maxLength: Int) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "params": [{"param_type": "IndexSet.Index", "param_description": "", "param_name": ["through", "position"]}], "class_name": "IndexSet", "method_declar": "func prefix(through position: IndexSet.Index) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "params": [{"param_type": "IndexSet.Index", "param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_name": ["upTo", "end"]}], "class_name": "IndexSet", "method_declar": "func prefix(upTo end: IndexSet.Index) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "IndexSet", "method_declar": "func prefix(while predicate: (Int) throws -> Bool) rethrows -> Slice<IndexSet>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "IndexSet", "method_declar": "func suffix(_ maxLength: Int) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "params": [{"param_type": "IndexSet.Index", "param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_name": ["from", "start"]}], "class_name": "IndexSet", "method_declar": "func suffix(from start: IndexSet.Index) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "params": [{"param_type": "Int", "param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "IndexSet", "method_declar": "func dropLast(_ k: Int) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "IndexSet", "method_declar": "func dropFirst(_ k: Int = 1) -> Slice<IndexSet>", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "IndexSet", "method_declar": "func drop(while predicate: (Int) throws -> Bool) rethrows -> Slice<IndexSet>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Slice<IndexSet"]}, "is_static": false}, {"method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_name": ["initialResult"]}, {"param_type": "(Result, Int) throws -> Result", "param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_name": ["nextPartialResult"]}], "class_name": "IndexSet", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Int) throws -> Result) rethrows -> Result", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Resul"]}, "is_static": false}, {"method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "params": [{"param_type": "(Int) throws -> Void", "param_description": "A closure that takes an element of the sequence as a parameter.", "param_name": ["body"]}], "class_name": "IndexSet", "method_declar": "func forEach(_ body: (Int) throws -> Void) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrow"]}, "is_static": false}, {"method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "params": [], "class_name": "IndexSet", "method_declar": "func enumerated() -> EnumeratedSequence<IndexSet>", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<IndexSet"]}, "is_static": false}, {"method_description": "Returns an iterator over the elements of this sequence.", "method_name": "makeIterator", "params": [], "class_name": "IndexSet", "method_declar": "func makeIterator() -> IndexingIterator<IndexSet>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<IndexSet"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted.", "method_name": "sorted", "params": [], "class_name": "IndexSet", "method_declar": "func sorted() -> [Int]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "params": [{"param_type": "(Int, Int) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "IndexSet", "method_declar": "func sorted(by areInIncreasingOrder: (Int, Int) throws -> Bool) rethrows -> [Int]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int"]}, "is_static": false}, {"method_description": "Returns a view presenting the elements of the collection in reverse order.", "method_name": "reversed", "params": [], "class_name": "IndexSet", "method_declar": "func reversed() -> ReversedCollection<IndexSet>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<IndexSet"]}, "is_static": false}, {"method_description": "For a positive delta, shifts the indexes in [index, INT_MAX] to the right, thereby inserting an \u201cempty space\u201d [index, delta], for a negative delta, shifts the indexes in [index, INT_MAX] to the left, thereby deleting the indexes in the range [index - delta, delta].", "method_name": "shift", "params": [{"param_type": "IndexSet.Element", "param_description": "", "param_name": ["startingAt", "integer"]}, {"param_type": "Int", "param_description": "", "param_name": ["by", "delta"]}], "class_name": "IndexSet", "method_declar": "mutating func shift(startingAt integer: IndexSet.Element, by delta: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "params": [{"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool", "param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_name": ["omittingEmptySubsequences"]}, {"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_name": ["whereSeparator", "isSeparator"]}], "class_name": "IndexSet", "method_declar": "func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Int) throws -> Bool) rethrows -> [Slice<IndexSet>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "method_name": "split", "params": [{"param_type": "Int", "param_description": "The element that should be split upon.", "param_name": ["separator"]}, {"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool = true", "param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.", "param_name": ["omittingEmptySubsequences"]}], "class_name": "IndexSet", "method_declar": "func split(separator: Int, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Slice<IndexSet>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[Slice<IndexSet>"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "params": [{"param_type": "IndexSet", "param_description": "A value to compare.", "param_name": ["lhs"]}, {"param_type": "IndexSet", "param_description": "Another value to compare.", "param_name": ["rhs"]}], "class_name": "IndexSet", "method_declar": "static func != (lhs: IndexSet, rhs: IndexSet) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": true}, {"method_description": "", "method_name": "==", "params": [{"param_type": "IndexSet", "param_description": "", "param_name": ["lhs"]}, {"param_type": "IndexSet", "param_description": "", "param_name": ["rhs"]}], "class_name": "IndexSet", "method_declar": "static func == (lhs: IndexSet, rhs: IndexSet) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": true}, {"method_description": "Returns a Range-based view of self.", "method_name": "rangeView", "params": [{"param_type": "Range<IndexSet.Element>", "param_description": "A subrange of self to view.", "param_name": ["of", "range"]}], "class_name": "IndexSet", "method_declar": "func rangeView(of range: Range<IndexSet.Element>) -> IndexSet.RangeView", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeVie"]}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "Decoder", "param_description": "", "param_name": ["from", "decoder"]}], "class_name": "IndexSet", "method_declar": "init(from decoder: Decoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "init<R>(integersIn range: R) where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_name": ["predicate"]}], "class_name": "IndexSet", "method_declar": "func allSatisfy(_ predicate: (Int) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "params": [{"param_type": "(Int) throws -> ElementOfResult", "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_name": ["transform"]}], "class_name": "IndexSet", "method_declar": "func compactMap<ElementOfResult>(_ transform: (Int) throws -> ElementOfResult?) rethrows -> [ElementOfResult]", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["[ElementOfResult"]}, "is_static": false}, {"method_description": "", "method_name": "contains", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "func contains<R>(integersIn range: R) -> Bool where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "", "method_name": "count", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["in", "range"]}], "class_name": "IndexSet", "method_declar": "func count<R>(in range: R) -> Int where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Returns the distance between two indices.", "method_name": "distance", "params": [{"param_type": "IndexSet.Index", "param_description": "A valid index of the collection.", "param_name": ["from", "start"]}, {"param_type": "IndexSet.Index", "param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_name": ["to", "end"]}], "class_name": "IndexSet", "method_declar": "func distance(from start: IndexSet.Index, to end: IndexSet.Index) -> Int", "return_value": {"return_description": ["The distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(Int, OtherSequence.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "IndexSet", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Int, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "", "method_name": "encode", "params": [{"param_type": "Encoder", "param_description": "", "param_name": ["to", "encoder"]}], "class_name": "IndexSet", "method_declar": "func encode(to encoder: Encoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the first index where the specified value appears in the collection.", "method_name": "firstIndex", "params": [{"param_type": "Int", "param_description": "An element to search for in the collection.", "param_name": ["of", "element"]}], "class_name": "IndexSet", "method_declar": "func firstIndex(of element: Int) -> IndexSet.Index?", "return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["IndexSet.Inde"]}, "is_static": false}, {"method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "IndexSet", "method_declar": "func firstIndex(where predicate: (Int) throws -> Bool) rethrows -> IndexSet.Index?", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "params": [{"param_type": "inout IndexSet.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "IndexSet", "method_declar": "func formIndex(_ i: inout IndexSet.Index, offsetBy distance: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "params": [{"param_type": "inout IndexSet.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "IndexSet.Index", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "IndexSet", "method_declar": "func formIndex(_ i: inout IndexSet.Index, offsetBy distance: Int, limitedBy limit: IndexSet.Index) -> Bool", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "params": [{"param_type": "IndexSet.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "", "param_name": ["offsetBy", "distance"]}], "class_name": "IndexSet", "method_declar": "func index(_ i: IndexSet.Index, offsetBy distance: Int) -> IndexSet.Index", "return_value": {"return_description": ["An index offset by n from the index i. If n is positive, this is the same value as the result of n calls to index(after:). If n is negative, this is the same value as the result of -n calls to index(before:)."], "return_name": [""], "return_type": ["IndexSet.Inde"]}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "params": [{"param_type": "IndexSet.Index", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "", "param_name": ["offsetBy", "distance"]}, {"param_type": "IndexSet.Index", "param_description": "A valid index of the collection to use as a limit. If n > 0, a limit that is less than i has no effect. Likewise, if n < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "IndexSet", "method_declar": "func index(_ i: IndexSet.Index, offsetBy distance: Int, limitedBy limit: IndexSet.Index) -> IndexSet.Index?", "return_value": {"return_description": ["An index offset by n from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["IndexSet.Inde"]}, "is_static": false}, {"method_description": "", "method_name": "indexRange", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["in", "range"]}], "class_name": "IndexSet", "method_declar": "func indexRange<R>(in range: R) -> Range<IndexSet.Index> where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Range<IndexSet.Index>"]}, "is_static": false}, {"method_description": "", "method_name": "insert", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "mutating func insert<R>(integersIn range: R) where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "intersects", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["integersIn", "range"]}], "class_name": "IndexSet", "method_declar": "func intersects<R>(integersIn range: R) -> Bool where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the last element of the sequence that satisfies the given predicate.", "method_name": "last", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "IndexSet", "method_declar": "func last(where predicate: (Int) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the last index where the specified value appears in the collection.", "method_name": "lastIndex", "params": [{"param_type": "Int", "param_description": "An element to search for in the collection.", "param_name": ["of", "element"]}], "class_name": "IndexSet", "method_declar": "func lastIndex(of element: Int) -> IndexSet.Index?", "return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["IndexSet.Inde"]}, "is_static": false}, {"method_description": "Returns the index of the last element in the collection that matches the given predicate.", "method_name": "lastIndex", "params": [{"param_type": "(Int) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "IndexSet", "method_declar": "func lastIndex(where predicate: (Int) throws -> Bool) rethrows -> IndexSet.Index?", "return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "IndexSet", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(Int, Int) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "IndexSet", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Int, Int) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(Int) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "IndexSet", "method_declar": "func map<T>(_ transform: (Int) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(Int) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "IndexSet", "method_declar": "func map<T>(_ transform: (Int) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T"]}, "is_static": false}, {"method_description": "Returns a random element of the collection.", "method_name": "randomElement", "params": [], "class_name": "IndexSet", "method_declar": "func randomElement() -> Int?", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when choosing a random element.", "param_name": ["using", "generator"]}], "class_name": "IndexSet", "method_declar": "func randomElement<T>(using generator: inout T) -> Int? where T : RandomNumberGenerator", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "", "method_name": "rangeView", "params": [{"param_type": "RangeExpression", "param_description": "", "param_name": ["of", "range"]}], "class_name": "IndexSet", "method_declar": "func rangeView<R>(of range: R) -> IndexSet.RangeView where R : RangeExpression, R.Bound == IndexSet.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexSet.RangeView"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "params": [], "class_name": "IndexSet", "method_declar": "func shuffled() -> [Int]", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Int"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when shuffling the sequence.", "param_name": ["using", "generator"]}], "class_name": "IndexSet", "method_declar": "func shuffled<T>(using generator: inout T) -> [Int] where T : RandomNumberGenerator", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Int]"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}, {"param_type": "(Int, PossiblePrefix.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "IndexSet", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Int, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}], "class_inherit_list": [], "class_name": "IndexSet", "typealias": ["typealias IndexSet.ReferenceType = NSIndexSet", "typealias IndexSet.Element = Int"], "Vars": [{"var_description": "The beginning index in the set.", "var_type": "IndexSet.Index", "is_static": false, "var_name": "startIndex"}, {"var_description": "The ending index in the set.", "var_type": "IndexSet.Index", "is_static": false, "var_name": "endIndex"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<IndexSet>", "is_static": false, "var_name": "lazy"}, {"var_description": "Returns a Range-based view of the entire contents of self.", "var_type": "IndexSet.RangeView", "is_static": false, "var_name": "rangeView"}, {"var_description": "A textual description of the index set.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A textual description of the index set suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the index set.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}, {"var_description": "The computed hash value for the index set.", "var_type": "Int", "is_static": false, "var_name": "hashValue"}, {"var_description": "", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The first integer in self, or nil if self is empty.", "var_type": "IndexSet.Element", "is_static": false, "var_name": "first"}, {"var_description": "The first element of the collection.", "var_type": "Int", "is_static": false, "var_name": "first"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "DefaultIndices<IndexSet>", "is_static": false, "var_name": "indices"}, {"var_description": "", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "The last integer in self, or nil if self is empty.", "var_type": "IndexSet.Element", "is_static": false, "var_name": "last"}, {"var_description": "The last element of the collection.", "var_type": "Int", "is_static": false, "var_name": "last"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}], "class_type": "struct", "interface_list": ["BidirectionalCollection", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "ReferenceConvertible", "SetAlgebra"], "package_name": "foundation", "subclass_list": []}