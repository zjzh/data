{"class_description": "The UserDefaults class provides a programmatic interface for interacting with the defaults system. The defaults system allows an app to customize its behavior to match a user\u2019s preferences. For example, you can allow users to specify their preferred units of measurement or media playback speed. Apps store these preferences by assigning values to a set of parameters in a user\u2019s defaults database. The parameters are referred to as defaults because they\u2019re commonly used to determine an app\u2019s default state at startup or the way it acts by default.\nAt runtime, you use UserDefaults objects to read the defaults that your app uses from a user\u2019s defaults database. UserDefaults caches the information to avoid having to open the user\u2019s defaults database each time you need a default value. When you set a default value, it\u2019s changed synchronously within your process, and asynchronously to persistent storage and other processes.\nImportant\nDon\u2019t try to access the preferences subsystem directly. Modifying preference property list files may result in loss of changes, delay of reflecting changes, and app crashes. To configure preferences, use the defaults command-line utility in macOS instead.\nWith the exception of managed devices in educational institutions, a user\u2019s defaults are stored locally on a single device, and persisted for backup and restore. To synchronize preferences and other data across a user\u2019s connected devices, use NSUbiquitousKeyValueStore instead.\nThe UserDefaults class provides convenience methods for accessing common types such as floats, doubles, integers, Boolean values, and URLs. These methods are described in Setting Default Values.\nA default object must be a property list\u2014that is, an instance of (or for collections, a combination of instances of) NSData, NSString, NSNumber, NSDate, NSArray, or NSDictionary. If you want to store any other type of object, you should typically archive it to create an instance of NSData. \nValues returned from UserDefaults are immutable, even if you set a mutable object as the value. For example, if you set a mutable string as the value for \u201cMyStringDefault\u201d, the string you later retrieve using the string(forKey:) method will be immutable. If you set a mutable string as a default value and later mutate the string, the default value won\u2019t reflect the mutated string value unless you call set(_:forKey:) again.\nFor more details, see Preferences and Settings Programming Guide.\nA file URL specifies a location in the file system. If you use the set(_:forKey:) method to store the location for a particular file and the user moves that file, your app may not be able to locate that file on next launch. To store a reference to a file by its file system identity, you can instead create NSURL bookmark data using the bookmarkData(options:includingResourceValuesForKeys:relativeTo:) method and persist it using the set(_:forKey:) method. You can then use the URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error: method to resolve the bookmark data stored in user defaults to a file URL.\nYou can use key-value observing to be notified of any updates to a particular default value. You can also register as an observer for didChangeNotification on the default notification center in order to be notified of all updates to a local defaults database.   \nFor more details, see Key-Value Observing Programming Guide and Notification Programming Topics.\nIf your app supports managed environments, you can use UserDefaults to determine which preferences are managed by an administrator for the benefit of the user. In a managed environment, such as a computer lab or classroom, an administrator or teacher can configure the systems by establishing a set of default preferences for users. If a preference is managed in this manner (as determined by the methods described in Accessing Managed Environment Keys), your app should prevent users from editing that preference by disabling or hiding controls.\nFor more details, see Mobile Device Management Protocol Reference.\nAn app running on a device managed by an educational institution can use the iCloud key-value store to share small amounts of data with other instances of itself on the user\u2019s other devices. For example, a textbook app might store the current page number being read by the user so that other instances of the app can open to the same page when launched.\nFor more information, see Storing Preferences in iCloud in Preferences and Settings Programming Guide.\nA sandboxed app cannot access or modify the preferences for any other app, with the following exceptions:\nApp extensions on macOS and iOS\nOther apps in your application group on macOS\nAdding a third-party app\u2019s domain using the addSuite(named:) method doesn\u2019t allow your app to access to that app\u2019s preferences. Attempting to access or modify  another app\u2019s preferences doesn\u2019t result in an error; instead, macOS reads and writes files located within your app\u2019s container, rather than the actual preference files for the other application.\nThe UserDefaults class is thread-safe.\n", "Methods": [], "class_inherit_list": ["NSObject"], "class_name": "UserDefaults", "typealias": [], "Vars": [], "class_type": "class", "interface_list": ["CVarArg", "Equatable", "Hashable"], "package_name": "foundation", "subclass_list": []}