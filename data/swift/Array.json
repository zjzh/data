{"class_description": "Arrays are one of the most commonly used data types in an app. You use arrays to organize your app\u2019s data. Specifically, you use the Array type to hold elements of a single type, the array\u2019s Element type. An array can store any kind of elements\u2014from integers to strings to classes.\nSwift makes it easy to create arrays in your code using an array literal: simply surround a comma-separated list of values with square brackets. Without any other information, Swift creates an array that includes the specified values, automatically inferring the array\u2019s Element type. For example:\nYou can create an empty array by specifying the Element type of your array in the declaration. For example:\nIf you need an array that is preinitialized with a fixed number of default values, use the Array(repeating:count:) initializer.\nWhen you need to perform an operation on all of an array\u2019s elements, use a for-in loop to iterate through the array\u2019s contents.\nUse the isEmpty property to check quickly whether an array has any elements, or use the count property to find the number of elements in the array.\nUse the first and last properties for safe access to the value of the array\u2019s first and last elements. If the array is empty, these properties are nil.\nYou can access individual array elements through a subscript. The first element of a nonempty array is always at index zero. You can subscript an array with any integer from zero up to, but not including, the count of the array. Using a negative number or an index equal to or greater than count triggers a runtime error. For example:\nSuppose you need to store a list of the names of students that are signed up for a class you\u2019re teaching. During the registration period, you need to add and remove names as students add and drop the class.\nTo add single elements to the end of an array, use the append(_:) method. Add multiple elements at the same time by passing another array or a sequence of any kind to the append(contentsOf:) method.\nYou can add new elements in the middle of an array by using the insert(_:at:) method for single elements and by using insert(contentsOf:at:) to insert multiple elements from another collection or array literal. The elements at that index and later indices are shifted back to make room.\nTo remove elements from an array, use the remove(at:), removeSubrange(_:), and removeLast() methods.\nYou can replace an existing element with a new value by assigning the new value to the subscript.\nEvery array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage\u2019s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.\nIf you know approximately how many elements you will need to store, use the reserveCapacity(_:) method before appending to the array to avoid intermediate reallocations. Use the capacity and count properties to determine how many more elements the array can store without allocating larger storage.\nFor arrays of most Element types, this storage is a contiguous block of memory. For arrays with an Element type that is a class or @objc protocol type, this storage can be a contiguous block of memory or an instance of NSArray. Because any arbitrary subclass of NSArray can become an Array, there are no guarantees about representation or efficiency in this case.\nEach array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array. For example:\nIf the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object\u2019s properties from both arrays. For example:\nArrays, like all variable-size collections in the standard library, use copy-on-write optimization. Multiple copies of an array share the same storage until you modify one of the copies. When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place. Optimizations are sometimes applied that can reduce the amount of copying.\nThis means that if an array is sharing storage with other copies, the first mutating operation on that array incurs the cost of copying the array. An array that is the sole owner of its storage can perform mutating operations in place.\nIn the example below, a numbers array is created along with two copies that share the same storage. When the original numbers array is modified, it makes a unique copy of its storage before making the modification. Further modifications to numbers are made in place, while the two copies continue to share the original storage.\nWhen you need to access APIs that require data in an NSArray instance instead of Array, use the type-cast operator (as) to bridge your instance. For bridging to be possible, the Element type of your array must be a class, an @objc protocol (a protocol imported from Objective-C or marked with the @objc attribute), or a type that bridges to a Foundation type.\nThe following example shows how you can bridge an Array instance to NSArray to use the write(to:atomically:) method. In this example, the colors array can be bridged to NSArray because the colors array\u2019s String elements bridge to NSString. The compiler prevents bridging the moreColors array, on the other hand, because its Element type is Optional<String>, which does not bridge to a Foundation type.\nBridging from Array to NSArray takes O(1) time and O(1) space if the array\u2019s elements are already instances of a class or an @objc protocol; otherwise, it takes O(n) time and space.\nWhen the destination array\u2019s element type is a class or an @objc protocol, bridging from NSArray to Array first calls the copy(with:) (- copyWithZone: in Objective-C) method on the array to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of NSArray that are already immutable, copy(with:) usually returns the same array in O(1) time; otherwise, the copying performance is unspecified. If copy(with:) returns the same array, the instances of NSArray and Array share storage using the same copy-on-write optimization that is used when two instances of Array share storage.\nWhen the destination array\u2019s element type is a nonclass type that bridges to a Foundation type, bridging from NSArray to Array performs a bridging copy of the elements to contiguous storage in O(n) time. For example, bridging from NSArray to Array<Int> performs such a copy. No further bridging is required when accessing elements of the Array instance.\nNote\nThe ContiguousArray and ArraySlice types are not bridged; instances of those types always have a contiguous block of memory as their storage.\n", "Methods": [{"method_description": "Creates a new, empty array.", "method_name": "init", "params": [], "class_name": "Array", "method_declar": "init()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new instance of a collection containing the elements of a sequence.", "method_name": "init", "params": [{"param_type": "Sequence", "param_description": "The sequence of elements for the new collection.", "param_name": ["elements"]}], "class_name": "Array", "method_declar": "init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an array containing the elements of a sequence.", "method_name": "init", "params": [{"param_type": "Sequence", "param_description": "The sequence of elements to turn into an array.", "param_name": ["s"]}], "class_name": "Array", "method_declar": "init<S>(_ s: S) where Element == S.Element, S : Sequence", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new array containing the specified number of a single, repeated value.", "method_name": "init", "params": [{"param_type": "Element", "param_description": "The element to repeat.", "param_name": ["repeating", "repeatedValue"]}, {"param_type": "Int", "param_description": "The number of times to repeat the value passed in the repeating parameter. count must be zero or greater.", "param_name": ["count"]}], "class_name": "Array", "method_declar": "init(repeating repeatedValue: Element, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a random element of the collection.", "method_name": "randomElement", "params": [], "class_name": "Array", "method_declar": "func randomElement() -> Element?", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when choosing a random element.", "param_name": ["using", "generator"]}], "class_name": "Array", "method_declar": "func randomElement<T>(using generator: inout T) -> Element? where T : RandomNumberGenerator", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Reserves enough space to store the specified number of elements.", "method_name": "reserveCapacity", "params": [{"param_type": "Int", "param_description": "The requested number of elements to store.", "param_name": ["minimumCapacity"]}], "class_name": "Array", "method_declar": "mutating func reserveCapacity(_ minimumCapacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Reserves enough space to store the specified number of elements.", "method_name": "reserveCapacity", "params": [{"param_type": "Int", "param_description": "The requested number of elements to store.", "param_name": ["minimumCapacity"]}], "class_name": "Array", "method_declar": "mutating func reserveCapacity(_ minimumCapacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new collection by concatenating the elements of a sequence and a collection.", "method_name": "+", "params": [{"param_type": "Sequence", "param_description": "A collection or finite sequence.", "param_name": ["lhs"]}, {"param_type": "Array<Element>", "param_description": "A range-replaceable collection.", "param_name": ["rhs"]}], "class_name": "Array", "method_declar": "static func + <Other>(lhs: Other, rhs: Array<Element>) -> Array<Element> where Other : Sequence, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Array<Element>"]}, "is_static": true}, {"method_description": "Creates a new collection by concatenating the elements of a collection and a sequence.", "method_name": "+", "params": [{"param_type": "Array<Element>", "param_description": "A range-replaceable collection.", "param_name": ["lhs"]}, {"param_type": "Sequence", "param_description": "A collection or finite sequence.", "param_name": ["rhs"]}], "class_name": "Array", "method_declar": "static func + <Other>(lhs: Array<Element>, rhs: Other) -> Array<Element> where Other : Sequence, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Array<Element>"]}, "is_static": true}, {"method_description": "Creates a new collection by concatenating the elements of two collections.", "method_name": "+", "params": [{"param_type": "Array<Element>", "param_description": "A range-replaceable collection.", "param_name": ["lhs"]}, {"param_type": "RangeReplaceableCollection", "param_description": "Another range-replaceable collection.", "param_name": ["rhs"]}], "class_name": "Array", "method_declar": "static func + <Other>(lhs: Array<Element>, rhs: Other) -> Array<Element> where Other : RangeReplaceableCollection, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Array<Element>"]}, "is_static": true}, {"method_description": "Appends the elements of a sequence to a range-replaceable collection.", "method_name": "+=", "params": [{"param_type": "inout Array<Element>", "param_description": "The array to append to.", "param_name": ["lhs"]}, {"param_type": "Sequence", "param_description": "A collection or finite sequence.", "param_name": ["rhs"]}], "class_name": "Array", "method_declar": "static func += <Other>(lhs: inout Array<Element>, rhs: Other) where Other : Sequence, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": true}, {"method_description": "Removes and returns the element at the specified position.", "method_name": "remove", "params": [{"param_type": "Int", "param_description": "The position of the element to remove. index must be a valid index of the array.", "param_name": ["at", "index"]}], "class_name": "Array", "method_declar": "@discardableResult mutating func remove(at index: Int) -> Element", "return_value": {"return_description": ["The element at the specified index."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Removes and returns the element at the specified position.", "method_name": "remove", "params": [{"param_type": "Int", "param_description": "The position of the element to remove. index must be a valid index of the array.", "param_name": ["at", "index"]}], "class_name": "Array", "method_declar": "@discardableResult mutating func remove(at index: Int) -> Element", "return_value": {"return_description": ["The element at the specified index."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "params": [], "class_name": "Array", "method_declar": "@discardableResult mutating func removeFirst() -> Element", "return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Array", "method_declar": "mutating func removeFirst(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes and returns the last element of the collection.", "method_name": "removeLast", "params": [], "class_name": "Array", "method_declar": "@discardableResult mutating func removeLast() -> Element", "return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Removes the specified number of elements from the end of the collection.", "method_name": "removeLast", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Array", "method_declar": "mutating func removeLast(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements in the specified subrange from the collection.", "method_name": "removeSubrange", "params": [{"param_type": "Range<Int>", "param_description": "The range of the collection to be removed. The bounds of the range must be valid indices of the collection.", "param_name": ["bounds"]}], "class_name": "Array", "method_declar": "mutating func removeSubrange(_ bounds: Range<Int>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements in the specified subrange from the collection.", "method_name": "removeSubrange", "params": [{"param_type": "RangeExpression", "param_description": "The range of the collection to be removed. The bounds of the range must be valid indices of the collection.", "param_name": ["bounds"]}], "class_name": "Array", "method_declar": "mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, Self.Index == R.Bound", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes all the elements that satisfy the given predicate.", "method_name": "removeAll", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.", "param_name": ["where", "shouldBeRemoved"]}], "class_name": "Array", "method_declar": "mutating func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Removes all the elements that satisfy the given predicate.", "method_name": "removeAll", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.", "param_name": ["where", "shouldBeRemoved"]}], "class_name": "Array", "method_declar": "mutating func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Removes all elements from the array.", "method_name": "removeAll", "params": [{"param_type": "Bool = false", "param_description": "Pass true to keep the existing capacity of the array after removing its elements. The default value is false.", "param_name": ["keepingCapacity", "keepCapacity"]}], "class_name": "Array", "method_declar": "mutating func removeAll(keepingCapacity keepCapacity: Bool = false)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes all elements from the array.", "method_name": "removeAll", "params": [{"param_type": "Bool = false", "param_description": "Pass true to keep the existing capacity of the array after removing its elements. The default value is false.", "param_name": ["keepingCapacity", "keepCapacity"]}], "class_name": "Array", "method_declar": "mutating func removeAll(keepingCapacity keepCapacity: Bool = false)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes and returns the last element of the collection.", "method_name": "popLast", "params": [], "class_name": "Array", "method_declar": "mutating func popLast() -> Element?", "return_value": {"return_description": ["The last element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "method_name": "contains", "params": [{"param_type": "Element", "param_description": "The element to find in the sequence.", "param_name": ["element"]}], "class_name": "Array", "method_declar": "func contains(_ element: Element) -> Bool", "return_value": {"return_description": ["true if the element was found in the sequence; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Array", "method_declar": "func contains(where predicate: (Element) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_name": ["predicate"]}], "class_name": "Array", "method_declar": "func allSatisfy(_ predicate: (Element) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "Array", "method_declar": "func first(where predicate: (Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the first index where the specified value appears in the collection.", "method_name": "firstIndex", "params": [{"param_type": "Element", "param_description": "An element to search for in the collection.", "param_name": ["of", "element"]}], "class_name": "Array", "method_declar": "func firstIndex(of element: Element) -> Int?", "return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Array", "method_declar": "func firstIndex(where predicate: (Element) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the last element of the sequence that satisfies the given predicate.", "method_name": "last", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "Array", "method_declar": "func last(where predicate: (Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the last index where the specified value appears in the collection.", "method_name": "lastIndex", "params": [{"param_type": "Element", "param_description": "An element to search for in the collection.", "param_name": ["of", "element"]}], "class_name": "Array", "method_declar": "func lastIndex(of element: Element) -> Int?", "return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Returns the index of the last element in the collection that matches the given predicate.", "method_name": "lastIndex", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Array", "method_declar": "func lastIndex(where predicate: (Element) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence.", "method_name": "min", "params": [], "class_name": "Array", "method_declar": "@warn_unqualified_access func min() -> Element?", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Array", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence.", "method_name": "max", "params": [], "class_name": "Array", "method_declar": "@warn_unqualified_access func max() -> Element?", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Array", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["Element"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Array", "method_declar": "func prefix(_ maxLength: Int) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "", "param_name": ["through", "position"]}], "class_name": "Array", "method_declar": "func prefix(through position: Int) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_name": ["upTo", "end"]}], "class_name": "Array", "method_declar": "func prefix(upTo end: Int) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "Array", "method_declar": "func prefix(while predicate: (Element) throws -> Bool) rethrows -> ArraySlice<Element>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Array", "method_declar": "func suffix(_ maxLength: Int) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_name": ["from", "start"]}], "class_name": "Array", "method_declar": "func suffix(from start: Int) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Array", "method_declar": "func dropFirst(_ k: Int = 1) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "params": [{"param_type": "Int", "param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Array", "method_declar": "func dropLast(_ k: Int) -> ArraySlice<Element>", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "Array", "method_declar": "func drop(while predicate: (Element) throws -> Bool) rethrows -> ArraySlice<Element>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ArraySlice<Element>"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(Element) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Array", "method_declar": "func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T]"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(Element) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Array", "method_declar": "func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T]"]}, "is_static": false}, {"method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "params": [{"param_type": "(Element) throws -> ElementOfResult", "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_name": ["transform"]}], "class_name": "Array", "method_declar": "func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["[ElementOfResult]"]}, "is_static": false}, {"method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_name": ["initialResult"]}, {"param_type": "(Result, Element) throws -> Result", "param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_name": ["nextPartialResult"]}], "class_name": "Array", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Result"]}, "is_static": false}, {"method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "params": [{"param_type": "(Element) throws -> Void", "param_description": "A closure that takes an element of the sequence as a parameter.", "param_name": ["body"]}], "class_name": "Array", "method_declar": "func forEach(_ body: (Element) throws -> Void) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrows"]}, "is_static": false}, {"method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "params": [], "class_name": "Array", "method_declar": "func enumerated() -> EnumeratedSequence<Array<Element>>", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<Array<Element>>"]}, "is_static": false}, {"method_description": "Returns an iterator over the elements of the collection.", "method_name": "makeIterator", "params": [], "class_name": "Array", "method_declar": "func makeIterator() -> IndexingIterator<Array<Element>>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["IndexingIterator<Array<Element>>"]}, "is_static": false}, {"method_description": "Sorts the collection in place.", "method_name": "sort", "params": [], "class_name": "Array", "method_declar": "mutating func sort()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Sorts the collection in place, using the given predicate as the comparison between elements.", "method_name": "sort", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Array", "method_declar": "mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrows"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted.", "method_name": "sorted", "params": [], "class_name": "Array", "method_declar": "func sorted() -> [Element]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element]"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "params": [{"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Array", "method_declar": "func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element]"]}, "is_static": false}, {"method_description": "Reverses the elements of the collection in place.", "method_name": "reverse", "params": [], "class_name": "Array", "method_declar": "mutating func reverse()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a view presenting the elements of the collection in reverse order.", "method_name": "reversed", "params": [], "class_name": "Array", "method_declar": "func reversed() -> ReversedCollection<Array<Element>>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<Array<Element>>"]}, "is_static": false}, {"method_description": "Shuffles the collection in place.", "method_name": "shuffle", "params": [], "class_name": "Array", "method_declar": "mutating func shuffle()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Shuffles the collection in place, using the given generator as a source for randomness.", "method_name": "shuffle", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when shuffling the collection.", "param_name": ["using", "generator"]}], "class_name": "Array", "method_declar": "mutating func shuffle<T>(using generator: inout T) where T : RandomNumberGenerator", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "params": [], "class_name": "Array", "method_declar": "func shuffled() -> [Element]", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[Element]"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when shuffling the sequence.", "param_name": ["using", "generator"]}], "class_name": "Array", "method_declar": "func shuffled<T>(using generator: inout T) -> [Element] where T : RandomNumberGenerator", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[Element]"]}, "is_static": false}, {"method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "method_name": "partition", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_name": ["by", "belongsInSecondPartition"]}], "class_name": "Array", "method_declar": "mutating func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Int", "return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "method_name": "partition", "params": [{"param_type": "(Element) throws -> Bool", "param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_name": ["by", "belongsInSecondPartition"]}], "class_name": "Array", "method_declar": "mutating func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Int", "return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Exchanges the values at the specified indices of the collection.", "method_name": "swapAt", "params": [{"param_type": "Int", "param_description": "The index of the first value to swap.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The index of the second value to swap.", "param_name": ["j"]}], "class_name": "Array", "method_declar": "mutating func swapAt(_ i: Int, _ j: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "method_name": "split", "params": [{"param_type": "Element", "param_description": "The element that should be split upon.", "param_name": ["separator"]}, {"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool = true", "param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.", "param_name": ["omittingEmptySubsequences"]}], "class_name": "Array", "method_declar": "func split(separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Element>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[ArraySlice<Element>]"]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "params": [{"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool", "param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_name": ["omittingEmptySubsequences"]}, {"param_type": "(Element) throws -> Bool", "param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_name": ["whereSeparator", "isSeparator"]}], "class_name": "Array", "method_declar": "func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [ArraySlice<Element>]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the elements of this sequence of sequences, concatenated.", "method_name": "joined", "params": [], "class_name": "Array", "method_declar": "func joined() -> FlattenSequence<Array<Element>>", "return_value": {"return_description": ["A flattened view of the elements of this sequence of sequences."], "return_name": [""], "return_type": ["FlattenSequence<Array<Element>>"]}, "is_static": false}, {"method_description": "Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.", "method_name": "joined", "params": [{"param_type": "Sequence", "param_description": "A sequence to insert between each of this sequence\u2019s elements.", "param_name": ["separator"]}], "class_name": "Array", "method_declar": "func joined<Separator>(separator: Separator) -> JoinedSequence<Array<Element>> where Separator : Sequence, Separator.Element == Self.Element.Element", "return_value": {"return_description": ["The joined sequence of elements."], "return_name": [""], "return_type": ["JoinedSequence<Array<Element>>"]}, "is_static": false}, {"method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "method_name": "joined", "params": [{"param_type": "String = \"\"", "param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_name": ["separator"]}], "class_name": "Array", "method_declar": "func joined(separator: String = \"\") -> String", "return_value": {"return_description": ["A single, concatenated string."], "return_name": [""], "return_type": ["String"]}, "is_static": false}, {"method_description": "Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.", "method_name": "joined", "params": [{"param_type": "String = \"\"", "param_description": "A string to insert between each of the elements in this sequence. The default separator is an empty string.", "param_name": ["separator"]}], "class_name": "Array", "method_declar": "func joined(separator: String = \"\") -> String", "return_value": {"return_description": ["A single, concatenated string."], "return_name": [""], "return_type": ["String"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether two arrays contain the same elements in the same order.", "method_name": "==", "params": [{"param_type": "Array<Element>", "param_description": "An array to compare.", "param_name": ["lhs"]}, {"param_type": "Array<Element>", "param_description": "Another array to compare.", "param_name": ["rhs"]}], "class_name": "Array", "method_declar": "static func == (lhs: Array<Element>, rhs: Array<Element>) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": true}, {"method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "params": [{"param_type": "Array<Element>", "param_description": "A value to compare.", "param_name": ["lhs"]}, {"param_type": "Array<Element>", "param_description": "Another value to compare.", "param_name": ["rhs"]}], "class_name": "Array", "method_declar": "static func != (lhs: Array<Element>, rhs: Array<Element>) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": true}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "Array", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(Element, OtherSequence.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "Array", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}], "class_name": "Array", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}, {"param_type": "(Element, PossiblePrefix.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "Array", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "Array", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(Element, Element) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Array", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the position immediately after the given index.", "method_name": "index", "params": [{"param_type": "Int", "param_description": "A valid index of the collection. i must be less than endIndex.", "param_name": ["after", "i"]}], "class_name": "Array", "method_declar": "func index(after i: Int) -> Int", "return_value": {"return_description": ["The index immediately after i."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Replaces the given index with its successor.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection. i must be less than endIndex.", "param_name": ["after", "i"]}], "class_name": "Array", "method_declar": "func formIndex(after i: inout Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the position immediately before the given index.", "method_name": "index", "params": [{"param_type": "Int", "param_description": "A valid index of the collection. i must be greater than startIndex.", "param_name": ["before", "i"]}], "class_name": "Array", "method_declar": "func index(before i: Int) -> Int", "return_value": {"return_description": ["The index immediately before i."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Replaces the given index with its predecessor.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection. i must be greater than startIndex.", "param_name": ["before", "i"]}], "class_name": "Array", "method_declar": "func formIndex(before i: inout Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "params": [{"param_type": "Int", "param_description": "A valid index of the array.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i.", "param_name": ["offsetBy", "distance"]}], "class_name": "Array", "method_declar": "func index(_ i: Int, offsetBy distance: Int) -> Int", "return_value": {"return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "Array", "method_declar": "func formIndex(_ i: inout Int, offsetBy distance: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "params": [{"param_type": "Int", "param_description": "A valid index of the array.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Int", "param_description": "A valid index of the collection to use as a limit. If distance > 0, limit has no effect if it is less than i. Likewise, if distance < 0, limit has no effect if it is greater than i.", "param_name": ["limitedBy", "limit"]}], "class_name": "Array", "method_declar": "func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?", "return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Int", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Array", "method_declar": "func formIndex(_ i: inout Int, offsetBy distance: Int, limitedBy limit: Int) -> Bool", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the distance between two indices.", "method_name": "distance", "params": [{"param_type": "Int", "param_description": "A valid index of the collection.", "param_name": ["from", "start"]}, {"param_type": "Int", "param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_name": ["to", "end"]}], "class_name": "Array", "method_declar": "func distance(from start: Int, to end: Int) -> Int", "return_value": {"return_description": ["The distance between start and end."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Calls a closure with a pointer to the array\u2019s contiguous storage.", "method_name": "withUnsafeBufferPointer", "params": [{"param_type": "(UnsafeBufferPointer<Element>) throws -> R", "param_description": "A closure with an UnsafeBufferPointer parameter that points to the contiguous storage for the array.  If no such storage exists, it is created. If body has a return value, that value is also used as the return value for the withUnsafeBufferPointer(_:) method. The pointer argument is valid only for the duration of the method\u2019s execution.", "param_name": ["body"]}], "class_name": "Array", "method_declar": "func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R", "return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R"]}, "is_static": false}, {"method_description": "Calls the given closure with a pointer to the array\u2019s mutable contiguous storage.", "method_name": "withUnsafeMutableBufferPointer", "params": [{"param_type": "(inout UnsafeMutableBufferPointer<Element>) throws -> R", "param_description": "A closure with an UnsafeMutableBufferPointer parameter that points to the contiguous storage for the array. If no such storage exists, it is created. If body has a return value, that value is also used as the return value for the withUnsafeMutableBufferPointer(_:) method. The pointer argument is valid only for the duration of the method\u2019s execution.", "param_name": ["body"]}], "class_name": "Array", "method_declar": "mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R", "return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R"]}, "is_static": false}, {"method_description": "Calls the given closure with a pointer to the underlying bytes of the array\u2019s contiguous storage.", "method_name": "withUnsafeBytes", "params": [{"param_type": "(UnsafeRawBufferPointer) throws -> R", "param_description": "A closure with an UnsafeRawBufferPointer parameter that points to the contiguous storage for the array. If no such storage exists, it is created. If body has a return value, that value is also used as the return value for the withUnsafeBytes(_:) method. The argument is valid only for the duration of the closure\u2019s execution.", "param_name": ["body"]}], "class_name": "Array", "method_declar": "func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R", "return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R"]}, "is_static": false}, {"method_description": "Calls the given closure with a pointer to the underlying bytes of the array\u2019s mutable contiguous storage.", "method_name": "withUnsafeMutableBytes", "params": [{"param_type": "(UnsafeMutableRawBufferPointer) throws -> R", "param_description": "A closure with an UnsafeMutableRawBufferPointer parameter that points to the contiguous storage for the array. If no such storage exists, it is created. If body has a return value, that value is also used as the return value for the withUnsafeMutableBytes(_:) method. The argument is valid only for the duration of the closure\u2019s execution.", "param_name": ["body"]}], "class_name": "Array", "method_declar": "mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R", "return_value": {"return_description": ["The return value, if any, of the body closure parameter."], "return_name": [""], "return_type": ["R"]}, "is_static": false}, {"method_description": "Encodes the elements of this array into the given encoder in an unkeyed container.", "method_name": "encode", "params": [{"param_type": "Encoder", "param_description": "The encoder to write data to.", "param_name": ["to", "encoder"]}], "class_name": "Array", "method_declar": "func encode(to encoder: Encoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new array by decoding from the given decoder.", "method_name": "init", "params": [{"param_type": "Decoder", "param_description": "The decoder to read data from.", "param_name": ["from", "decoder"]}], "class_name": "Array", "method_declar": "init(from decoder: Decoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Hashes the essential components of this value by feeding them into the given hasher.", "method_name": "hash", "params": [{"param_type": "inout Hasher", "param_description": "The hasher to use when combining the components of this instance.", "param_name": ["into", "hasher"]}], "class_name": "Array", "method_declar": "func hash(into hasher: inout Hasher)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an array from a column in a machine learning data table.", "method_name": "init", "params": [{"param_type": "MLDataColumn<Element>", "param_description": "", "param_name": ["column"]}], "class_name": "Array", "method_declar": "init(_ column: MLDataColumn<Element>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an array from an untyped column in a machine learning data table.", "method_name": "init", "params": [{"param_type": "MLUntypedColumn", "param_description": "", "param_name": ["untypedColumn"]}], "class_name": "Array", "method_declar": "init(_ untypedColumn: MLUntypedColumn)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an array from a machine learning data value.", "method_name": "init", "params": [{"param_type": "MLDataValue", "param_description": "", "param_name": ["from", "dataValue"]}], "class_name": "Array", "method_declar": "init?(from dataValue: MLDataValue)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an array from the given array literal.", "method_name": "init", "params": [{"param_type": "Element...", "param_description": "A variadic list of elements of the new array.", "param_name": ["arrayLiteral", "elements"]}], "class_name": "Array", "method_declar": "init(arrayLiteral elements: Element...)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}], "class_inherit_list": [], "class_name": "Array", "typealias": ["typealias Index = Int", "typealias Indices = Range<Int>", "typealias Iterator = IndexingIterator<Array<Element>>"], "Vars": [{"var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "The number of elements in the array.", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The number of elements in the array.", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The total number of elements that the array can contain without allocating new storage.", "var_type": "Int", "is_static": false, "var_name": "capacity"}, {"var_description": "The first element of the collection.", "var_type": "Element", "is_static": false, "var_name": "first"}, {"var_description": "The last element of the collection.", "var_type": "Element", "is_static": false, "var_name": "last"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<Array<Element>>", "is_static": false, "var_name": "lazy"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "The position of the first element in a nonempty array.", "var_type": "Int", "is_static": false, "var_name": "startIndex"}, {"var_description": "The array\u2019s \u201cpast the end\u201d position\u2014that is, the position one greater than the last valid subscript argument.", "var_type": "Int", "is_static": false, "var_name": "endIndex"}, {"var_description": "The indices that are valid for subscripting the collection, in ascending order.", "var_type": "Range<Int>", "is_static": false, "var_name": "indices"}, {"var_description": "A textual representation of the array and its elements.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A textual representation of the array and its elements, suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the array.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}, {"var_description": "A machine learning data value representation of the array.", "var_type": "MLDataValue", "is_static": false, "var_name": "dataValue"}, {"var_description": "The kind of machine learning data value to which the array may be converted.", "var_type": "MLDataValue.ValueType", "is_static": false, "var_name": "dataValueType"}], "class_type": "struct", "interface_list": ["CKRecordValueProtocol", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "CVarArg", "Decodable", "Encodable", "Equatable", "ExpressibleByArrayLiteral", "Hashable", "MLDataValueConvertible", "MutableCollection", "RandomAccessCollection", "RangeReplaceableCollection"], "package_name": "foundation", "subclass_list": []}