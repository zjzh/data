{"class_description": "The Data value type allows simple byte buffers to take on the behavior of Foundation objects. You can create empty or pre-populated buffers from a variety of sources and later add or remove bytes. You can filter and sort the content, or compare against other buffers. You can manipulate subranges of bytes and iterate over some or all of them.\nData bridges to the NSData class and its mutable subclass, NSMutableData. You can use these interchangeably in code that interacts with Objective-C APIs.\n", "Methods": [{"method_description": "Creates an empty data buffer.", "method_name": "init", "params": [], "class_name": "Data", "method_declar": "init()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an empty data buffer of a specified size.", "method_name": "init", "params": [{"param_type": "Int", "param_description": "The size of the data.", "param_name": ["capacity"]}], "class_name": "Data", "method_declar": "init(capacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new data buffer with the specified count of zeroed bytes.", "method_name": "init", "params": [{"param_type": "Int", "param_description": "The number of bytes the data initially contains.", "param_name": ["count"]}], "class_name": "Data", "method_declar": "init(count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Sets a region of the data buffer to 0.", "method_name": "resetBytes", "params": [{"param_type": "Range<Data.Index>", "param_description": "The range in the data to set to 0.", "param_name": ["in", "range"]}], "class_name": "Data", "method_declar": "mutating func resetBytes(in range: Range<Data.Index>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an empty data buffer.", "method_name": "init", "params": [], "class_name": "Data", "method_declar": "init()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new instance of a collection containing the elements of a sequence.", "method_name": "init", "params": [{"param_type": "Sequence", "param_description": "The sequence of elements for the new collection.", "param_name": ["elements"]}], "class_name": "Data", "method_declar": "init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a data buffer with copied memory content using a buffer pointer.", "method_name": "init", "params": [{"param_type": "UnsafeBufferPointer<SourceType>", "param_description": "A buffer pointer to copy. The size is calculated from SourceType and buffer.count.", "param_name": ["buffer"]}], "class_name": "Data", "method_declar": "init<SourceType>(buffer: UnsafeBufferPointer<SourceType>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a data buffer with copied memory content using a mutable buffer pointer.", "method_name": "init", "params": [{"param_type": "UnsafeMutableBufferPointer<SourceType>", "param_description": "A buffer pointer to copy. The size is calculated from SourceType and buffer.count.", "param_name": ["buffer"]}], "class_name": "Data", "method_declar": "init<SourceType>(buffer: UnsafeMutableBufferPointer<SourceType>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates data with copied memory content.", "method_name": "init", "params": [{"param_type": "UnsafeRawPointer", "param_description": "A pointer to the memory to copy.", "param_name": ["bytes"]}, {"param_type": "Int", "param_description": "The number of bytes to copy.", "param_name": ["count"]}], "class_name": "Data", "method_declar": "init(bytes: UnsafeRawPointer, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a data buffer with memory content without copying the bytes.", "method_name": "init", "params": [{"param_type": "UnsafeMutableRawPointer", "param_description": "A pointer to the bytes.", "param_name": ["bytesNoCopy", "bytes"]}, {"param_type": "Int", "param_description": "The size of the bytes.", "param_name": ["count"]}, {"param_type": "Data.Deallocator", "param_description": "Specifies the mechanism to free the indicated buffer, or .none.", "param_name": ["deallocator"]}], "class_name": "Data", "method_declar": "init(bytesNoCopy bytes: UnsafeMutableRawPointer, count: Int, deallocator: Data.Deallocator)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates an empty data buffer of a specified size.", "method_name": "init", "params": [{"param_type": "Int", "param_description": "The size of the data.", "param_name": ["capacity"]}], "class_name": "Data", "method_declar": "init(capacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new data buffer with the specified count of zeroed bytes.", "method_name": "init", "params": [{"param_type": "Int", "param_description": "The number of bytes the data initially contains.", "param_name": ["count"]}], "class_name": "Data", "method_declar": "init(count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates data with copied memory content.", "method_name": "init", "params": [{"param_type": "UnsafeRawPointer", "param_description": "A pointer to the memory to copy.", "param_name": ["bytes"]}, {"param_type": "Int", "param_description": "The number of bytes to copy.", "param_name": ["count"]}], "class_name": "Data", "method_declar": "init(bytes: UnsafeRawPointer, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a data buffer with copied memory content using a buffer pointer.", "method_name": "init", "params": [{"param_type": "UnsafeBufferPointer<SourceType>", "param_description": "A buffer pointer to copy. The size is calculated from SourceType and buffer.count.", "param_name": ["buffer"]}], "class_name": "Data", "method_declar": "init<SourceType>(buffer: UnsafeBufferPointer<SourceType>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a data buffer with copied memory content using a mutable buffer pointer.", "method_name": "init", "params": [{"param_type": "UnsafeMutableBufferPointer<SourceType>", "param_description": "A buffer pointer to copy. The size is calculated from SourceType and buffer.count.", "param_name": ["buffer"]}], "class_name": "Data", "method_declar": "init<SourceType>(buffer: UnsafeMutableBufferPointer<SourceType>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a data buffer with memory content without copying the bytes.", "method_name": "init", "params": [{"param_type": "UnsafeMutableRawPointer", "param_description": "A pointer to the bytes.", "param_name": ["bytesNoCopy", "bytes"]}, {"param_type": "Int", "param_description": "The size of the bytes.", "param_name": ["count"]}, {"param_type": "Data.Deallocator", "param_description": "Specifies the mechanism to free the indicated buffer, or .none.", "param_name": ["deallocator"]}], "class_name": "Data", "method_declar": "init(bytesNoCopy bytes: UnsafeMutableRawPointer, count: Int, deallocator: Data.Deallocator)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Writes the contents of the data buffer to a location.", "method_name": "write", "params": [{"param_type": "URL", "param_description": "The location to write the data into.", "param_name": ["to", "url"]}, {"param_type": "Data.WritingOptions = []", "param_description": "Options for writing the data. Default value is [].", "param_name": ["options"]}], "class_name": "Data", "method_declar": "func write(to url: URL, options: Data.WritingOptions = []) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns Base-64 encoded data.", "method_name": "base64EncodedData", "params": [{"param_type": "Data.Base64EncodingOptions = []", "param_description": "The options to use for the encoding. Default value is [].", "param_name": ["options"]}], "class_name": "Data", "method_declar": "func base64EncodedData(options: Data.Base64EncodingOptions = []) -> Data", "return_value": {"return_description": ["The Base-64 encoded data."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a Base-64 encoded string.", "method_name": "base64EncodedString", "params": [{"param_type": "Data.Base64EncodingOptions = []", "param_description": "The options to use for the encoding. Default value is [].", "param_name": ["options"]}], "class_name": "Data", "method_declar": "func base64EncodedString(options: Data.Base64EncodingOptions = []) -> String", "return_value": {"return_description": ["The Base-64 encoded string."], "return_name": [""], "return_type": ["Strin"]}, "is_static": false}, {"method_description": "Accesses the raw bytes in the data's buffer.", "method_name": "withUnsafeBytes", "params": [{"param_type": "(UnsafePointer<ContentType>) throws -> ResultType", "param_description": "", "param_name": ["body"]}], "class_name": "Data", "method_declar": "func withUnsafeBytes<ResultType, ContentType>(_ body: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ResultTyp"]}, "is_static": false}, {"method_description": "Mutates the raw bytes in the data's buffer.", "method_name": "withUnsafeMutableBytes", "params": [{"param_type": "(UnsafeMutablePointer<ContentType>) throws -> ResultType", "param_description": "", "param_name": ["body"]}], "class_name": "Data", "method_declar": "mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ResultTyp"]}, "is_static": false}, {"method_description": "Copies the contents of the data to memory.", "method_name": "copyBytes", "params": [{"param_type": "UnsafeMutablePointer<UInt8>", "param_description": "A pointer to the buffer you wish to copy the bytes into.", "param_name": ["to", "pointer"]}, {"param_type": "Int", "param_description": "The number of bytes to copy.", "param_name": ["count"]}], "class_name": "Data", "method_declar": "func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Copies a subset of the contents of the data to memory.", "method_name": "copyBytes", "params": [{"param_type": "UnsafeMutablePointer<UInt8>", "param_description": "A pointer to the buffer you wish to copy the bytes into.", "param_name": ["to", "pointer"]}, {"param_type": "Range<Data.Index>", "param_description": "The range in the Data to copy.", "param_name": ["from", "range"]}], "class_name": "Data", "method_declar": "func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, from range: Range<Data.Index>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Copies the bytes in a range from the data into a buffer. ", "method_name": "copyBytes", "params": [{"param_type": "UnsafeMutableBufferPointer<DestinationType>", "param_description": "A buffer to copy the data into.", "param_name": ["to", "buffer"]}, {"param_type": "Range<Data.Index> = nil", "param_description": "A range in the data to copy into the buffer. If the range is empty, this function will return 0 without copying anything. If the range is nil, as much data as will fit into buffer is copied.", "param_name": ["from", "range"]}], "class_name": "Data", "method_declar": "func copyBytes<DestinationType>(to buffer: UnsafeMutableBufferPointer<DestinationType>, from range: Range<Data.Index>? = nil) -> Int", "return_value": {"return_description": ["Number of bytes copied into the destination buffer."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Appends the specified data to the end of this data.", "method_name": "append", "params": [{"param_type": "Data", "param_description": "", "param_name": ["other"]}], "class_name": "Data", "method_declar": "mutating func append(_ other: Data)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Append a buffer of bytes to the data.", "method_name": "append", "params": [{"param_type": "UnsafeBufferPointer<SourceType>", "param_description": "The buffer of bytes to append. The size is calculated from SourceType and buffer.count.", "param_name": ["buffer"]}], "class_name": "Data", "method_declar": "mutating func append<SourceType>(_ buffer: UnsafeBufferPointer<SourceType>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Appends the specified bytes from memory to the end of the data.", "method_name": "append", "params": [{"param_type": "UnsafePointer<UInt8>", "param_description": "", "param_name": ["bytes"]}, {"param_type": "Int", "param_description": "", "param_name": ["count"]}], "class_name": "Data", "method_declar": "mutating func append(_ bytes: UnsafePointer<UInt8>, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Appends the bytes in the specified array to the end of the data.", "method_name": "append", "params": [{"param_type": "[UInt8]", "param_description": "", "param_name": ["contentsOf", "bytes"]}], "class_name": "Data", "method_declar": "mutating func append(contentsOf bytes: [UInt8])", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Prepares the collection to store the specified number of elements, when doing so is appropriate for the underlying type.", "method_name": "reserveCapacity", "params": [{"param_type": "Int", "param_description": "", "param_name": ["minimumCapacity"]}], "class_name": "Data", "method_declar": "mutating func reserveCapacity(_ minimumCapacity: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes and returns the element at the specified position.", "method_name": "remove", "params": [{"param_type": "Int", "param_description": "The position of the element to remove. position must be a valid index of the collection that is not equal to the collection\u2019s end index.", "param_name": ["at", "position"]}], "class_name": "Data", "method_declar": "@discardableResult mutating func remove(at position: Int) -> UInt8", "return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes all elements from the collection.", "method_name": "removeAll", "params": [{"param_type": "Bool = false", "param_description": "Pass true to request that the collection avoid releasing its storage. Retaining the collection\u2019s storage can be a useful optimization when you\u2019re planning to grow the collection again. The default value is false.", "param_name": ["keepingCapacity", "keepCapacity"]}], "class_name": "Data", "method_declar": "mutating func removeAll(keepingCapacity keepCapacity: Bool = false)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements in the specified subrange from the collection.", "method_name": "removeSubrange", "params": [{"param_type": "Range<Int>", "param_description": "The range of the collection to be removed. The bounds of the range must be valid indices of the collection.", "param_name": ["bounds"]}], "class_name": "Data", "method_declar": "mutating func removeSubrange(_ bounds: Range<Int>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Replaces a region of bytes in the data with new data.", "method_name": "replaceSubrange", "params": [{"param_type": "Range<Data.Index>", "param_description": "The range in the data to replace. If subrange.lowerBound == data.count && subrange.count == 0 then this operation is an append.", "param_name": ["subrange"]}, {"param_type": "Data", "param_description": "The replacement data.", "param_name": ["with", "data"]}], "class_name": "Data", "method_declar": "mutating func replaceSubrange(_ subrange: Range<Data.Index>, with data: Data)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Replaces a region of bytes in the data with new bytes from a collection.", "method_name": "replaceSubrange", "params": [{"param_type": "Range<Data.Index>", "param_description": "The range in the data to replace.", "param_name": ["subrange"]}, {"param_type": "Collection", "param_description": "The replacement bytes.", "param_name": ["with", "newElements"]}], "class_name": "Data", "method_declar": "mutating func replaceSubrange<ByteCollection>(_ subrange: Range<Data.Index>, with newElements: ByteCollection) where ByteCollection : Collection, ByteCollection.Element == Data.Iterator.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Replaces a region of bytes in the data with new bytes from a buffer.", "method_name": "replaceSubrange", "params": [{"param_type": "Range<Data.Index>", "param_description": "The range in the data to replace.", "param_name": ["subrange"]}, {"param_type": "UnsafeBufferPointer<SourceType>", "param_description": "The replacement bytes.", "param_name": ["with", "buffer"]}], "class_name": "Data", "method_declar": "mutating func replaceSubrange<SourceType>(_ subrange: Range<Data.Index>, with buffer: UnsafeBufferPointer<SourceType>)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Replaces a region of bytes in the data with bytes from memory.", "method_name": "replaceSubrange", "params": [{"param_type": "Range<Data.Index>", "param_description": "", "param_name": ["subrange"]}, {"param_type": "UnsafeRawPointer", "param_description": "", "param_name": ["with", "bytes"]}, {"param_type": "Int", "param_description": "", "param_name": ["count", "cnt"]}], "class_name": "Data", "method_declar": "mutating func replaceSubrange(_ subrange: Range<Data.Index>, with bytes: UnsafeRawPointer, count cnt: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the first element of the sequence that satisfies the given predicate.", "method_name": "first", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "Data", "method_declar": "func first(where predicate: (UInt8) throws -> Bool) rethrows -> UInt8?", "return_value": {"return_description": ["The first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence.", "method_name": "max", "params": [], "class_name": "Data", "method_declar": "@warn_unqualified_access func max() -> UInt8?", "return_value": {"return_description": ["The sequence\u2019s maximum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Returns the maximum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "max", "params": [{"param_type": "(UInt8, UInt8) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Data", "method_declar": "@warn_unqualified_access func max(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> UInt8?", "return_value": {"return_description": ["The sequence\u2019s maximum element if the sequence is not empty; otherwise, nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence.", "method_name": "min", "params": [], "class_name": "Data", "method_declar": "@warn_unqualified_access func min() -> UInt8?", "return_value": {"return_description": ["The sequence\u2019s minimum element. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Returns the minimum element in the sequence, using the given predicate as the comparison between elements.", "method_name": "min", "params": [{"param_type": "(UInt8, UInt8) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Data", "method_declar": "@warn_unqualified_access func min(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> UInt8?", "return_value": {"return_description": ["The sequence\u2019s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Finds the range of the specified data as a subsequence of this data, if it exists.", "method_name": "range", "params": [{"param_type": "Data", "param_description": "The data to be searched for.", "param_name": ["of", "dataToFind"]}, {"param_type": "Data.SearchOptions", "param_description": "Options for the search. Default value is [].", "param_name": ["options"]}, {"param_type": "Range<Data.Index> = nil", "param_description": "The range of this data in which to perform the search. Default value is nil, which means the entire content of this data.", "param_name": ["in", "range"]}], "class_name": "Data", "method_declar": "func range(of dataToFind: Data, options: Data.SearchOptions = [], in range: Range<Data.Index>? = nil) -> Range<Data.Index>?", "return_value": {"return_description": ["A Range specifying the location of the found data, or nil if a match could not be found."], "return_name": [""], "return_type": ["Range<Data.Index"]}, "is_static": false}, {"method_description": "Returns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.", "method_name": "filter", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned collection.", "param_name": ["isIncluded"]}], "class_name": "Data", "method_declar": "func filter(_ isIncluded: (UInt8) throws -> Bool) rethrows -> Data", "return_value": {"return_description": ["A collection of the elements that isIncluded allowed."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Data", "method_declar": "func prefix(_ maxLength: Int) -> Data", "return_value": {"return_description": ["A subsequence starting at the beginning of this collection with at most maxLength elements."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection through the specified position.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "", "param_name": ["through", "position"]}], "class_name": "Data", "method_declar": "func prefix(through position: Int) -> Data", "return_value": {"return_description": ["A subsequence up to, and including, the end position."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence from the start of the collection up to, but not including, the specified position.", "method_name": "prefix", "params": [{"param_type": "Int", "param_description": "The \u201cpast the end\u201d index of the resulting subsequence. end must be a valid index of the collection.", "param_name": ["upTo", "end"]}], "class_name": "Data", "method_declar": "func prefix(upTo end: Int) -> Data", "return_value": {"return_description": ["A subsequence up to, but not including, the end position."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.", "method_name": "prefix", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "Data", "method_declar": "func prefix(while predicate: (UInt8) throws -> Bool) rethrows -> Data", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence, up to the given maximum length, containing the final elements of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The maximum number of elements to return. maxLength must be greater than or equal to zero.", "param_name": ["maxLength"]}], "class_name": "Data", "method_declar": "func suffix(_ maxLength: Int) -> Data", "return_value": {"return_description": ["A subsequence terminating at the end of the collection with at most maxLength elements."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence from the specified position to the end of the collection.", "method_name": "suffix", "params": [{"param_type": "Int", "param_description": "The index at which to start the resulting subsequence. start must be a valid index of the collection.", "param_name": ["from", "start"]}], "class_name": "Data", "method_declar": "func suffix(from start: Int) -> Data", "return_value": {"return_description": ["A subsequence starting at the start position."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the specified number of final elements.", "method_name": "dropLast", "params": [{"param_type": "Int", "param_description": "The number of elements to drop off the end of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "func dropLast(_ k: Int) -> Data", "return_value": {"return_description": ["A subsequence that leaves off k elements from the end."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence containing all but the given number of initial elements.", "method_name": "dropFirst", "params": [{"param_type": "Int = 1", "param_description": "The number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "func dropFirst(_ k: Int = 1) -> Data", "return_value": {"return_description": ["A subsequence starting after the specified number of elements."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a subsequence by skipping elements while predicate returns true and returning the remaining elements.", "method_name": "drop", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.", "param_name": ["while", "predicate"]}], "class_name": "Data", "method_declar": "func drop(while predicate: (UInt8) throws -> Bool) rethrows -> Data", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns a new data buffer created by removing the given number of bytes from the front of the original buffer.", "method_name": "advanced", "params": [{"param_type": "Int", "param_description": "The number of bytes to strip from the input data buffer. The value must be less than the original data buffer's length.", "param_name": ["by", "amount"]}], "class_name": "Data", "method_declar": "func advanced(by amount: Int) -> Data", "return_value": {"return_description": ["A newly created data buffer that is shorter by the given amount than the original."], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns the result of combining the elements of the sequence using the given closure.", "method_name": "reduce", "params": [{"param_type": "Result", "param_description": "The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.", "param_name": ["initialResult"]}, {"param_type": "(Result, UInt8) throws -> Result", "param_description": "A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.", "param_name": ["nextPartialResult"]}], "class_name": "Data", "method_declar": "func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, UInt8) throws -> Result) rethrows -> Result", "return_value": {"return_description": ["The final accumulated value. If the sequence has no elements, the result is initialResult."], "return_name": [""], "return_type": ["Resul"]}, "is_static": false}, {"method_description": "Calls the given closure on each element in the sequence in the same order as a for-in loop.", "method_name": "forEach", "params": [{"param_type": "(UInt8) throws -> Void", "param_description": "A closure that takes an element of the sequence as a parameter.", "param_name": ["body"]}], "class_name": "Data", "method_declar": "func forEach(_ body: (UInt8) throws -> Void) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void rethrow"]}, "is_static": false}, {"method_description": "Returns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.", "method_name": "enumerated", "params": [], "class_name": "Data", "method_declar": "func enumerated() -> EnumeratedSequence<Data>", "return_value": {"return_description": ["A sequence of pairs enumerating the sequence."], "return_name": [""], "return_type": ["EnumeratedSequence<Data"]}, "is_static": false}, {"method_description": "Returns an iterator over the contents of the data.", "method_name": "makeIterator", "params": [], "class_name": "Data", "method_declar": "func makeIterator() -> Data.Iterator", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Data.Iterato"]}, "is_static": false}, {"method_description": "Enumerates the contents of the data's buffer.", "method_name": "enumerateBytes", "params": [{"param_type": "(UnsafeBufferPointer<UInt8>, Data.Index, inout Bool) -> Void", "param_description": "The closure to invoke for each region of data. You may stop the enumeration by setting the stop parameter to true.", "param_name": ["block"]}], "class_name": "Data", "method_declar": "func enumerateBytes(_ block: (UnsafeBufferPointer<UInt8>, Data.Index, inout Bool) -> Void)", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void"]}, "is_static": false}, {"method_description": "Sorts the collection in place, using the given predicate as the comparison between elements.", "method_name": "sort", "params": [{"param_type": "(UInt8, UInt8) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Data", "method_declar": "mutating func sort(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool rethrow"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted.", "method_name": "sorted", "params": [], "class_name": "Data", "method_declar": "func sorted() -> [UInt8]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[UInt8"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.", "method_name": "sorted", "params": [{"param_type": "(UInt8, UInt8) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Data", "method_declar": "func sorted(by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> [UInt8]", "return_value": {"return_description": ["A sorted array of the sequence\u2019s elements."], "return_name": [""], "return_type": ["[UInt8"]}, "is_static": false}, {"method_description": "Returns a view presenting the elements of the collection in reverse order.", "method_name": "reversed", "params": [], "class_name": "Data", "method_declar": "func reversed() -> ReversedCollection<Data>", "return_value": {"return_description": [], "return_name": [""], "return_type": ["ReversedCollection<Data"]}, "is_static": false}, {"method_description": "Returns a new copy of the data in a specified range.", "method_name": "subdata", "params": [{"param_type": "Range<Data.Index>", "param_description": "The range to copy.", "param_name": ["in", "range"]}], "class_name": "Data", "method_declar": "func subdata(in range: Range<Data.Index>) -> Data", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Dat"]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, that don\u2019t contain elements satisfying the given predicate.", "method_name": "split", "params": [{"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool", "param_description": "If false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.", "param_name": ["omittingEmptySubsequences"]}, {"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.", "param_name": ["whereSeparator", "isSeparator"]}], "class_name": "Data", "method_declar": "func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (UInt8) throws -> Bool) rethrows -> [Data]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.", "method_name": "split", "params": [{"param_type": "UInt8", "param_description": "The element that should be split upon.", "param_name": ["separator"]}, {"param_type": "Int", "param_description": "The maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.", "param_name": ["maxSplits"]}, {"param_type": "Bool = true", "param_description": "If false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.", "param_name": ["omittingEmptySubsequences"]}], "class_name": "Data", "method_declar": "func split(separator: UInt8, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Data]", "return_value": {"return_description": ["An array of subsequences, split from this collection\u2019s elements."], "return_name": [""], "return_type": ["[Data"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether or not two data buffers are equivalent.", "method_name": "==", "params": [{"param_type": "Data", "param_description": "", "param_name": ["d1"]}, {"param_type": "Data", "param_description": "", "param_name": ["d2"]}], "class_name": "Data", "method_declar": "static func == (d1: Data, d2: Data) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": true}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "Data", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence and other contain the same elements in the same order."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}], "class_name": "Data", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element", "return_value": {"return_description": ["true if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}], "class_name": "Data", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.", "method_name": "lexicographicallyPrecedes", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(UInt8, UInt8) throws -> Bool", "param_description": "A predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.", "param_name": ["by", "areInIncreasingOrder"]}], "class_name": "Data", "method_declar": "func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (UInt8, UInt8) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element", "return_value": {"return_description": ["true if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index.", "method_name": "index", "params": [{"param_type": "Int", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i.", "param_name": ["offsetBy", "distance"]}], "class_name": "Data", "method_declar": "func index(_ i: Int, offsetBy distance: Int) -> Int", "return_value": {"return_description": ["An index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:)."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the index that immediately follows the specified index.", "method_name": "index", "params": [{"param_type": "Data.Index", "param_description": "", "param_name": ["after", "i"]}], "class_name": "Data", "method_declar": "func index(after i: Data.Index) -> Data.Index", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Data.Inde"]}, "is_static": false}, {"method_description": "Returns the index that immediately precedes the specified index.", "method_name": "index", "params": [{"param_type": "Data.Index", "param_description": "", "param_name": ["before", "i"]}], "class_name": "Data", "method_declar": "func index(before i: Data.Index) -> Data.Index", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Data.Inde"]}, "is_static": false}, {"method_description": "Returns the distance between two indices.", "method_name": "distance", "params": [{"param_type": "Int", "param_description": "A valid index of the collection.", "param_name": ["from", "start"]}, {"param_type": "Int", "param_description": "Another valid index of the collection. If end is equal to start, the result is zero.", "param_name": ["to", "end"]}], "class_name": "Data", "method_declar": "func distance(from start: Int, to end: Int) -> Int", "return_value": {"return_description": ["The distance between start and end."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "Sequence", "param_description": "", "param_name": ["elements"]}], "class_name": "Data", "method_declar": "init<S>(_ elements: S) where S : Sequence, S.Element == UInt8", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "Sequence", "param_description": "", "param_name": ["bytes", "elements"]}], "class_name": "Data", "method_declar": "init<S>(bytes elements: S) where S : Sequence, S.Element == UInt8", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "Decoder", "param_description": "", "param_name": ["from", "decoder"]}], "class_name": "Data", "method_declar": "init(from decoder: Decoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "UInt8", "param_description": "", "param_name": ["repeating", "repeatedValue"]}, {"param_type": "Int", "param_description": "", "param_name": ["count"]}], "class_name": "Data", "method_declar": "init(repeating repeatedValue: UInt8, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "", "method_name": "init", "params": [{"param_type": "UInt8", "param_description": "", "param_name": ["repeating", "repeatedValue"]}, {"param_type": "Int", "param_description": "", "param_name": ["count"]}], "class_name": "Data", "method_declar": "init(repeating repeatedValue: UInt8, count: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.", "method_name": "allSatisfy", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.", "param_name": ["predicate"]}], "class_name": "Data", "method_declar": "func allSatisfy(_ predicate: (UInt8) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains only elements that satisfy predicate; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "", "method_name": "append", "params": [{"param_type": "Sequence", "param_description": "", "param_name": ["contentsOf", "elements"]}], "class_name": "Data", "method_declar": "mutating func append<S>(contentsOf elements: S) where S : Sequence, S.Element == Data.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.", "method_name": "compactMap", "params": [{"param_type": "(UInt8) throws -> ElementOfResult", "param_description": "A closure that accepts an element of this sequence as its argument and returns an optional value.", "param_name": ["transform"]}], "class_name": "Data", "method_declar": "func compactMap<ElementOfResult>(_ transform: (UInt8) throws -> ElementOfResult?) rethrows -> [ElementOfResult]", "return_value": {"return_description": ["An array of the non-nil results of calling transform with each element of the sequence."], "return_name": [""], "return_type": ["[ElementOfResult"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains the given element.", "method_name": "contains", "params": [{"param_type": "UInt8", "param_description": "The element to find in the sequence.", "param_name": ["element"]}], "class_name": "Data", "method_declar": "func contains(_ element: UInt8) -> Bool", "return_value": {"return_description": ["true if the element was found in the sequence; otherwise, false."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.", "method_name": "contains", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Data", "method_declar": "func contains(where predicate: (UInt8) throws -> Bool) rethrows -> Bool", "return_value": {"return_description": ["true if the sequence contains an element that satisfies predicate; otherwise, false."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.", "method_name": "elementsEqual", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["other"]}, {"param_type": "(UInt8, OtherSequence.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "Data", "method_declar": "func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (UInt8, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence", "return_value": {"return_description": ["true if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "", "method_name": "encode", "params": [{"param_type": "Encoder", "param_description": "", "param_name": ["to", "encoder"]}], "class_name": "Data", "method_declar": "func encode(to encoder: Encoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the first index where the specified value appears in the collection.", "method_name": "firstIndex", "params": [{"param_type": "UInt8", "param_description": "An element to search for in the collection.", "param_name": ["of", "element"]}], "class_name": "Data", "method_declar": "func firstIndex(of element: UInt8) -> Int?", "return_value": {"return_description": ["The first index where element is found. If element is not found in the collection, returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the first index in which an element of the collection satisfies the given predicate.", "method_name": "firstIndex", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Data", "method_declar": "func firstIndex(where predicate: (UInt8) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}], "class_name": "Data", "method_declar": "func formIndex(_ i: inout Int, offsetBy distance: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Offsets the given index by the specified distance, or so that it equals the given limiting index.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Int", "param_description": "A valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Data", "method_declar": "func formIndex(_ i: inout Int, offsetBy distance: Int, limitedBy limit: Int) -> Bool", "return_value": {"return_description": ["true if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit."], "return_name": [""], "return_type": ["Boo"]}, "is_static": false}, {"method_description": "Replaces the given index with its successor.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection. i must be less than endIndex.", "param_name": ["after", "i"]}], "class_name": "Data", "method_declar": "func formIndex(after i: inout Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Replaces the given index with its predecessor.", "method_name": "formIndex", "params": [{"param_type": "inout Int", "param_description": "A valid index of the collection. i must be greater than startIndex.", "param_name": ["before", "i"]}], "class_name": "Data", "method_declar": "func formIndex(before i: inout Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.", "method_name": "index", "params": [{"param_type": "Int", "param_description": "A valid index of the array.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The distance to offset i.", "param_name": ["offsetBy", "distance"]}, {"param_type": "Int", "param_description": "A valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.", "param_name": ["limitedBy", "limit"]}], "class_name": "Data", "method_declar": "func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?", "return_value": {"return_description": ["An index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the last element of the sequence that satisfies the given predicate.", "method_name": "last", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.", "param_name": ["where", "predicate"]}], "class_name": "Data", "method_declar": "func last(where predicate: (UInt8) throws -> Bool) rethrows -> UInt8?", "return_value": {"return_description": ["The last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns the last index where the specified value appears in the collection.", "method_name": "lastIndex", "params": [{"param_type": "UInt8", "param_description": "An element to search for in the collection.", "param_name": ["of", "element"]}], "class_name": "Data", "method_declar": "func lastIndex(of element: UInt8) -> Int?", "return_value": {"return_description": ["The last index where element is found. If element is not found in the collection, this method returns nil."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Returns the index of the last element in the collection that matches the given predicate.", "method_name": "lastIndex", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.", "param_name": ["where", "predicate"]}], "class_name": "Data", "method_declar": "func lastIndex(where predicate: (UInt8) throws -> Bool) rethrows -> Int?", "return_value": {"return_description": ["The index of the last element in the collection that matches predicate, or nil if no elements match."], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(UInt8) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Data", "method_declar": "func map<T>(_ transform: (UInt8) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T"]}, "is_static": false}, {"method_description": "Returns an array containing the results of mapping the given closure over the sequence\u2019s elements.", "method_name": "map", "params": [{"param_type": "(UInt8) throws -> T", "param_description": "A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.", "param_name": ["transform"]}], "class_name": "Data", "method_declar": "func map<T>(_ transform: (UInt8) throws -> T) rethrows -> [T]", "return_value": {"return_description": ["An array containing the transformed elements of this sequence."], "return_name": [""], "return_type": ["[T"]}, "is_static": false}, {"method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "method_name": "partition", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_name": ["by", "belongsInSecondPartition"]}], "class_name": "Data", "method_declar": "mutating func partition(by belongsInSecondPartition: (UInt8) throws -> Bool) rethrows -> Int", "return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don\u2019t match.", "method_name": "partition", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.", "param_name": ["by", "belongsInSecondPartition"]}], "class_name": "Data", "method_declar": "mutating func partition(by belongsInSecondPartition: (UInt8) throws -> Bool) rethrows -> Int", "return_value": {"return_description": ["The index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection\u2019s endIndex."], "return_name": [""], "return_type": ["In"]}, "is_static": false}, {"method_description": "Removes and returns the first element of the collection.", "method_name": "popFirst", "params": [], "class_name": "Data", "method_declar": "mutating func popFirst() -> UInt8?", "return_value": {"return_description": ["The first element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes and returns the last element of the collection.", "method_name": "popLast", "params": [], "class_name": "Data", "method_declar": "mutating func popLast() -> UInt8?", "return_value": {"return_description": ["The last element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes and returns the last element of the collection.", "method_name": "popLast", "params": [], "class_name": "Data", "method_declar": "mutating func popLast() -> UInt8?", "return_value": {"return_description": ["The last element of the collection if the collection is not empty; otherwise, nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Returns a random element of the collection.", "method_name": "randomElement", "params": [], "class_name": "Data", "method_declar": "func randomElement() -> UInt8?", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Returns a random element of the collection, using the given generator as a source for randomness.", "method_name": "randomElement", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when choosing a random element.", "param_name": ["using", "generator"]}], "class_name": "Data", "method_declar": "func randomElement<T>(using generator: inout T) -> UInt8? where T : RandomNumberGenerator", "return_value": {"return_description": ["A random element from the collection. If the collection is empty, the method returns nil."], "return_name": [""], "return_type": ["UInt8"]}, "is_static": false}, {"method_description": "Removes all the elements that satisfy the given predicate.", "method_name": "removeAll", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.", "param_name": ["where", "shouldBeRemoved"]}], "class_name": "Data", "method_declar": "mutating func removeAll(where shouldBeRemoved: (UInt8) throws -> Bool) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Removes all the elements that satisfy the given predicate.", "method_name": "removeAll", "params": [{"param_type": "(UInt8) throws -> Bool", "param_description": "A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.", "param_name": ["where", "shouldBeRemoved"]}], "class_name": "Data", "method_declar": "mutating func removeAll(where shouldBeRemoved: (UInt8) throws -> Bool) rethrows", "return_value": {"return_description": [], "return_name": [""], "return_type": [""]}, "is_static": false}, {"method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "params": [], "class_name": "Data", "method_declar": "@discardableResult mutating func removeFirst() -> UInt8", "return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "params": [], "class_name": "Data", "method_declar": "@discardableResult mutating func removeFirst() -> UInt8", "return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes and returns the first element of the collection.", "method_name": "removeFirst", "params": [], "class_name": "Data", "method_declar": "@discardableResult mutating func removeFirst() -> UInt8", "return_value": {"return_description": ["The removed element."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "mutating func removeFirst(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "mutating func removeFirst(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the specified number of elements from the beginning of the collection.", "method_name": "removeFirst", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "mutating func removeFirst(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes and returns the last element of the collection.", "method_name": "removeLast", "params": [], "class_name": "Data", "method_declar": "@discardableResult mutating func removeLast() -> UInt8", "return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes and returns the last element of the collection.", "method_name": "removeLast", "params": [], "class_name": "Data", "method_declar": "@discardableResult mutating func removeLast() -> UInt8", "return_value": {"return_description": ["The last element of the collection."], "return_name": [""], "return_type": ["UInt"]}, "is_static": false}, {"method_description": "Removes the specified number of elements from the end of the collection.", "method_name": "removeLast", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "mutating func removeLast(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the specified number of elements from the end of the collection.", "method_name": "removeLast", "params": [{"param_type": "Int", "param_description": "The number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.", "param_name": ["k"]}], "class_name": "Data", "method_declar": "mutating func removeLast(_ k: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Removes the elements in the specified subrange from the collection.", "method_name": "removeSubrange", "params": [{"param_type": "RangeExpression", "param_description": "The range of the collection to be removed. The bounds of the range must be valid indices of the collection.", "param_name": ["bounds"]}], "class_name": "Data", "method_declar": "mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, Self.Index == R.Bound", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Reverses the elements of the collection in place.", "method_name": "reverse", "params": [], "class_name": "Data", "method_declar": "mutating func reverse()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Shuffles the collection in place.", "method_name": "shuffle", "params": [], "class_name": "Data", "method_declar": "mutating func shuffle()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Shuffles the collection in place, using the given generator as a source for randomness.", "method_name": "shuffle", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when shuffling the collection.", "param_name": ["using", "generator"]}], "class_name": "Data", "method_declar": "mutating func shuffle<T>(using generator: inout T) where T : RandomNumberGenerator", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled.", "method_name": "shuffled", "params": [], "class_name": "Data", "method_declar": "func shuffled() -> [UInt8]", "return_value": {"return_description": ["A shuffled array of this sequence\u2019s elements."], "return_name": [""], "return_type": ["[UInt8"]}, "is_static": false}, {"method_description": "Returns the elements of the sequence, shuffled using the given generator as a source for randomness.", "method_name": "shuffled", "params": [{"param_type": "inout T", "param_description": "The random number generator to use when shuffling the sequence.", "param_name": ["using", "generator"]}], "class_name": "Data", "method_declar": "func shuffled<T>(using generator: inout T) -> [UInt8] where T : RandomNumberGenerator", "return_value": {"return_description": ["An array of this sequence\u2019s elements in a shuffled order."], "return_name": [""], "return_type": ["[UInt8]"]}, "is_static": false}, {"method_description": "Sorts the collection in place.", "method_name": "sort", "params": [], "class_name": "Data", "method_declar": "mutating func sort()", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.", "method_name": "starts", "params": [{"param_type": "Sequence", "param_description": "A sequence to compare to this sequence.", "param_name": ["with", "possiblePrefix"]}, {"param_type": "(UInt8, PossiblePrefix.Element) throws -> Bool", "param_description": "A predicate that returns true if its two arguments are equivalent; otherwise, false.", "param_name": ["by", "areEquivalent"]}], "class_name": "Data", "method_declar": "func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (UInt8, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence", "return_value": {"return_description": ["true if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Exchanges the values at the specified indices of the collection.", "method_name": "swapAt", "params": [{"param_type": "Int", "param_description": "The index of the first value to swap.", "param_name": ["i"]}, {"param_type": "Int", "param_description": "The index of the second value to swap.", "param_name": ["j"]}], "class_name": "Data", "method_declar": "mutating func swapAt(_ i: Int, _ j: Int)", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "params": [{"param_type": "Data", "param_description": "A value to compare.", "param_name": ["lhs"]}, {"param_type": "Data", "param_description": "Another value to compare.", "param_name": ["rhs"]}], "class_name": "Data", "method_declar": "static func != (lhs: Data, rhs: Data) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Boo"]}, "is_static": true}, {"method_description": "Creates a new collection by concatenating the elements of a sequence and a collection.", "method_name": "+", "params": [{"param_type": "Sequence", "param_description": "A collection or finite sequence.", "param_name": ["lhs"]}, {"param_type": "Data", "param_description": "A range-replaceable collection.", "param_name": ["rhs"]}], "class_name": "Data", "method_declar": "static func + <Other>(lhs: Other, rhs: Data) -> Data where Other : Sequence, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Data"]}, "is_static": true}, {"method_description": "Creates a new collection by concatenating the elements of a collection and a sequence.", "method_name": "+", "params": [{"param_type": "Data", "param_description": "A range-replaceable collection.", "param_name": ["lhs"]}, {"param_type": "Sequence", "param_description": "A collection or finite sequence.", "param_name": ["rhs"]}], "class_name": "Data", "method_declar": "static func + <Other>(lhs: Data, rhs: Other) -> Data where Other : Sequence, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Data"]}, "is_static": true}, {"method_description": "Creates a new collection by concatenating the elements of two collections.", "method_name": "+", "params": [{"param_type": "Data", "param_description": "A range-replaceable collection.", "param_name": ["lhs"]}, {"param_type": "RangeReplaceableCollection", "param_description": "Another range-replaceable collection.", "param_name": ["rhs"]}], "class_name": "Data", "method_declar": "static func + <Other>(lhs: Data, rhs: Other) -> Data where Other : RangeReplaceableCollection, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Data"]}, "is_static": true}, {"method_description": "Appends the elements of a sequence to a range-replaceable collection.", "method_name": "+=", "params": [{"param_type": "inout Data", "param_description": "The array to append to.", "param_name": ["lhs"]}, {"param_type": "Sequence", "param_description": "A collection or finite sequence.", "param_name": ["rhs"]}], "class_name": "Data", "method_declar": "static func += <Other>(lhs: inout Data, rhs: Other) where Other : Sequence, Self.Element == Other.Element", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": true}], "class_inherit_list": [], "class_name": "Data", "typealias": ["typealias Data.ReadingOptions = NSData.ReadingOptions", "typealias Data.WritingOptions = NSData.WritingOptions", "typealias Data.Base64DecodingOptions = NSData.Base64DecodingOptions", "typealias Data.Base64EncodingOptions = NSData.Base64EncodingOptions", "typealias Data.SearchOptions = NSData.SearchOptions", "typealias Data.Index = Int", "typealias Data.Indices = Range<Int>", "typealias Data.ReferenceType = NSData"], "Vars": [{"var_description": "A Boolean value indicating whether the collection is empty.", "var_type": "Bool", "is_static": false, "var_name": "isEmpty"}, {"var_description": "A sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.", "var_type": "LazySequence<Data>", "is_static": false, "var_name": "lazy"}, {"var_description": "The beginning index into the data.", "var_type": "Data.Index", "is_static": false, "var_name": "startIndex"}, {"var_description": "The end index into the data.", "var_type": "Data.Index", "is_static": false, "var_name": "endIndex"}, {"var_description": "A textual description of the data.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A textual description the data suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the data.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}, {"var_description": "The hash value for the data.", "var_type": "Int", "is_static": false, "var_name": "hashValue"}, {"var_description": "", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "", "var_type": "Int", "is_static": false, "var_name": "count"}, {"var_description": "The first element of the collection.", "var_type": "UInt8", "is_static": false, "var_name": "first"}, {"var_description": "", "var_type": "Range<Int>", "is_static": false, "var_name": "indices"}, {"var_description": "", "var_type": "Range<Int>", "is_static": false, "var_name": "indices"}, {"var_description": "The last element of the collection.", "var_type": "UInt8", "is_static": false, "var_name": "last"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}, {"var_description": "A value less than or equal to the number of elements in the collection.", "var_type": "Int", "is_static": false, "var_name": "underestimatedCount"}], "class_type": "struct", "interface_list": ["CKRecordValueProtocol", "CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "Hashable", "MutableCollection", "RandomAccessCollection", "RangeReplaceableCollection", "ReferenceConvertible"], "package_name": "foundation", "subclass_list": []}