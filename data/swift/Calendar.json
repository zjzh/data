{"package_name": "foundation", "subclass_list": [], "class_description": "Calendar encapsulates information about systems of reckoning time in which the beginning, length, and divisions of a year are defined. It provides information about the calendar and support for calendrical computations such as determining the range of a given calendrical unit and adding units to a given absolute time.\n", "class_type": "struct", "typealias": ["typealias Calendar.ReferenceType = NSCalendar"], "interface_list": ["CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "Hashable", "ReferenceConvertible"], "class_inherit_list": [], "Methods": [{"params": [{"param_name": ["date"], "param_type": "Date", "param_description": ""}, {"param_name": ["matchesComponents", "components"], "param_type": "DateComponents", "param_description": ""}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the date matches all of the components, otherwise false."], "return_type": ["Boo"]}, "method_name": "date", "method_description": "Determines if the date has all of the specified date components.", "method_declar": "func date(_ date: Date, matchesComponents components: DateComponents) -> Bool"}, {"params": [{"param_name": ["component"], "param_type": "Calendar.Component", "param_description": "The component to calculate."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The date to use."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The value for the component."], "return_type": ["In"]}, "method_name": "component", "method_description": "Returns the value for one component of a date.", "method_declar": "func component(_ component: Calendar.Component, from date: Date) -> Int"}, {"params": [{"param_name": ["components"], "param_type": "Set<Calendar.Component>", "param_description": ""}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The Date to use."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The date components of the specified date."], "return_type": ["DateComponent"]}, "method_name": "dateComponents", "method_description": "Returns all the date components of a date, using the calendar time zone.", "method_declar": "func dateComponents(_ components: Set<Calendar.Component>, from date: Date) -> DateComponents"}, {"params": [{"param_name": ["components"], "param_type": "Set<Calendar.Component>", "param_description": "Which components to compare."}, {"param_name": ["from", "start"], "param_type": "Date", "param_description": "The starting date."}, {"param_name": ["to", "end"], "param_type": "Date", "param_description": "The ending date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The result of calculating the difference from start to end."], "return_type": ["DateComponent"]}, "method_name": "dateComponents", "method_description": "Returns the difference between two dates.", "method_declar": "func dateComponents(_ components: Set<Calendar.Component>, from start: Date, to end: Date) -> DateComponents"}, {"params": [{"param_name": ["components"], "param_type": "Set<Calendar.Component>", "param_description": "Which components to compare."}, {"param_name": ["from", "start"], "param_type": "DateComponents", "param_description": "The starting date components."}, {"param_name": ["to", "end"], "param_type": "DateComponents", "param_description": "The ending date components."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The result of calculating the difference from start to end."], "return_type": ["DateComponent"]}, "method_name": "dateComponents", "method_description": "Returns the difference between two dates specified as DateComponents.", "method_declar": "func dateComponents(_ components: Set<Calendar.Component>, from start: DateComponents, to end: DateComponents) -> DateComponents"}, {"params": [{"param_name": ["in", "timeZone"], "param_type": "TimeZone", "param_description": "The TimeZone to use."}, {"param_name": ["from", "date"], "param_type": "Date", "param_description": "The Date to use."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["All components, calculated using the Calendar and TimeZone."], "return_type": ["DateComponent"]}, "method_name": "dateComponents", "method_description": "Returns all the date components of a date, as if in a given time zone (instead of the Calendar time zone).", "method_declar": "func dateComponents(in timeZone: TimeZone, from date: Date) -> DateComponents"}, {"params": [{"param_name": ["of", "component"], "param_type": "Calendar.Component", "param_description": "A component to calculate a range for."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The range, or nil if it could not be calculated."], "return_type": ["Range<Int"]}, "method_name": "maximumRange", "method_description": "The maximum range limits of the values that a given component can take on.", "method_declar": "func maximumRange(of component: Calendar.Component) -> Range<Int>?"}, {"params": [{"param_name": ["of", "component"], "param_type": "Calendar.Component", "param_description": "A component to calculate a range for."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The range, or nil if it could not be calculated."], "return_type": ["Range<Int"]}, "method_name": "minimumRange", "method_description": "Returns the minimum range limits of the values that a given component can take on.", "method_declar": "func minimumRange(of component: Calendar.Component) -> Range<Int>?"}, {"params": [{"param_name": ["of", "smaller"], "param_type": "Calendar.Component", "param_description": "The smaller calendar component."}, {"param_name": ["in", "larger"], "param_type": "Calendar.Component", "param_description": "The larger calendar component."}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "The absolute time for which the calculation is performed."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The ordinal number of smaller within larger at the time specified by date. Returns nil if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined)."], "return_type": ["In"]}, "method_name": "ordinality", "method_description": "Returns, for a given absolute time, the ordinal number of a smaller calendar component (such as a day) within a specified larger calendar component (such as a week).", "method_declar": "func ordinality(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Int?"}, {"params": [{"param_name": ["of", "smaller"], "param_type": "Calendar.Component", "param_description": "The smaller calendar component."}, {"param_name": ["in", "larger"], "param_type": "Calendar.Component", "param_description": "The larger calendar component."}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "The absolute time for which the calculation is performed."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The range of absolute time values smaller can take on in larger at the time specified by date. Returns nil if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined)."], "return_type": ["Range<Int"]}, "method_name": "range", "method_description": "Returns the range of absolute time values that a smaller calendar component (such as a day) can take on in a larger calendar component (such as a month) that includes a specified absolute time.", "method_declar": "func range(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Range<Int>?"}, {"params": [{"param_name": ["for", "date"], "param_type": "Date", "param_description": "The date to search."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["The first moment of the given date."], "return_type": ["Dat"]}, "method_name": "startOfDay", "method_description": "Returns the first moment of a given Date, as a Date.", "method_declar": "func startOfDay(for date: Date) -> Date"}, {"params": [{"param_name": ["startingAfter", "start"], "param_type": "Date", "param_description": "The Date at which to start the search."}, {"param_name": ["matching", "components"], "param_type": "DateComponents", "param_description": "The DateComponents to use as input to the search algorithm."}, {"param_name": ["matchingPolicy"], "param_type": "Calendar.MatchingPolicy", "param_description": "Determines the behavior of the search algorithm when the input produces an ambiguous result."}, {"param_name": ["repeatedTimePolicy"], "param_type": "Calendar.RepeatedTimePolicy", "param_description": "Determines the behavior of the search algorithm when the input produces a time that occurs twice on a particular day."}, {"param_name": ["direction"], "param_type": "Calendar.SearchDirection", "param_description": "Which direction in time to search. The default value is .forward, which means later in time."}, {"param_name": ["using", "block"], "param_type": "(Date, Bool, inout Bool) -> Void", "param_description": "A closure that is called with search results."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Void"]}, "method_name": "enumerateDates", "method_description": "Computes the dates which match (or most closely match) a given set of components, and calls the closure once for each of them, until the enumeration is stopped.", "method_declar": "func enumerateDates(startingAfter start: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward, using block: (Date?, Bool, inout Bool) -> Void)"}, {"params": [{"param_name": ["after", "date"], "param_type": "Date", "param_description": "The starting date."}, {"param_name": ["matching", "components"], "param_type": "DateComponents", "param_description": "The components to search for."}, {"param_name": ["matchingPolicy"], "param_type": "Calendar.MatchingPolicy", "param_description": "Specifies the technique the search algorithm uses to find results. Default value is .nextTime."}, {"param_name": ["repeatedTimePolicy"], "param_type": "Calendar.RepeatedTimePolicy", "param_description": "Specifies the behavior when multiple matches are found. Default value is .first."}, {"param_name": ["direction"], "param_type": "Calendar.SearchDirection = .forward", "param_description": "Specifies the direction in time to search. Default is .forward."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A Date representing the result of the search, or nil if a result could not be found."], "return_type": ["Dat"]}, "method_name": "nextDate", "method_description": "Computes the next date which matches (or most closely matches) a given set of components.", "method_declar": "func nextDate(after date: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?"}, {"params": [{"param_name": ["from", "components"], "param_type": "DateComponents", "param_description": "Used as input to the search algorithm for finding a corresponding date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new Date, or nil if a date could not be found which matches the components."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a date created from the specified components.", "method_declar": "func date(from components: DateComponents) -> Date?"}, {"params": [{"param_name": ["byAdding", "components"], "param_type": "DateComponents", "param_description": "A set of values to add to the date."}, {"param_name": ["to", "date"], "param_type": "Date", "param_description": "The starting date."}, {"param_name": ["wrappingComponents"], "param_type": "Bool = false", "param_description": "If true, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is false."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new date, or nil if a date could not be calculated with the given input."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a new Date representing the date calculated by adding components to a given date.", "method_declar": "func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = false) -> Date?"}, {"params": [{"param_name": ["byAdding", "component"], "param_type": "Calendar.Component", "param_description": "A single component to add."}, {"param_name": ["value"], "param_type": "Int", "param_description": "The value of the specified component to add."}, {"param_name": ["to", "date"], "param_type": "Date", "param_description": "The starting date."}, {"param_name": ["wrappingComponents"], "param_type": "Bool = false", "param_description": "If true, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is false."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new date, or nil if a date could not be calculated with the given input."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a new Date representing the date calculated by adding an amount of a specific component to a given date.", "method_declar": "func date(byAdding component: Calendar.Component, value: Int, to date: Date, wrappingComponents: Bool = false) -> Date?"}, {"params": [{"param_name": ["bySetting", "component"], "param_type": "Calendar.Component", "param_description": ""}, {"param_name": ["value"], "param_type": "Int", "param_description": ""}, {"param_name": ["of", "date"], "param_type": "Date", "param_description": ""}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a new Date representing the date calculated by setting a specific component to a given time, and trying to keep lower components the same.  If the component already has that value, this may result in a date which is the same as the given date.", "method_declar": "func date(bySetting component: Calendar.Component, value: Int, of date: Date) -> Date?"}, {"params": [{"param_name": ["bySettingHour", "hour"], "param_type": "Int", "param_description": "A specified hour."}, {"param_name": ["minute"], "param_type": "Int", "param_description": "A specified minute."}, {"param_name": ["second"], "param_type": "Int", "param_description": "A specified second."}, {"param_name": ["of", "date"], "param_type": "Date", "param_description": "The date to start calculation with."}, {"param_name": ["matchingPolicy"], "param_type": "Calendar.MatchingPolicy", "param_description": "Specifies the technique the search algorithm uses to find results. Default value is .nextTime."}, {"param_name": ["repeatedTimePolicy"], "param_type": "Calendar.RepeatedTimePolicy", "param_description": "Specifies the behavior when multiple matches are found. Default value is .first."}, {"param_name": ["direction"], "param_type": "Calendar.SearchDirection = .forward", "param_description": "Specifies the direction in time to search. Default is .forward."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A Date representing the result of the search, or nil if a result could not be found."], "return_type": ["Dat"]}, "method_name": "date", "method_description": "Returns a new Date representing the date calculated by setting hour, minute, and second to a given time on a specified Date.", "method_declar": "func date(bySettingHour hour: Int, minute: Int, second: Int, of date: Date, matchingPolicy: Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?"}, {"params": [{"param_name": ["of", "component"], "param_type": "Calendar.Component", "param_description": "A calendar component."}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "The specified date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A new DateInterval if the starting time and duration of a component could be calculated; otherwise, nil."], "return_type": ["DateInterva"]}, "method_name": "dateInterval", "method_description": "Returns the starting time and duration of a given calendar component that contains a given date.", "method_declar": "func dateInterval(of component: Calendar.Component, for date: Date) -> DateInterval?"}, {"params": [{"param_name": ["of", "component"], "param_type": "Calendar.Component", "param_description": "A calendar component."}, {"param_name": ["start"], "param_type": "inout Date", "param_description": "Upon return, the starting time of the calendar component that contains the date."}, {"param_name": ["interval"], "param_type": "inout TimeInterval", "param_description": "Upon return, the duration of the calendar component that contains the date."}, {"param_name": ["for", "date"], "param_type": "Date", "param_description": "The specified date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the starting time and duration of a component could be calculated; otherwise, false."], "return_type": ["Boo"]}, "method_name": "dateInterval", "method_description": "Returns, via two inout parameters, the starting time and duration of a given calendar component that contains a given date.", "method_declar": "func dateInterval(of component: Calendar.Component, start: inout Date, interval: inout TimeInterval, for date: Date) -> Bool"}, {"params": [{"param_name": ["containing", "date"], "param_type": "Date", "param_description": "The date contained in the weekend."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A DateInterval, or nil if the date is not in a weekend."], "return_type": ["DateInterva"]}, "method_name": "dateIntervalOfWeekend", "method_description": "Returns a DateInterval of the weekend contained by the given date, or nil if the date is not in a weekend.", "method_declar": "func dateIntervalOfWeekend(containing date: Date) -> DateInterval?"}, {"params": [{"param_name": ["containing", "date"], "param_type": "Date", "param_description": "The date at which to start the search."}, {"param_name": ["start"], "param_type": "inout Date", "param_description": "When the result is true, set"}, {"param_name": ["interval"], "param_type": "inout TimeInterval", "param_description": ""}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if a date range could be found, and false if the date is not in a weekend."], "return_type": ["Boo"]}, "method_name": "dateIntervalOfWeekend", "method_description": "Find the range of the weekend around the given date, returned via two by-reference parameters.", "method_declar": "func dateIntervalOfWeekend(containing date: Date, start: inout Date, interval: inout TimeInterval) -> Bool"}, {"params": [{"param_name": ["startingAfter", "date"], "param_type": "Date", "param_description": "The date at which to begin the search."}, {"param_name": ["direction"], "param_type": "Calendar.SearchDirection = .forward", "param_description": "Which direction in time to search. The default value is .forward."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A DateInterval, or nil if weekends do not exist in the specific calendar or locale."], "return_type": ["DateInterva"]}, "method_name": "nextWeekend", "method_description": "Returns a DateInterval of the next weekend, which starts strictly after the given date.", "method_declar": "func nextWeekend(startingAfter date: Date, direction: Calendar.SearchDirection = .forward) -> DateInterval?"}, {"params": [{"param_name": ["startingAfter", "date"], "param_type": "Date", "param_description": "The date at which to begin the search."}, {"param_name": ["start"], "param_type": "inout Date", "param_description": ""}, {"param_name": ["interval"], "param_type": "inout TimeInterval", "param_description": ""}, {"param_name": ["direction"], "param_type": "Calendar.SearchDirection = .forward", "param_description": "Which direction in time to search. The default value is .forward."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["A DateInterval, or nil if the weekend could not be found."], "return_type": ["Boo"]}, "method_name": "nextWeekend", "method_description": "Returns the range of the next weekend via two inout parameters. The weekend starts strictly after the given date.", "method_declar": "func nextWeekend(startingAfter date: Date, start: inout Date, interval: inout TimeInterval, direction: Calendar.SearchDirection = .forward) -> Bool"}, {"params": [{"param_name": ["date1"], "param_type": "Date", "param_description": "A date to compare."}, {"param_name": ["to", "date2"], "param_type": "Date", "param_description": "A date to compare."}, {"param_name": ["toGranularity", "component"], "param_type": "Calendar.Component", "param_description": "A granularity to compare. For example, pass .hour to check if two dates are in the same hour."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": [".orderedSame if the two dates are equal in the given component and all larger components; otherwise, either .orderedAscending or .orderedDescending."], "return_type": ["ComparisonResul"]}, "method_name": "compare", "method_description": "Compares two dates down to the specified component.", "method_declar": "func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -> ComparisonResult"}, {"params": [{"param_name": ["date1"], "param_type": "Date", "param_description": "A date to compare."}, {"param_name": ["equalTo", "date2"], "param_type": "Date", "param_description": "A date to compare."}, {"param_name": ["toGranularity", "component"], "param_type": "Calendar.Component", "param_description": "A granularity to compare. For example, pass .hour to check if two dates are in the same hour."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the two dates are equal in the given component and all larger components; otherwise, false."], "return_type": ["Boo"]}, "method_name": "isDate", "method_description": "Returns a Boolean value indicating whether two dates are equal down to the specified component.", "method_declar": "func isDate(_ date1: Date, equalTo date2: Date, toGranularity component: Calendar.Component) -> Bool"}, {"params": [{"param_name": ["date1"], "param_type": "Date", "param_description": "A date to check for containment."}, {"param_name": ["inSameDayAs", "date2"], "param_type": "Date", "param_description": "A date to check for containment."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if date1 and date2 are in the same day, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_type": ["Boo"]}, "method_name": "isDate", "method_description": "Returns a Boolean value indicating whether a date is within the same day as another date.", "method_declar": "func isDate(_ date1: Date, inSameDayAs date2: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The specified date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is within today, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_type": ["Boo"]}, "method_name": "isDateInToday", "method_description": "Returns a Boolean value indicating whether the given date is within today.", "method_declar": "func isDateInToday(_ date: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The specified date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is within tomorrow, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_type": ["Boo"]}, "method_name": "isDateInTomorrow", "method_description": "Returns a Boolean value indicating whether the given date is within tomorrow.", "method_declar": "func isDateInTomorrow(_ date: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The specified date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is within yesterday, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_type": ["Boo"]}, "method_name": "isDateInYesterday", "method_description": "Returns a Boolean value indicating whether the given date is within yesterday.", "method_declar": "func isDateInYesterday(_ date: Date) -> Bool"}, {"params": [{"param_name": ["date"], "param_type": "Date", "param_description": "The specified date."}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [""], "return_description": ["true if the given date is within a weekend, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_type": ["Boo"]}, "method_name": "isDateInWeekend", "method_description": "Returns a Boolean value indicating whether the given date is within a weekend period.", "method_declar": "func isDateInWeekend(_ date: Date) -> Bool"}, {"params": [{"param_name": ["lhs"], "param_type": "Calendar", "param_description": ""}, {"param_name": ["rhs"], "param_type": "Calendar", "param_description": ""}], "class_name": "Calendar", "is_static": true, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Boo"]}, "method_name": "==", "method_description": "Returns a Boolean indicating whether two calendars are the same.", "method_declar": "static func == (lhs: Calendar, rhs: Calendar) -> Bool"}, {"params": [{"param_name": ["lhs"], "param_type": "Calendar", "param_description": "A value to compare."}, {"param_name": ["rhs"], "param_type": "Calendar", "param_description": "Another value to compare."}], "class_name": "Calendar", "is_static": true, "return_value": {"return_name": [""], "return_description": [], "return_type": ["Boo"]}, "method_name": "!=", "method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_declar": "static func != (lhs: Calendar, rhs: Calendar) -> Bool"}, {"params": [{"param_name": ["to", "encoder"], "param_type": "Encoder", "param_description": ""}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "encode", "method_description": "Encodes this calendar into the given encoder.", "method_declar": "func encode(to encoder: Encoder) throws"}, {"params": [{"param_name": ["from", "decoder"], "param_type": "Decoder", "param_description": ""}], "class_name": "Calendar", "is_static": false, "return_value": {"return_name": [], "return_description": [], "return_type": []}, "method_name": "init", "method_description": "Creates a new calendar instance by decoding from the given decoder.", "method_declar": "init(from decoder: Decoder) throws"}], "class_name": "Calendar", "Vars": [{"var_description": "A calendar that tracks changes to user\u2019s preferred calendar.", "var_type": "Calendar", "is_static": false, "var_name": "autoupdatingCurrent"}, {"var_description": "The user\u2019s current calendar.", "var_type": "Calendar", "is_static": false, "var_name": "current"}, {"var_description": "The identifier of the calendar.", "var_type": "Calendar.Identifier", "is_static": false, "var_name": "identifier"}, {"var_description": "The locale of the calendar.", "var_type": "Locale", "is_static": false, "var_name": "locale"}, {"var_description": "The first weekday of the calendar.", "var_type": "Int", "is_static": false, "var_name": "firstWeekday"}, {"var_description": "The number of minimum days in the first week.", "var_type": "Int", "is_static": false, "var_name": "minimumDaysInFirstWeek"}, {"var_description": "The time zone of the calendar.", "var_type": "TimeZone", "is_static": false, "var_name": "timeZone"}, {"var_description": "The symbol used to represent \u201cAM\u201d, localized to the Calendar\u2019s locale.", "var_type": "String", "is_static": false, "var_name": "amSymbol"}, {"var_description": "The symbol used to represent \u201cPM\u201d, localized to the Calendar\u2019s locale.", "var_type": "String", "is_static": false, "var_name": "pmSymbol"}, {"var_description": "A list of weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "weekdaySymbols"}, {"var_description": "A list of shorter-named weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortWeekdaySymbols"}, {"var_description": "A list of very-shortly-named weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortWeekdaySymbols"}, {"var_description": "A list of standalone weekday names in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "standaloneWeekdaySymbols"}, {"var_description": "A list of shorter-named standalone weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneWeekdaySymbols"}, {"var_description": "A list of very-shortly-named weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortStandaloneWeekdaySymbols"}, {"var_description": "A list of months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "monthSymbols"}, {"var_description": "A list of shorter-named months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortMonthSymbols"}, {"var_description": "A list of very-shortly-named months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortMonthSymbols"}, {"var_description": "A list of standalone months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "standaloneMonthSymbols"}, {"var_description": "A list of shorter-named standalone months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneMonthSymbols"}, {"var_description": "A list of very-shortly-named standalone months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortStandaloneMonthSymbols"}, {"var_description": "A list of quarter names in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "quarterSymbols"}, {"var_description": "A list of shorter-named quarters in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortQuarterSymbols"}, {"var_description": "A list of standalone quarter names in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "standaloneQuarterSymbols"}, {"var_description": "A list of shorter-named standalone quarters in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneQuarterSymbols"}, {"var_description": "A list of eras in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "eraSymbols"}, {"var_description": "A list of longer-named eras in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "longEraSymbols"}, {"var_description": "A textual description of the calendar.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A textual description of the locale suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the calendar.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}, {"var_description": "The computed hash value for the calendar.", "var_type": "Int", "is_static": false, "var_name": "hashValue"}]}