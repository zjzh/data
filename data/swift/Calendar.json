{"class_description": "Calendar encapsulates information about systems of reckoning time in which the beginning, length, and divisions of a year are defined. It provides information about the calendar and support for calendrical computations such as determining the range of a given calendrical unit and adding units to a given absolute time.\n", "Methods": [{"method_description": "Determines if the date has all of the specified date components.", "method_name": "date", "params": [{"param_type": "Date", "param_description": "", "param_name": ["date"]}, {"param_type": "DateComponents", "param_description": "", "param_name": ["matchesComponents", "components"]}], "class_name": "Calendar", "method_declar": "func date(_ date: Date, matchesComponents components: DateComponents) -> Bool", "return_value": {"return_description": ["true if the date matches all of the components, otherwise false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns the value for one component of a date.", "method_name": "component", "params": [{"param_type": "Calendar.Component", "param_description": "The component to calculate.", "param_name": ["component"]}, {"param_type": "Date", "param_description": "The date to use.", "param_name": ["from", "date"]}], "class_name": "Calendar", "method_declar": "func component(_ component: Calendar.Component, from date: Date) -> Int", "return_value": {"return_description": ["The value for the component."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Returns all the date components of a date, using the calendar time zone.", "method_name": "dateComponents", "params": [{"param_type": "Set<Calendar.Component>", "param_description": "", "param_name": ["components"]}, {"param_type": "Date", "param_description": "The Date to use.", "param_name": ["from", "date"]}], "class_name": "Calendar", "method_declar": "func dateComponents(_ components: Set<Calendar.Component>, from date: Date) -> DateComponents", "return_value": {"return_description": ["The date components of the specified date."], "return_name": [""], "return_type": ["DateComponents"]}, "is_static": false}, {"method_description": "Returns the difference between two dates.", "method_name": "dateComponents", "params": [{"param_type": "Set<Calendar.Component>", "param_description": "Which components to compare.", "param_name": ["components"]}, {"param_type": "Date", "param_description": "The starting date.", "param_name": ["from", "start"]}, {"param_type": "Date", "param_description": "The ending date.", "param_name": ["to", "end"]}], "class_name": "Calendar", "method_declar": "func dateComponents(_ components: Set<Calendar.Component>, from start: Date, to end: Date) -> DateComponents", "return_value": {"return_description": ["The result of calculating the difference from start to end."], "return_name": [""], "return_type": ["DateComponents"]}, "is_static": false}, {"method_description": "Returns the difference between two dates specified as DateComponents.", "method_name": "dateComponents", "params": [{"param_type": "Set<Calendar.Component>", "param_description": "Which components to compare.", "param_name": ["components"]}, {"param_type": "DateComponents", "param_description": "The starting date components.", "param_name": ["from", "start"]}, {"param_type": "DateComponents", "param_description": "The ending date components.", "param_name": ["to", "end"]}], "class_name": "Calendar", "method_declar": "func dateComponents(_ components: Set<Calendar.Component>, from start: DateComponents, to end: DateComponents) -> DateComponents", "return_value": {"return_description": ["The result of calculating the difference from start to end."], "return_name": [""], "return_type": ["DateComponents"]}, "is_static": false}, {"method_description": "Returns all the date components of a date, as if in a given time zone (instead of the Calendar time zone).", "method_name": "dateComponents", "params": [{"param_type": "TimeZone", "param_description": "The TimeZone to use.", "param_name": ["in", "timeZone"]}, {"param_type": "Date", "param_description": "The Date to use.", "param_name": ["from", "date"]}], "class_name": "Calendar", "method_declar": "func dateComponents(in timeZone: TimeZone, from date: Date) -> DateComponents", "return_value": {"return_description": ["All components, calculated using the Calendar and TimeZone."], "return_name": [""], "return_type": ["DateComponents"]}, "is_static": false}, {"method_description": "The maximum range limits of the values that a given component can take on.", "method_name": "maximumRange", "params": [{"param_type": "Calendar.Component", "param_description": "A component to calculate a range for.", "param_name": ["of", "component"]}], "class_name": "Calendar", "method_declar": "func maximumRange(of component: Calendar.Component) -> Range<Int>?", "return_value": {"return_description": ["The range, or nil if it could not be calculated."], "return_name": [""], "return_type": ["Range<Int>"]}, "is_static": false}, {"method_description": "Returns the minimum range limits of the values that a given component can take on.", "method_name": "minimumRange", "params": [{"param_type": "Calendar.Component", "param_description": "A component to calculate a range for.", "param_name": ["of", "component"]}], "class_name": "Calendar", "method_declar": "func minimumRange(of component: Calendar.Component) -> Range<Int>?", "return_value": {"return_description": ["The range, or nil if it could not be calculated."], "return_name": [""], "return_type": ["Range<Int>"]}, "is_static": false}, {"method_description": "Returns, for a given absolute time, the ordinal number of a smaller calendar component (such as a day) within a specified larger calendar component (such as a week).", "method_name": "ordinality", "params": [{"param_type": "Calendar.Component", "param_description": "The smaller calendar component.", "param_name": ["of", "smaller"]}, {"param_type": "Calendar.Component", "param_description": "The larger calendar component.", "param_name": ["in", "larger"]}, {"param_type": "Date", "param_description": "The absolute time for which the calculation is performed.", "param_name": ["for", "date"]}], "class_name": "Calendar", "method_declar": "func ordinality(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Int?", "return_value": {"return_description": ["The ordinal number of smaller within larger at the time specified by date. Returns nil if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined)."], "return_name": [""], "return_type": ["Int"]}, "is_static": false}, {"method_description": "Returns the range of absolute time values that a smaller calendar component (such as a day) can take on in a larger calendar component (such as a month) that includes a specified absolute time.", "method_name": "range", "params": [{"param_type": "Calendar.Component", "param_description": "The smaller calendar component.", "param_name": ["of", "smaller"]}, {"param_type": "Calendar.Component", "param_description": "The larger calendar component.", "param_name": ["in", "larger"]}, {"param_type": "Date", "param_description": "The absolute time for which the calculation is performed.", "param_name": ["for", "date"]}], "class_name": "Calendar", "method_declar": "func range(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Range<Int>?", "return_value": {"return_description": ["The range of absolute time values smaller can take on in larger at the time specified by date. Returns nil if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined)."], "return_name": [""], "return_type": ["Range<Int>"]}, "is_static": false}, {"method_description": "Returns the first moment of a given Date, as a Date.", "method_name": "startOfDay", "params": [{"param_type": "Date", "param_description": "The date to search.", "param_name": ["for", "date"]}], "class_name": "Calendar", "method_declar": "func startOfDay(for date: Date) -> Date", "return_value": {"return_description": ["The first moment of the given date."], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Computes the dates which match (or most closely match) a given set of components, and calls the closure once for each of them, until the enumeration is stopped.", "method_name": "enumerateDates", "params": [{"param_type": "Date", "param_description": "The Date at which to start the search.", "param_name": ["startingAfter", "start"]}, {"param_type": "DateComponents", "param_description": "The DateComponents to use as input to the search algorithm.", "param_name": ["matching", "components"]}, {"param_type": "Calendar.MatchingPolicy", "param_description": "Determines the behavior of the search algorithm when the input produces an ambiguous result.", "param_name": ["matchingPolicy"]}, {"param_type": "Calendar.RepeatedTimePolicy", "param_description": "Determines the behavior of the search algorithm when the input produces a time that occurs twice on a particular day.", "param_name": ["repeatedTimePolicy"]}, {"param_type": "Calendar.SearchDirection", "param_description": "Which direction in time to search. The default value is .forward, which means later in time.", "param_name": ["direction"]}, {"param_type": "(Date, Bool, inout Bool) -> Void", "param_description": "A closure that is called with search results.", "param_name": ["using", "block"]}], "class_name": "Calendar", "method_declar": "func enumerateDates(startingAfter start: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward, using block: (Date?, Bool, inout Bool) -> Void)", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Void"]}, "is_static": false}, {"method_description": "Computes the next date which matches (or most closely matches) a given set of components.", "method_name": "nextDate", "params": [{"param_type": "Date", "param_description": "The starting date.", "param_name": ["after", "date"]}, {"param_type": "DateComponents", "param_description": "The components to search for.", "param_name": ["matching", "components"]}, {"param_type": "Calendar.MatchingPolicy", "param_description": "Specifies the technique the search algorithm uses to find results. Default value is .nextTime.", "param_name": ["matchingPolicy"]}, {"param_type": "Calendar.RepeatedTimePolicy", "param_description": "Specifies the behavior when multiple matches are found. Default value is .first.", "param_name": ["repeatedTimePolicy"]}, {"param_type": "Calendar.SearchDirection = .forward", "param_description": "Specifies the direction in time to search. Default is .forward.", "param_name": ["direction"]}], "class_name": "Calendar", "method_declar": "func nextDate(after date: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?", "return_value": {"return_description": ["A Date representing the result of the search, or nil if a result could not be found."], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Returns a date created from the specified components.", "method_name": "date", "params": [{"param_type": "DateComponents", "param_description": "Used as input to the search algorithm for finding a corresponding date.", "param_name": ["from", "components"]}], "class_name": "Calendar", "method_declar": "func date(from components: DateComponents) -> Date?", "return_value": {"return_description": ["A new Date, or nil if a date could not be found which matches the components."], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Returns a new Date representing the date calculated by adding components to a given date.", "method_name": "date", "params": [{"param_type": "DateComponents", "param_description": "A set of values to add to the date.", "param_name": ["byAdding", "components"]}, {"param_type": "Date", "param_description": "The starting date.", "param_name": ["to", "date"]}, {"param_type": "Bool = false", "param_description": "If true, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is false.", "param_name": ["wrappingComponents"]}], "class_name": "Calendar", "method_declar": "func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = false) -> Date?", "return_value": {"return_description": ["A new date, or nil if a date could not be calculated with the given input."], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Returns a new Date representing the date calculated by adding an amount of a specific component to a given date.", "method_name": "date", "params": [{"param_type": "Calendar.Component", "param_description": "A single component to add.", "param_name": ["byAdding", "component"]}, {"param_type": "Int", "param_description": "The value of the specified component to add.", "param_name": ["value"]}, {"param_type": "Date", "param_description": "The starting date.", "param_name": ["to", "date"]}, {"param_type": "Bool = false", "param_description": "If true, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is false.", "param_name": ["wrappingComponents"]}], "class_name": "Calendar", "method_declar": "func date(byAdding component: Calendar.Component, value: Int, to date: Date, wrappingComponents: Bool = false) -> Date?", "return_value": {"return_description": ["A new date, or nil if a date could not be calculated with the given input."], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Returns a new Date representing the date calculated by setting a specific component to a given time, and trying to keep lower components the same.  If the component already has that value, this may result in a date which is the same as the given date.", "method_name": "date", "params": [{"param_type": "Calendar.Component", "param_description": "", "param_name": ["bySetting", "component"]}, {"param_type": "Int", "param_description": "", "param_name": ["value"]}, {"param_type": "Date", "param_description": "", "param_name": ["of", "date"]}], "class_name": "Calendar", "method_declar": "func date(bySetting component: Calendar.Component, value: Int, of date: Date) -> Date?", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Returns a new Date representing the date calculated by setting hour, minute, and second to a given time on a specified Date.", "method_name": "date", "params": [{"param_type": "Int", "param_description": "A specified hour.", "param_name": ["bySettingHour", "hour"]}, {"param_type": "Int", "param_description": "A specified minute.", "param_name": ["minute"]}, {"param_type": "Int", "param_description": "A specified second.", "param_name": ["second"]}, {"param_type": "Date", "param_description": "The date to start calculation with.", "param_name": ["of", "date"]}, {"param_type": "Calendar.MatchingPolicy", "param_description": "Specifies the technique the search algorithm uses to find results. Default value is .nextTime.", "param_name": ["matchingPolicy"]}, {"param_type": "Calendar.RepeatedTimePolicy", "param_description": "Specifies the behavior when multiple matches are found. Default value is .first.", "param_name": ["repeatedTimePolicy"]}, {"param_type": "Calendar.SearchDirection = .forward", "param_description": "Specifies the direction in time to search. Default is .forward.", "param_name": ["direction"]}], "class_name": "Calendar", "method_declar": "func date(bySettingHour hour: Int, minute: Int, second: Int, of date: Date, matchingPolicy: Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?", "return_value": {"return_description": ["A Date representing the result of the search, or nil if a result could not be found."], "return_name": [""], "return_type": ["Date"]}, "is_static": false}, {"method_description": "Returns the starting time and duration of a given calendar component that contains a given date.", "method_name": "dateInterval", "params": [{"param_type": "Calendar.Component", "param_description": "A calendar component.", "param_name": ["of", "component"]}, {"param_type": "Date", "param_description": "The specified date.", "param_name": ["for", "date"]}], "class_name": "Calendar", "method_declar": "func dateInterval(of component: Calendar.Component, for date: Date) -> DateInterval?", "return_value": {"return_description": ["A new DateInterval if the starting time and duration of a component could be calculated; otherwise, nil."], "return_name": [""], "return_type": ["DateInterval"]}, "is_static": false}, {"method_description": "Returns, via two inout parameters, the starting time and duration of a given calendar component that contains a given date.", "method_name": "dateInterval", "params": [{"param_type": "Calendar.Component", "param_description": "A calendar component.", "param_name": ["of", "component"]}, {"param_type": "inout Date", "param_description": "Upon return, the starting time of the calendar component that contains the date.", "param_name": ["start"]}, {"param_type": "inout TimeInterval", "param_description": "Upon return, the duration of the calendar component that contains the date.", "param_name": ["interval"]}, {"param_type": "Date", "param_description": "The specified date.", "param_name": ["for", "date"]}], "class_name": "Calendar", "method_declar": "func dateInterval(of component: Calendar.Component, start: inout Date, interval: inout TimeInterval, for date: Date) -> Bool", "return_value": {"return_description": ["true if the starting time and duration of a component could be calculated; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a DateInterval of the weekend contained by the given date, or nil if the date is not in a weekend.", "method_name": "dateIntervalOfWeekend", "params": [{"param_type": "Date", "param_description": "The date contained in the weekend.", "param_name": ["containing", "date"]}], "class_name": "Calendar", "method_declar": "func dateIntervalOfWeekend(containing date: Date) -> DateInterval?", "return_value": {"return_description": ["A DateInterval, or nil if the date is not in a weekend."], "return_name": [""], "return_type": ["DateInterval"]}, "is_static": false}, {"method_description": "Find the range of the weekend around the given date, returned via two by-reference parameters.", "method_name": "dateIntervalOfWeekend", "params": [{"param_type": "Date", "param_description": "The date at which to start the search.", "param_name": ["containing", "date"]}, {"param_type": "inout Date", "param_description": "When the result is true, set", "param_name": ["start"]}, {"param_type": "inout TimeInterval", "param_description": "", "param_name": ["interval"]}], "class_name": "Calendar", "method_declar": "func dateIntervalOfWeekend(containing date: Date, start: inout Date, interval: inout TimeInterval) -> Bool", "return_value": {"return_description": ["true if a date range could be found, and false if the date is not in a weekend."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a DateInterval of the next weekend, which starts strictly after the given date.", "method_name": "nextWeekend", "params": [{"param_type": "Date", "param_description": "The date at which to begin the search.", "param_name": ["startingAfter", "date"]}, {"param_type": "Calendar.SearchDirection = .forward", "param_description": "Which direction in time to search. The default value is .forward.", "param_name": ["direction"]}], "class_name": "Calendar", "method_declar": "func nextWeekend(startingAfter date: Date, direction: Calendar.SearchDirection = .forward) -> DateInterval?", "return_value": {"return_description": ["A DateInterval, or nil if weekends do not exist in the specific calendar or locale."], "return_name": [""], "return_type": ["DateInterval"]}, "is_static": false}, {"method_description": "Returns the range of the next weekend via two inout parameters. The weekend starts strictly after the given date.", "method_name": "nextWeekend", "params": [{"param_type": "Date", "param_description": "The date at which to begin the search.", "param_name": ["startingAfter", "date"]}, {"param_type": "inout Date", "param_description": "", "param_name": ["start"]}, {"param_type": "inout TimeInterval", "param_description": "", "param_name": ["interval"]}, {"param_type": "Calendar.SearchDirection = .forward", "param_description": "Which direction in time to search. The default value is .forward.", "param_name": ["direction"]}], "class_name": "Calendar", "method_declar": "func nextWeekend(startingAfter date: Date, start: inout Date, interval: inout TimeInterval, direction: Calendar.SearchDirection = .forward) -> Bool", "return_value": {"return_description": ["A DateInterval, or nil if the weekend could not be found."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Compares two dates down to the specified component.", "method_name": "compare", "params": [{"param_type": "Date", "param_description": "A date to compare.", "param_name": ["date1"]}, {"param_type": "Date", "param_description": "A date to compare.", "param_name": ["to", "date2"]}, {"param_type": "Calendar.Component", "param_description": "A granularity to compare. For example, pass .hour to check if two dates are in the same hour.", "param_name": ["toGranularity", "component"]}], "class_name": "Calendar", "method_declar": "func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -> ComparisonResult", "return_value": {"return_description": [".orderedSame if the two dates are equal in the given component and all larger components; otherwise, either .orderedAscending or .orderedDescending."], "return_name": [""], "return_type": ["ComparisonResult"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether two dates are equal down to the specified component.", "method_name": "isDate", "params": [{"param_type": "Date", "param_description": "A date to compare.", "param_name": ["date1"]}, {"param_type": "Date", "param_description": "A date to compare.", "param_name": ["equalTo", "date2"]}, {"param_type": "Calendar.Component", "param_description": "A granularity to compare. For example, pass .hour to check if two dates are in the same hour.", "param_name": ["toGranularity", "component"]}], "class_name": "Calendar", "method_declar": "func isDate(_ date1: Date, equalTo date2: Date, toGranularity component: Calendar.Component) -> Bool", "return_value": {"return_description": ["true if the two dates are equal in the given component and all larger components; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether a date is within the same day as another date.", "method_name": "isDate", "params": [{"param_type": "Date", "param_description": "A date to check for containment.", "param_name": ["date1"]}, {"param_type": "Date", "param_description": "A date to check for containment.", "param_name": ["inSameDayAs", "date2"]}], "class_name": "Calendar", "method_declar": "func isDate(_ date1: Date, inSameDayAs date2: Date) -> Bool", "return_value": {"return_description": ["true if date1 and date2 are in the same day, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the given date is within today.", "method_name": "isDateInToday", "params": [{"param_type": "Date", "param_description": "The specified date.", "param_name": ["date"]}], "class_name": "Calendar", "method_declar": "func isDateInToday(_ date: Date) -> Bool", "return_value": {"return_description": ["true if the given date is within today, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the given date is within tomorrow.", "method_name": "isDateInTomorrow", "params": [{"param_type": "Date", "param_description": "The specified date.", "param_name": ["date"]}], "class_name": "Calendar", "method_declar": "func isDateInTomorrow(_ date: Date) -> Bool", "return_value": {"return_description": ["true if the given date is within tomorrow, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the given date is within yesterday.", "method_name": "isDateInYesterday", "params": [{"param_type": "Date", "param_description": "The specified date.", "param_name": ["date"]}], "class_name": "Calendar", "method_declar": "func isDateInYesterday(_ date: Date) -> Bool", "return_value": {"return_description": ["true if the given date is within yesterday, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean value indicating whether the given date is within a weekend period.", "method_name": "isDateInWeekend", "params": [{"param_type": "Date", "param_description": "The specified date.", "param_name": ["date"]}], "class_name": "Calendar", "method_declar": "func isDateInWeekend(_ date: Date) -> Bool", "return_value": {"return_description": ["true if the given date is within a weekend, as defined by the calendar and calendar\u2019s locale; otherwise, false."], "return_name": [""], "return_type": ["Bool"]}, "is_static": false}, {"method_description": "Returns a Boolean indicating whether two calendars are the same.", "method_name": "==", "params": [{"param_type": "Calendar", "param_description": "", "param_name": ["lhs"]}, {"param_type": "Calendar", "param_description": "", "param_name": ["rhs"]}], "class_name": "Calendar", "method_declar": "static func == (lhs: Calendar, rhs: Calendar) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": true}, {"method_description": "Returns a Boolean value indicating whether two values are not equal.", "method_name": "!=", "params": [{"param_type": "Calendar", "param_description": "A value to compare.", "param_name": ["lhs"]}, {"param_type": "Calendar", "param_description": "Another value to compare.", "param_name": ["rhs"]}], "class_name": "Calendar", "method_declar": "static func != (lhs: Calendar, rhs: Calendar) -> Bool", "return_value": {"return_description": [], "return_name": [""], "return_type": ["Bool"]}, "is_static": true}, {"method_description": "Encodes this calendar into the given encoder.", "method_name": "encode", "params": [{"param_type": "Encoder", "param_description": "", "param_name": ["to", "encoder"]}], "class_name": "Calendar", "method_declar": "func encode(to encoder: Encoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}, {"method_description": "Creates a new calendar instance by decoding from the given decoder.", "method_name": "init", "params": [{"param_type": "Decoder", "param_description": "", "param_name": ["from", "decoder"]}], "class_name": "Calendar", "method_declar": "init(from decoder: Decoder) throws", "return_value": {"return_description": [], "return_name": [], "return_type": []}, "is_static": false}], "class_inherit_list": [], "class_name": "Calendar", "typealias": ["typealias Calendar.ReferenceType = NSCalendar"], "Vars": [{"var_description": "A calendar that tracks changes to user\u2019s preferred calendar.", "var_type": "Calendar", "is_static": false, "var_name": "autoupdatingCurrent"}, {"var_description": "The user\u2019s current calendar.", "var_type": "Calendar", "is_static": false, "var_name": "current"}, {"var_description": "The identifier of the calendar.", "var_type": "Calendar.Identifier", "is_static": false, "var_name": "identifier"}, {"var_description": "The locale of the calendar.", "var_type": "Locale", "is_static": false, "var_name": "locale"}, {"var_description": "The first weekday of the calendar.", "var_type": "Int", "is_static": false, "var_name": "firstWeekday"}, {"var_description": "The number of minimum days in the first week.", "var_type": "Int", "is_static": false, "var_name": "minimumDaysInFirstWeek"}, {"var_description": "The time zone of the calendar.", "var_type": "TimeZone", "is_static": false, "var_name": "timeZone"}, {"var_description": "The symbol used to represent \u201cAM\u201d, localized to the Calendar\u2019s locale.", "var_type": "String", "is_static": false, "var_name": "amSymbol"}, {"var_description": "The symbol used to represent \u201cPM\u201d, localized to the Calendar\u2019s locale.", "var_type": "String", "is_static": false, "var_name": "pmSymbol"}, {"var_description": "A list of weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "weekdaySymbols"}, {"var_description": "A list of shorter-named weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortWeekdaySymbols"}, {"var_description": "A list of very-shortly-named weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortWeekdaySymbols"}, {"var_description": "A list of standalone weekday names in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "standaloneWeekdaySymbols"}, {"var_description": "A list of shorter-named standalone weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneWeekdaySymbols"}, {"var_description": "A list of very-shortly-named weekdays in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortStandaloneWeekdaySymbols"}, {"var_description": "A list of months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "monthSymbols"}, {"var_description": "A list of shorter-named months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortMonthSymbols"}, {"var_description": "A list of very-shortly-named months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortMonthSymbols"}, {"var_description": "A list of standalone months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "standaloneMonthSymbols"}, {"var_description": "A list of shorter-named standalone months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneMonthSymbols"}, {"var_description": "A list of very-shortly-named standalone months in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "veryShortStandaloneMonthSymbols"}, {"var_description": "A list of quarter names in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "quarterSymbols"}, {"var_description": "A list of shorter-named quarters in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortQuarterSymbols"}, {"var_description": "A list of standalone quarter names in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "standaloneQuarterSymbols"}, {"var_description": "A list of shorter-named standalone quarters in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "shortStandaloneQuarterSymbols"}, {"var_description": "A list of eras in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "eraSymbols"}, {"var_description": "A list of longer-named eras in this calendar, localized to the Calendar\u2019s locale.", "var_type": "[String]", "is_static": false, "var_name": "longEraSymbols"}, {"var_description": "A textual description of the calendar.", "var_type": "String", "is_static": false, "var_name": "description"}, {"var_description": "A textual description of the locale suitable for debugging.", "var_type": "String", "is_static": false, "var_name": "debugDescription"}, {"var_description": "A mirror that reflects the calendar.", "var_type": "Mirror", "is_static": false, "var_name": "customMirror"}, {"var_description": "The computed hash value for the calendar.", "var_type": "Int", "is_static": false, "var_name": "hashValue"}], "class_type": "struct", "interface_list": ["CustomDebugStringConvertible", "CustomReflectable", "CustomStringConvertible", "Equatable", "Hashable", "ReferenceConvertible"], "package_name": "foundation", "subclass_list": []}